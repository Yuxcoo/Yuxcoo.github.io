<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stay hungry. Stay foolish.</title>
  
  
  <link href="https://blog.icjlu.eu.org/atom.xml" rel="self"/>
  
  <link href="https://blog.icjlu.eu.org/"/>
  <updated>2025-05-22T13:05:46.947Z</updated>
  <id>https://blog.icjlu.eu.org/</id>
  
  <author>
    <name>Yuxico</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode每日一题2025-05-22</title>
    <link href="https://blog.icjlu.eu.org/post/zero-array-transformation-iii.html"/>
    <id>https://blog.icjlu.eu.org/post/zero-array-transformation-iii.html</id>
    <published>2025-05-22T12:27:24.000Z</published>
    <updated>2025-05-22T13:05:46.947Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/zero-array-transformation-iii/">3362. 零数组变换 III</a> M</h1><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个二维数组 <code>queries</code> ，其中 <code>queries[i] = [lᵢ, rᵢ]</code> 。</p><p>每一个 <code>queries[i]</code> 表示对于 <code>nums</code> 的以下操作：</p><ul><li>将 <code>nums</code> 中下标在范围 <code>[lᵢ, rᵢ]</code> 之间的每一个元素 <strong>最多</strong> 减少 1 。</li><li>坐标范围内每一个元素减少的值相互 <strong>独立</strong> 。</li></ul><p><strong>零数组</strong> 指的是一个数组里所有元素都等于 0 。</p><p>请你返回 <strong>最多</strong> 可以从 <code>queries</code> 中删除多少个元素，使得 <code>queries</code> 中剩下的元素仍然能将 <code>nums</code> 变为一个 <strong>零数组</strong> 。如果无法将 <code>nums</code> 变为一个 <strong>零数组</strong> ，返回 -1 。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> nums = [2,0,2], queries = [[0,2],[0,2],[1,1]]</p><p><strong>输出：</strong> 1</p><p><strong>解释：</strong></p><p>删除 <code>queries[2]</code> 后，<code>nums</code> 仍然可以变为零数组。</p><ul><li>对于 <code>queries[0]</code> ，将 <code>nums[0]</code> 和 <code>nums[2]</code> 减少 1 ，将 <code>nums[1]</code> 减少 0 。</li><li>对于 <code>queries[1]</code> ，将 <code>nums[0]</code> 和 <code>nums[2]</code> 减少 1 ，将 <code>nums[1]</code> 减少 0 。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> nums = [1,1,1,1], queries = [[1,3],[0,2],[1,3],[1,2]]</p><p><strong>输出：</strong> 2</p><p><strong>解释：</strong></p><p>可以删除 <code>queries[2]</code> 和 <code>queries[3]</code> 。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> nums = [1,2,3,4], queries = [[0,3]]</p><p><strong>输出：</strong> -1</p><p><strong>解释：</strong></p><p><code>nums</code> 无法通过 <code>queries</code> 变成零数组。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10⁵</code></li><li><code>0 &lt;= nums[i] &lt;= 10⁵</code></li><li><code>1 &lt;= queries.length &lt;= 10⁵</code></li><li><code>queries[i].length == 2</code></li><li><code>0 &lt;= lᵢ &lt;= rᵢ &lt; nums.length</code></li></ul><h2 id="问题分析">问题分析</h2><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数数组 <code>nums</code> 和一个包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个查询的二维数组 <code>queries</code>，其中 <code>queries[i] = [l_i, r_i]</code> 表示对于 <code>nums</code> 执行一次操作：将下标在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l_i, r_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 之间的每个元素最多减少 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>（各位置减少值相互独立）。目标是从原来的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个查询中删除尽可能多的查询，使得剩余查询仍能将 <code>nums</code> 变成全 0 的“零数组”。如果无论如何也不能变成零数组，则返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p><p>关键在于，“每次操作对区间内元素各自减少最多 1” 意味着，若某位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 在剩余操作中被覆盖了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 次，则该位置至多减少 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，要达到最终 <code>nums[i] = 0</code>，就需要</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub><mtext>  </mtext><mo>≥</mo><mtext>  </mtext><mtext>nums</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mtext> </mtext><mo separator="true">,</mo><mspace width="1em"/><mi mathvariant="normal">∀</mi><mtext> </mtext><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">k_i \;\ge\; \text{nums}[i]\,,\quad \forall\,0 \le i &lt; n.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">nums</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∀</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord">.</span></span></span></span></span></p><p>此处每个查询只有两种选择：保留或删除。若保留，就会对它覆盖区间内的各个位置“增加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>”的覆盖次数；若删除，就相当于完全忽略它对覆盖次数的贡献。我们需要在确保对每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，剩余查询的覆盖次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mn>1</mn><mo stretchy="false">{</mo><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><msub><mi>l</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\sum 1\{i \in [l_j, r_j]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mopen">{</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">]}</span></span></span></span> 至少等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>nums</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\text{nums}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">nums</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 的前提下，尽量 <strong>删除</strong> 也就是丢弃尽量多的区间。</p><p>换言之，若最少要保留 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 条区间才能覆盖所有位置的需求，那么最多能删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">m-K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 条。若任何选择都无法满足某位置覆盖次数需求，则返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p><h2 id="算法思路">算法思路</h2><p>本文展示两种思路的实现代码，逻辑不同，但都遵循“贪心地选最需要的区间以满足每个位置的覆盖需求”这一核心原则。</p><h3 id="方法一：按左端点分桶-差分数组-贪心选右端最大的可用区间">方法一：按左端点分桶 + 差分数组 + 贪心选右端最大的可用区间</h3><ol><li><p><strong>按左端点分桶</strong></p><ul><li>事先将所有查询 <code>[l, r]</code> 按其左端点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 归类：用 <code>start_at[l]</code> 存储所有左端为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 的查询的右端 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>。这样在扫描数组位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 时，可以将所有新“激活”的区间（左端恰好是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>）一次性加入到可选集合里。</li></ul></li><li><p><strong>差分数组维护“已选区间覆盖次数”</strong></p><ul><li>用一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的差分数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><annotation encoding="application/x-tex">\mathrm{diffCover}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">diffCover</span></span></span></span></span>，配合一个变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><annotation encoding="application/x-tex">\mathrm{currCover}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">currCover</span></span></span></span></span> 来维护“当前已保留的区间对当前位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的覆盖次数”。矩阵含义如下：<ul><li>当我们决定保留某个区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 时，就执行<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mtext>  </mtext><mo>+</mo><mo>=</mo><mtext>  </mtext><mn>1</mn><mo separator="true">,</mo><mspace width="2em"/><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mtext>  </mtext><mo>−</mo><mtext> ⁣</mtext><mo>=</mo><mtext>  </mtext><mn>1</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\mathrm{diffCover}[l] \;+=\; 1,\qquad \mathrm{diffCover}[r+1] \;-\!=\;1,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">diffCover</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">diffCover</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span></span></span></span></span></p>这样在后续扫描时，位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 所被选中区间覆盖次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{currCover}(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">currCover</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span> 可以通过累加前缀和来得到。</li><li>在扫描到位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 时，先用<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mtext>  </mtext><mo>=</mo><mtext>  </mtext><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{currCover} \;=\; \sum_{j=0}^{i-1} \mathrm{diffCover}[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">currCover</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2254em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">diffCover</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p>（代码中累加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{diffCover}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">diffCover</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><annotation encoding="application/x-tex">\mathrm{currCover}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">currCover</span></span></span></span></span>）以得到“已保留区间对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的覆盖次数”。如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo>&lt;</mo><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{currCover} &lt; \mathrm{nums}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathrm">currCover</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">nums</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，说明还需多选区间来满足位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的需求。</li></ul></li></ul></li><li><p><strong>维护可选区间按右端最大化</strong></p><ul><li>用 <code>availCount[r]</code> 统计当前“可选且未选”且右端恰好为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 的区间数量；用 <code>intervals_by_r[r]</code> 存储这些区间的左端 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>。</li><li>同时维护一个指针 <code>maxR</code>，表示当前所有可选区间中最大的右端。当我们要为当前位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 额外“补覆盖”时，总是“贪心”地优先选取右端最大的区间（因为它能为之后尽可能多的位置提供覆盖机会），即不断从 <code>r = maxR</code> 的组里弹出一条区间 [l_{\text{top}},\,\maxR] 来保留。</li><li>每当保留一条 [l_{\text{top}},\,\maxR]，我们会：<ul><li><code>availCount[maxR] -= 1</code></li><li><code>chosenCount += 1</code>（记录已选区间数）</li><li>更新差分：<code>diffCover[l_top] += 1</code>, <code>diffCover[maxR+1] -= 1</code>，并即时 <code>currCover += 1</code> 因为该区间确实覆盖了当前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>。</li></ul></li><li>如果 <code>availCount[maxR]</code> 变为 0，则将 <code>maxR</code> 不断向左移动至下一个 <code>availCount[r'] &gt; 0</code> 为止（且保持 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>≥</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">r&#x27; \ge i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>），否则就说明没有可选区间能覆盖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，直接返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</li></ul></li><li><p><strong>逐位扫描</strong></p><ul><li>从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，先累加 <code>diffCover[i]</code> 到 <code>currCover</code>，再将左端恰好是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的所有区间“激活”到 <code>availCount</code> 和 <code>intervals_by_r</code>，更新 <code>maxR</code>。</li><li>如果此时 <code>currCover &lt; nums[i]</code>，就在当前可选中右端最大的 <code>maxR</code> 里不断选区间来增加覆盖，直到 <code>currCover &gt;= nums[i]</code> 或者发现无法满足而返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</li><li>这样保证每个位置都至少被覆盖 <code>nums[i]</code> 次。扫描结束后，若没有失败，则记录已保留区间数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">K = \mathrm{chosenCount}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">chosenCount</span></span></span></span></span>，答案即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">m - K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>。</li></ul></li><li><p><strong>数学公式</strong></p><ul><li>差分数组更新公式：<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mtext>  </mtext><mo>+</mo><mo>=</mo><mtext>  </mtext><mn>1</mn><mo separator="true">,</mo><mspace width="1em"/><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mtext>  </mtext><mo>−</mo><mtext> ⁣</mtext><mo>=</mo><mtext>  </mtext><mn>1</mn><mtext> </mtext><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathrm{diffCover}[l] \;+=\;1,\quad \mathrm{diffCover}[r+1]\;-\!=\;1\,.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">diffCover</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">diffCover</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span></span></p></li><li>在扫描到位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 时，已选区间的覆盖次数：<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>=</mo><mtext>  </mtext><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>i</mi></munderover><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mtext> </mtext><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathrm{currCover}(i) \;=\; \sum_{j=0}^i \mathrm{diffCover}[j]\,.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">currCover</span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2254em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">diffCover</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span></span></p></li><li>需要满足：<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>≥</mo><mtext>  </mtext><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mspace width="1em"/><mi mathvariant="normal">∀</mi><mtext> </mtext><mi>i</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathrm{currCover}(i) \;\ge\; \mathrm{nums}[i],\quad \forall\,i.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">currCover</span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">nums</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∀</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mord">.</span></span></span></span></span></p></li></ul></li></ol><h3 id="方法二：按左端排序-最大堆-差分前缀">方法二：按左端排序 + 最大堆 + 差分前缀</h3><ol><li><p><strong>将查询按左端 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 升序排序</strong></p><ul><li>令 <code>queries.sort(key=lambda x: x[0])</code>，并用指针 <code>j</code> 遍历所有查询。当扫描到数组位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 时，顺便把所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>≤</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">l \le i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的区间逐一推入堆中。</li></ul></li><li><p><strong>用最大堆维护“已激活的区间按右端降序”</strong></p><ul><li>在Python里，我们用 <code>heapq</code>，但由于它是最小堆，我们将右端 $r` 取负数存入堆，实际效果是“堆顶”对应最大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>。</li><li>当扫描到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，先将左端 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\le i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的所有区间都 <code>heappush(h, -r)</code>。</li></ul></li><li><p><strong>差分数组 <code>diff</code> 记录“当前已选区间对后续位置的累积覆盖影响”</strong></p><ul><li>初始化 <code>diff = [0]*(n+1)</code>，并维护一个前缀和 <code>sum_d = 0</code>。含义是：<code>sum_d = \sum_&#123;k=0&#125;^&#123;i-1&#125; diff[k]</code>。</li><li>当我们保留一条区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 时，执行：<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi></mrow><mo stretchy="false">[</mo><mtext> </mtext><mi>r</mi><mo>+</mo><mn>1</mn><mtext> </mtext><mo stretchy="false">]</mo><mtext>  </mtext><mo>+</mo><mtext> ⁣</mtext><mo>=</mo><mtext>  </mtext><mo>−</mo><mn>1</mn><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mtext>因为 pos </mtext><mstyle scriptlevel="0" displaystyle="false"><mo>&gt;</mo><mi>r</mi></mstyle><mtext> 时覆盖计数会减少</mtext></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{diff}[\,r+1\,] \;+\!=\; -1\quad(\text{因为 pos $&gt;r$ 时覆盖计数会减少})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.07778em;">diff</span></span><span class="mopen">[</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">+</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord cjk_fallback">因为</span><span class="mord"> pos </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"> </span><span class="mord cjk_fallback">时覆盖计数会减少</span></span><span class="mclose">)</span></span></span></span></span></p>并且在选区间时，立刻做 <code>sum_d -= 1</code> 并计入已选区间计数 <code>k += 1</code>，相当于该区间“直接覆盖了当前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>”，所以对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 之后的所有位置在 <code>sum_d</code> 上预先扣了 1。总之，这里将覆盖量通过一维差分转换成后缀影响。</li></ul></li><li><p><strong>遍历数组</strong></p><ul><li>对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，先做 <code>sum_d += diff[i]</code>。此时 <code>sum_d</code> 代表“由之前保留的区间，在当前位置及其之后还能继续贡献的覆盖次数”与当前位置应有的需求 <code>-nums[i]</code> 做对比：<ul><li>因为我们维持 <code>sum_d</code> 是负数时表示对当前位置仍需额外 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>d</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-sum_d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的“补覆盖”。</li></ul></li><li>如果 <code>sum_d &lt;= -nums[i]</code>，说明当前已有保留区间的覆盖就足够满足 <code>nums[i]</code>，不需要额外选。</li><li>否则，就不断从堆中弹出右端最大的区间（即 <code>-heap[0]</code> 最大），若弹出区间的右端 $r` <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\ge i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，就保留它：<ul><li>执行 <code>diff[r+1] += 1</code>（意味着在位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 开始，“覆盖贡献”减少 1），</li><li><code>sum_d -= 1</code>，<code>k += 1</code>。</li></ul></li><li>重复弹区间直到 <code>sum_d &lt;= -nums[i]</code> 或堆空或堆顶区间右端 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">&lt; i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>（此时堆里所有剩余区间都无法覆盖当前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，直接返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>）。</li><li>如果循环结束后仍然 <code>sum_d &gt; -nums[i]</code>，说明无法达到需求，返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</li></ul></li><li><p><strong>答案</strong></p><ul><li>如果整个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0..</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=0..n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0..</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 都顺利通过，记录保留的区间数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">K = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，则最多能删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">m - K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>。</li></ul></li></ol><h2 id="时间复杂度">时间复杂度</h2><ul><li><p><strong>方法一</strong></p><ul><li>构建 <code>start_at</code> 要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，差分数组大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li><li>遍历每个位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 时：<ul><li>将左端恰为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的区间激活到 <code>availCount</code> 和 <code>intervals_by_r</code>，总共需要把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 条区间分配一次，属于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</li><li>在最坏情况下，每个位置都可能进行一次或多次“选区间”操作，总共最多选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 条区间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">K \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，每次更新差分和 <code>maxR</code> 都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 或者 <code>maxR</code> 左移 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 次的摊销。</li></ul></li><li>因此总体时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</li></ul></li><li><p><strong>方法二</strong></p><ul><li>先对查询排序 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\log m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</li><li>遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0..</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0..n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0..</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，每步：<ul><li>把左端 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\le i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的查询压入堆，所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 条均只入一次堆，总共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\log m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</li><li>弹堆操作最多也是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\log m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</li><li>差分数组前缀 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">sum_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的累加是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul></li><li>因此总复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\log m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 远大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，则主要开销在堆操作上。</li></ul></li></ul><h2 id="代码分解">代码分解</h2><h3 id="方法一">方法一</h3><ol><li><strong>构建 <code>start_at</code> 列表</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start_at = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> idx, (l, r) <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries):</span><br><span class="line">    start_at[l].append(r)</span><br></pre></td></tr></table></figure></li></ol><p>意味着 <code>start_at[i]</code> 内存储所有左端为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的查询的右端 <code>r</code>。</p><ol><li><p><strong>初始化辅助数组和变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diffCover = [<span class="number">0</span>] * (n + <span class="number">1</span>)   <span class="comment"># 差分数组</span></span><br><span class="line">currCover = <span class="number">0</span>              <span class="comment"># 前缀和，表示当前位置已有覆盖</span></span><br><span class="line">chosenCount = <span class="number">0</span>            <span class="comment"># 已保留区间数</span></span><br><span class="line">availCount = [<span class="number">0</span>] * n       <span class="comment"># 右端为 r 的“可选未选”区间数量</span></span><br><span class="line">intervals_by_r = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># 记录右端 r 下的各左端 l</span></span><br><span class="line">maxR = n - <span class="number">1</span>               <span class="comment"># 当前可选区间的最大右端</span></span><br></pre></td></tr></table></figure></li><li><p><strong>从 i=0…n-1 扫描</strong></p><ul><li><p>累加差分：<code>currCover += diffCover[i]</code>。</p></li><li><p>将所有 <code>l=i</code> 的区间激活：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> start_at[i]:</span><br><span class="line">    availCount[r] += <span class="number">1</span></span><br><span class="line">    intervals_by_r[r].append(i)</span><br><span class="line">    <span class="keyword">if</span> r &gt; maxR: maxR = r</span><br></pre></td></tr></table></figure></li><li><p>“剔除过期”并维护 <code>maxR &gt;= i &amp;&amp; availCount[maxR] &gt; 0</code>。</p></li><li><p>若 <code>currCover &lt; nums[i]</code>，就要补选区间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> currCover &lt; nums[i]:</span><br><span class="line">    <span class="keyword">if</span> maxR &lt; i: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 取出右端 = maxR 的一个可选区间</span></span><br><span class="line">    l_top = intervals_by_r[maxR].pop()</span><br><span class="line">    availCount[maxR] -= <span class="number">1</span></span><br><span class="line">    chosenCount += <span class="number">1</span></span><br><span class="line">    currCover += <span class="number">1</span></span><br><span class="line">    diffCover[l_top] += <span class="number">1</span></span><br><span class="line">    diffCover[maxR + <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> availCount[maxR] == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># maxR 不断左移</span></span><br><span class="line">        <span class="keyword">while</span> maxR &gt;= i <span class="keyword">and</span> (availCount[maxR] == <span class="number">0</span>):</span><br><span class="line">            maxR -= <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>若循环结束时 <code>currCover &gt;= nums[i]</code>，位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 满足需求，继续下一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p></li></ul></li><li><p><strong>返回结果</strong></p><ul><li>如果遍历结束都没出错，最少要保留 <code>chosenCount</code> 条，最多可删除 <code>m - chosenCount</code>。否则中途返回 <code>-1</code>。</li></ul></li></ol><h3 id="方法二">方法二</h3><ol><li><p><strong>排序与初始化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queries.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">h = []</span><br><span class="line">diff = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">q, j = <span class="built_in">len</span>(queries), <span class="number">0</span></span><br><span class="line">k = sum_d = <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><code>h</code> 为堆（Python 默认最小堆，用 <code>-r</code> 保存便于每次弹出最大右端）。</li><li><code>diff[i]</code> 存储差分：一旦保留区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，就对 <code>diff[r+1] += 1</code> 来表示“从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 开始，后缀不再被此区间覆盖”。</li><li><code>sum_d</code> 追踪前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的差分前缀和。</li></ul></li><li><p><strong>遍历 nums</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">    sum_d += diff[i]</span><br><span class="line">    <span class="comment"># 如果已有覆盖 sum_d &lt;= -x，说明已满足 nums[i]</span></span><br><span class="line">    <span class="keyword">if</span> sum_d &lt;= -x:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 否则，把左端 &lt;= i 的所有区间压堆</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; q <span class="keyword">and</span> queries[j][<span class="number">0</span>] &lt;= i:</span><br><span class="line">        heapq.heappush(h, -queries[j][<span class="number">1</span>])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 弹堆，补选最大的右端区间</span></span><br><span class="line">    <span class="keyword">while</span> sum_d &gt; -x <span class="keyword">and</span> h <span class="keyword">and</span> -h[<span class="number">0</span>] &gt;= i:</span><br><span class="line">        r = -heapq.heappop(h)</span><br><span class="line">        diff[r + <span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        sum_d -= <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 若无法满足需求，则失败</span></span><br><span class="line">    <span class="keyword">if</span> sum_d &gt; -x:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> q - k</span><br></pre></td></tr></table></figure><ul><li>对每个位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，先 <code>sum_d += diff[i]</code>。此时若 <code>sum_d &lt;= -nums[i]</code>，说明此前已选的区间覆盖次数充足；否则进入补选。</li><li>在补选阶段，只要当前 <code>sum_d &gt; -nums[i]</code>，且堆顶区间的右端 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>≥</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">r \ge i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，就可以选取它：<code>sum_d -= 1</code> 立刻反映“当前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 被此区间覆盖”；<code>diff[r+1] += 1</code> 表示“在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 处去掉这条区间后续的覆盖贡献”。</li><li>若在此之后仍不能满足，则直接返回 <code>-1</code>。</li></ul></li></ol><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxRemoval</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(nums), <span class="built_in">len</span>(queries)</span><br><span class="line">        <span class="comment"># 1. 把所有区间按左端点 l 分桶</span></span><br><span class="line">        <span class="comment">#    start_at[i] 里存的，是所有左端点恰好为 i 的查询 (r)</span></span><br><span class="line">        start_at = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> idx, (l, r) <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries):</span><br><span class="line">            start_at[l].append(r)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 差分数组 diffCover 用于维护“已选区间到当前位置 i 的覆盖次数”</span></span><br><span class="line">        diffCover = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        currCover = <span class="number">0</span>    <span class="comment"># 当前在 i 处，已选的区间一共覆盖了多少次</span></span><br><span class="line">        chosenCount = <span class="number">0</span>  <span class="comment"># 已经保留（选中）的区间数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. availCount[r] 统计：目前“可选”且尚未被选的“右端点恰好等于 r”的区间有多少条</span></span><br><span class="line">        availCount = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="comment"># intervals_by_r[r] 存储：当区间 [l,r] 一被激活，就把它的 l push 到这里</span></span><br><span class="line">        intervals_by_r = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 用一个指针 maxR 来指向“当前可选区间里最大的 r”</span></span><br><span class="line">        maxR = n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 从 i=0..n-1 依次扫描</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># ——(A) 先把 diffCover[i] 累到 currCover 上</span></span><br><span class="line">            currCover += diffCover[i]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># ——(B) 把左端点 l = i 的区间全部“激活”</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> start_at[i]:</span><br><span class="line">                availCount[r] += <span class="number">1</span></span><br><span class="line">                intervals_by_r[r].append(i)</span><br><span class="line">                <span class="keyword">if</span> r &gt; maxR:</span><br><span class="line">                    maxR = r</span><br><span class="line"></span><br><span class="line">            <span class="comment"># ——(C) 剔除过期的 r：保证 maxR ≥ i 且 availCount[maxR] &gt; 0</span></span><br><span class="line">            <span class="keyword">while</span> maxR &gt;= i <span class="keyword">and</span> (availCount[maxR] == <span class="number">0</span>):</span><br><span class="line">                maxR -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># ——(D) 如果 currCover &lt; nums[i]，就必须“贪心地”从 r = maxR 开始选区间补覆盖</span></span><br><span class="line">            <span class="keyword">while</span> currCover &lt; nums[i]:</span><br><span class="line">                <span class="keyword">if</span> maxR &lt; i:</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 从 intervals_by_r[maxR] 中 pop 出一个左端 l_top</span></span><br><span class="line">                l_top = intervals_by_r[maxR].pop()</span><br><span class="line">                availCount[maxR] -= <span class="number">1</span></span><br><span class="line">                chosenCount += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 该区间覆盖了当前 i，立刻补一个 currCover</span></span><br><span class="line">                currCover += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 差分更新：对 [l_top, maxR] 内所有位置各 +1</span></span><br><span class="line">                diffCover[l_top] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> maxR + <span class="number">1</span> &lt; <span class="built_in">len</span>(diffCover):</span><br><span class="line">                    diffCover[maxR + <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果 maxR 组里已无可选区间，继续将 maxR 左移</span></span><br><span class="line">                <span class="keyword">while</span> maxR &gt;= i <span class="keyword">and</span> (availCount[maxR] == <span class="number">0</span>):</span><br><span class="line">                    maxR -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 至此 currCover ≥ nums[i]，安全进入 i+1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 扫完所有 i，没有失败</span></span><br><span class="line">        <span class="keyword">return</span> m - chosenCount</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxRemoval</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 将 queries 按左端升序排序</span></span><br><span class="line">        queries.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        h = []  <span class="comment"># 最大堆（用负的 r 存储）</span></span><br><span class="line">        diff = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">        q, j = <span class="built_in">len</span>(queries), <span class="number">0</span></span><br><span class="line">        k = sum_d = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 更新前缀和</span></span><br><span class="line">            sum_d += diff[i]</span><br><span class="line">            <span class="comment"># 如果已有 sum_d &lt;= -x，则说明已满足 nums[i]，继续</span></span><br><span class="line">            <span class="keyword">if</span> sum_d &lt;= -x:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将左端 &lt;= i 的所有查询压入堆</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; q <span class="keyword">and</span> queries[j][<span class="number">0</span>] &lt;= i:</span><br><span class="line">                heapq.heappush(h, -queries[j][<span class="number">1</span>])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 弹堆补选右端最大的区间，直到满足需求或堆空/无法覆盖</span></span><br><span class="line">            <span class="keyword">while</span> sum_d &gt; -x <span class="keyword">and</span> h <span class="keyword">and</span> -h[<span class="number">0</span>] &gt;= i:</span><br><span class="line">                r = -heapq.heappop(h)</span><br><span class="line">                <span class="comment"># 差分更新，位置 r+1 开始对后缀去掉一个覆盖</span></span><br><span class="line">                diff[r + <span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                sum_d -= <span class="number">1</span></span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果仍然不够覆盖，返回 -1</span></span><br><span class="line">            <span class="keyword">if</span> sum_d &gt; -x:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 能完成覆盖，最多删除 q - k</span></span><br><span class="line">        <span class="keyword">return</span> q - k</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/zero-array-transformation-iii/&quot;&gt;3362. 零数组变换 III&lt;/a&gt; M&lt;/h1&gt;
&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;n</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="数据结构" scheme="https://blog.icjlu.eu.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="中等" scheme="https://blog.icjlu.eu.org/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="贪心" scheme="https://blog.icjlu.eu.org/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="状态建模" scheme="https://blog.icjlu.eu.org/tags/%E7%8A%B6%E6%80%81%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="优先队列" scheme="https://blog.icjlu.eu.org/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="差分数组" scheme="https://blog.icjlu.eu.org/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
    <category term="区间覆盖" scheme="https://blog.icjlu.eu.org/tags/%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-21</title>
    <link href="https://blog.icjlu.eu.org/post/zero-array-transformation-ii.html"/>
    <id>https://blog.icjlu.eu.org/post/zero-array-transformation-ii.html</id>
    <published>2025-05-21T13:24:40.000Z</published>
    <updated>2025-05-21T15:04:49.170Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/zero-array-transformation-ii/">3356. 零数组变换 II</a> M</h1><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个二维数组 <code>queries</code>，其中 <code>queries[i] = [lᵢ, rᵢ, valᵢ]</code>。</p><p>每个 <code>queries[i]</code> 表示在 <code>nums</code> 上执行以下操作：</p><ul><li>将 <code>nums</code> 中 <code>[lᵢ, rᵢ]</code> 范围内的每个下标对应元素的值 <strong>最多</strong> 减少 <code>valᵢ</code>。</li><li>每个下标的减少的数值可以<strong>独立</strong>选择。</li></ul><p><strong>零数组</strong> 是指所有元素都等于 0 的数组。</p><p>返回 <code>k</code> 可以取到的 <strong>最小非负</strong> 值，使得在 <strong>顺序</strong> 处理前 <code>k</code> 个查询后，<code>nums</code> 变成 <strong>零数组</strong>。如果不存在这样的 <code>k</code>，则返回 -1。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> nums = [2,0,2], queries = [[0,2,1],[0,2,1],[1,1,3]]</p><p><strong>输出：</strong> 2</p><p><strong>解释：</strong></p><ul><li>对于 i = 0（l = 0, r = 2, val = 1）：<ul><li>在下标 <code>[0, 1, 2]</code> 处分别减少 <code>[1, 0, 1]</code>。</li><li>数组将变为 <code>[1, 0, 1]</code>。</li></ul></li><li>对于 i = 1（l = 0, r = 2, val = 1）：<ul><li>在下标 <code>[0, 1, 2]</code> 处分别减少 <code>[1, 0, 1]</code>。</li><li>数组将变为 <code>[0, 0, 0]</code>，这是一个零数组。因此，<code>k</code> 的最小值为 2。</li></ul></li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> nums = [4,3,2,1], queries = [[1,3,2],[0,2,1]]</p><p><strong>输出：</strong> -1</p><p><strong>解释：</strong></p><ul><li>对于 i = 0（l = 1, r = 3, val = 2）：<ul><li>在下标 <code>[1, 2, 3]</code> 处分别减少 <code>[2, 2, 1]</code>。</li><li>数组将变为 <code>[4, 1, 0, 0]</code>。</li></ul></li><li>对于 i = 1（l = 0, r = 2, val = 1）：<ul><li>在下标 <code>[0, 1, 2]</code> 处分别减少 <code>[1, 1, 0]</code>。</li><li>数组将变为 <code>[3, 0, 0, 0]</code>，这不是一个零数组。</li></ul></li></ul></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10⁵</code></li><li><code>0 &lt;= nums[i] &lt;= 5 * 10⁵</code></li><li><code>1 &lt;= queries.length &lt;= 10⁵</code></li><li><code>queries[i].length == 3</code></li><li><code>0 &lt;= lᵢ &lt;= rᵢ &lt; nums.length</code></li><li><code>1 &lt;= valᵢ &lt;= 5</code></li></ul><h2 id="问题分析">问题分析</h2><p>要找最小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> ，使得对 <code>nums</code> 执行前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 条查询后，可以将数组完全凑成“零数组”。每条查询 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><mtext> </mtext><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mtext> </mtext><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l_i,\,r_i,\,v_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 表示在区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l_i,r_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 内，各下标位置最多各自减少 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，每个位置可以独立选减少多少。</p><p>我们定义一个“<strong>剩余需求</strong>”数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，它表示下标 iii 要变成 0，还需要从查询里“累计扣除”多少。<br>初始时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mtext mathvariant="monospace">nums</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i] = \texttt{nums}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord texttt">nums</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。随着我们“依次”处理第 1 条、第 2 条、…、第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 条查询，每执行一条查询，就要把它对区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 内的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><annotation encoding="application/x-tex">\mathrm{rem}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathrm">rem</span></span></span></span></span> 统一**“减去”** <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>（注意：如果该条查询本身要求的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，其实“最多”减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 的含义对应我们在代码里直接减；因为之后我们会在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i] \le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时“收集答案”并且把它标记为不再参与后续运算——详见下文）。</p><p>当且仅当某个位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 经历了若干次涵盖它的查询以后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 的值变得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，就说明“对下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 而言，它已经完全被扣成 0 了”。我们记录下最先使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> “跨到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>”的那条查询的编号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">idx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span>，记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>i</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\mathrm{ans}[i] = idx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span>。如果直到所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 条查询都跑完，它仍未被扣到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\mathrm{ans}[i]=+\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span> （或用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 表示“永远扣不成 0”）。</p><p>最后，只要所有下标都能在某个时刻“跨到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>”，那么整个数组才能凑成零。令</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>K</mi><mo>=</mo><munder><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow></munder><mtext>  </mtext><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mtext> </mtext><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">K = \max_{0 \le i &lt; n}\; \mathrm{ans}[i]\,.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5728em;vertical-align:-0.8228em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.3723em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8228em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span></span></p><p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">K \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，则答案就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>；否则（存在某个位置从未走到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>），答案返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p><h2 id="算法思路">算法思路</h2><p><strong>区间减与“找最小非正下标”</strong></p><p><strong>“给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mtext> </mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[\,]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">]</span></span></span></span> 做一次 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间统一减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>”</strong></p><p><strong>“询问当前整个数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mtext> </mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[\,]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">]</span></span></span></span> 的最小值，检查它是否 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>；如果是，把那个位置取出来，记录答案，并把它从后续运算中剔除。”</strong></p><p>要想在<strong>每执行一条查询</strong>之后，快速做到“把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>l</mi><mo>…</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[l \ldots r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 整个区间都减掉 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>”，并能检查是否有位置跨到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，最常用的办法就是<strong>线段树（带懒标记）的“区间减一次，区间查询最小值”</strong>。具体思路如下：</p><p>我们把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 维护在一棵线段树上，线段树的每个节点记录该区间当前的最小 rem 值（即 minv），同时支持“区间减去 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>”的<strong>懒标记</strong>（节点上加一个 <code>lazy</code> 值表示要向下传递的减量）。</p><p>我们还需要一个额外操作：<strong>“如果整个区间的最小值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，就找出一个下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i] \leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。”</strong></p><p>由于线段树根节点存储了全区间（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0..</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0..n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0..</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）的最小值，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>tree</mtext><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mtext>minv</mtext></mrow><annotation encoding="application/x-tex">\text{tree}[1].\text{minv}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">tree</span></span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mord">.</span><span class="mord text"><span class="mord">minv</span></span></span></span></span>，只要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>tree</mtext><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mtext>minv</mtext><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{tree}[1].\text{minv} \leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">tree</span></span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mord">.</span><span class="mord text"><span class="mord">minv</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，就说明至少有一个叶子节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i] \leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><p>此时我们可以从根节点向下递归：</p><ul><li><p>如果左子节点的 minv <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，就优先进入左子树，否则进入右子树。</p></li><li><p>不断递归，直到定位到某个叶节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，它的 <code>minv</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，这就是当前“最小 <code>rem</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>”对应的下标。</p></li></ul><p>找到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 之后，我们将线段树中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 设为一个很大的正数（比如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">+\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span>，实际代码里用足够大的常数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>INF</mtext><mo>=</mo><msup><mn>10</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">\text{INF}=10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">INF</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">18</span></span></span></span></span></span></span></span></span></span></span></span>）。这样，相当于把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 从后续所有区间减法操作中移除，该下标不再参与后面的判 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 检查。</p><p>只要“线段树根节点 <code>minv</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>”，就不断进行“找 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">+\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span>，并记录 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>ans</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mtext>当前查询编号</mtext></mrow><annotation encoding="application/x-tex">\text{ans}[i]=\text{当前查询编号}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">当前查询编号</span></span></span></span></span>”操作；循环直到根节点最小值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，然后进入下一条查询。</p><h2 id="时间复杂度">时间复杂度</h2><ol><li><p>线段树建树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p></li><li><p>先把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{nums}[i]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">nums</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的那些下标提取一次，总共操作次数最多 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 次“找 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> + 单点置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">F</mi></mrow><annotation encoding="application/x-tex">\mathrm{INF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">INF</span></span></span></span></span>”，每次 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，合计 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p></li><li><p>针对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 条查询，每条：</p><ol><li>区间减一次 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li><li>紧接着最多有若干个新下标跨到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem} \le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，反复做“找 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> + 置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">F</mi></mrow><annotation encoding="application/x-tex">\mathrm{INF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">INF</span></span></span></span></span>” 若干次。<ul><li>每个下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 只会从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem}&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 变到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem}\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 一次，因此<strong>所有</strong>“找 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 并置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">F</mi></mrow><annotation encoding="application/x-tex">\mathrm{INF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">INF</span></span></span></span></span>”操作总共不会超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 次，每次 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li></ul></li></ol></li><li><p>所以总复杂度为：</p><ul><li>建树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>查找与置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">F</mi></mrow><annotation encoding="application/x-tex">\mathrm{INF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">INF</span></span></span></span></span> 总共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>区间减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 次 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>最终为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((n+m)\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul></li></ol><ul><li>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，主要用于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><annotation encoding="application/x-tex">\mathrm{rem}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathrm">rem</span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">\mathrm{ans}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathrm">ans</span></span></span></span></span> 以及线段树节点（最多约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">4n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span></span></span></span>）。</li></ul><h2 id="代码分解">代码分解</h2><ol><li><strong>初始化</strong></li></ol><ul><li><p>读入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mo stretchy="false">(</mo><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">s</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">n = \mathrm{len(nums)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">len</span><span class="mopen">(</span><span class="mord mathrm">nums</span><span class="mclose">)</span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mo stretchy="false">(</mo><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">m = \mathrm{len(queries)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">len</span><span class="mopen">(</span><span class="mord mathrm">queries</span><span class="mclose">)</span></span></span></span></span>。</p></li><li><p>用一个数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><annotation encoding="application/x-tex">\mathrm{rem}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathrm">rem</span></span></span></span></span>，大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i] = \mathrm{nums}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">nums</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。</p></li><li><p>用一个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的答案数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">\mathrm{ans}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathrm">ans</span></span></span></span></span>，全部初始化成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">F</mi></mrow><annotation encoding="application/x-tex">\mathrm{INF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">INF</span></span></span></span></span>（或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，表示“还没被扣到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>”）。</p></li><li><p>提前把所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的下标视作“在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 条查询就能扣到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>”：</p><ul><li><p>构建一棵线段树，把每个叶子节点的初始值设成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。</p></li><li><p>线段树内置“最小值”信息，建完之后如果根节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{minv} == 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">minv</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，就说明某些下标初始就 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。我们要<strong>在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 步</strong>（即不执行任何查询）就把它们提取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> tree_root.minv ≤ <span class="number">0</span>:</span><br><span class="line">    i = query_index_of_some_leaf_with_minv≤<span class="number">0</span>()</span><br><span class="line">    ans[i] = <span class="number">0</span></span><br><span class="line">    update_leaf(i, +INF)   <span class="comment"># 把 rem[i] 设为 +INF，等于“干掉它”</span></span><br></pre></td></tr></table></figure></li><li><p>这样，所有初始 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{nums}[i]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">nums</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的位置就有了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{ans}[i]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p></li></ul></li></ul><ol start="2"><li><strong>按查询编号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1..</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">1..m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1..</span><span class="mord mathnormal">m</span></span></span></span> 依次处理</strong></li></ol><p>对于当前处理到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">idx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span>（1-based）的查询 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mi>d</mi><mi>x</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{queries}[idx-1] = [l, r, v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">queries</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>，执行：</p><ul><li><p>在线段树上对区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 做“整体再减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>” （用懒标记方式）。</p></li><li><p>更新完毕后，检查线段树的根节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><annotation encoding="application/x-tex">\mathrm{minv}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">minv</span></span></span></span></span> 是否 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>：</p><ul><li><p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{minv} &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.707em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">minv</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，说明这时候没有任何下标的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem} \le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，直接跳到下一条查询（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>x</mi><mo>+</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">idx += 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）。</p></li><li><p>否则，反复循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> tree_root.minv ≤ <span class="number">0</span>:</span><br><span class="line">    i = 找到某个叶子下标 i，使得 rem[i] ≤ <span class="number">0</span></span><br><span class="line">    ans[i] = idx</span><br><span class="line">    update_leaf(i, +INF)   <span class="comment"># 将该位置从后续考虑中剔除</span></span><br></pre></td></tr></table></figure></li><li><p>上述循环结束代表此时所有还在树里的“rem”都已 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，可以处理下一条查询。</p></li></ul></li></ul><ol start="3"><li><strong>遍历结束后，计算最终答案</strong></li></ol><ul><li>对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{ans}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 做一次遍历：如果有下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 永远都没被扣到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{ans}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 保持初始的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">F</mi></mrow><annotation encoding="application/x-tex">\mathrm{INF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">INF</span></span></span></span></span>），说明它不可能凑成零，直接返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</li><li>否则，答案 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><msub><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow></msub><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K = \max_{0 \le i &lt; n} \mathrm{ans}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2452em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。返回此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>。</li></ul><ol start="4"><li><p>我们需要实现一个支持以下操作的线段树（0-based）：</p></li><li><p><strong>建树（build）</strong>：把初始数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 的值装进去，构建出“每个区间的最小值”。</p></li><li><p><strong>区间减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>q</mi><mi>l</mi><mo separator="true">,</mo><mi>q</mi><mi>r</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(ql, qr, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">ql</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></strong>：在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>q</mi><mi>l</mi><mo separator="true">,</mo><mi>q</mi><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[ql, qr]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">ql</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 这段，所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 都要再减去 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>。</p><ul><li>通过在节点打“懒标记 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">z</mi></mrow><mo stretchy="false">[</mo><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">\mathrm{lz}[node] += v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">lz</span></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>”让该节点下所有值都“虚拟地”减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，并在需要时把懒标记下传给左右子节点。</li></ul></li><li><p><strong>询问全局最小 (query_min())</strong>：直接从根节点读出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{tree}[1].\mathrm{minv}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">tree</span></span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mord">.</span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">minv</span></span></span></span></span>。</p></li><li><p><strong>找某个满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i]\leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></strong>：</p><ul><li>如果当前根节点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{minv} &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.707em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">minv</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，说明没有任何 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的叶子，直接返回“无”。</li><li>否则从根节点开始，若左子节点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{minv} \leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8038em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">minv</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 就往左子树走；否则往右子树。直到到叶子，拿到具体下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>。</li></ul></li><li><p><strong>把一个下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>“标记为已完成”</strong>：在叶子层将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 直接置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">F</mi></mrow><annotation encoding="application/x-tex">\mathrm{INF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">INF</span></span></span></span></span>（足够大的正数），然后向上拉一次更新父节点的最小值。这样后续它就不会再被判 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p></li></ol><p>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n\le 10^{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>，线段树最多需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">4n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span></span></span></span> 个节点。所有操作的单次复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="代码实现">代码实现</h2><p><strong>初始化时把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{nums}[i]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">nums</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的下标提前提取</strong></p><ul><li>一开始建树完毕后，就把所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i] == 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的下标（也就是原始 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{nums}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">nums</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 已经是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）用“查询编号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>”直接记录在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{ans}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，然后在树里把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">F</mi></mrow><annotation encoding="application/x-tex">\mathrm{INF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">INF</span></span></span></span></span>（等价于把它从后续所有区间操作和“再查 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>”中干掉）。</li><li>这样做的好处是：如果某个位置原本就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，就不需要等待任何真正的查询，它的答案就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</li></ul><p><strong>每条查询后“区间整体再减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>”</strong></p><ul><li>使用线段树带懒标记的区间减操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">b</mi></mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{range\_sub}(1, 0, n-1, l, r, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathrm">range_sub</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>，单次复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li><li>更新完毕以后，只需要检查树根的最小值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{query\_global\_min}()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathrm">query_global_min</span></span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 是否 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。<ul><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，说明目前没有新的下标变得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem} \le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，直接进入下一条查询。</li><li>否则，循环“找一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的叶子” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>0</mn></msub><mo>=</mo><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i_0 = \mathrm{find\_any\_nonpos}(1, 0, n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathrm">find_any_nonpos</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，把它的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><msub><mi>i</mi><mn>0</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{ans}[i_0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 设为当前查询编号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">idx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span>，再在树里把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><msub><mi>i</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo>=</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">F</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i_0]=\mathrm{INF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">INF</span></span></span></span></span>，并向上更新维护最小值。循环直到树根最小值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</li></ul></li></ul><p><strong>最后的答案 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></strong></p><ul><li>只要所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 都在某个时刻跨到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathrm{rem}[i] \le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">rem</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，它们的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{ans}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 就是一个落在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0..</mn><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0..m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0..</span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span> 的整数。此时答案 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><msub><mrow><mi>max</mi><mo>⁡</mo></mrow><mi>i</mi></msub><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K = \max_i \mathrm{ans}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。</li><li>如果有某个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{ans}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ans</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 始终保持 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">F</mi></mrow><annotation encoding="application/x-tex">\mathrm{INF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">INF</span></span></span></span></span>，说明它从来没被扣到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arr: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="variable language_">self</span>.minv = [<span class="number">0</span>] * (<span class="number">4</span> * <span class="variable language_">self</span>.n)</span><br><span class="line">        <span class="variable language_">self</span>.lazy = [<span class="number">0</span>] * (<span class="number">4</span> * <span class="variable language_">self</span>.n)</span><br><span class="line">        <span class="variable language_">self</span>.INF = <span class="number">10</span>**<span class="number">18</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">node, l, r</span>):</span><br><span class="line">            <span class="keyword">if</span> l == r:</span><br><span class="line">                <span class="variable language_">self</span>.minv[node] = arr[l]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mid = (l + r) // <span class="number">2</span></span><br><span class="line">                build(node * <span class="number">2</span>, l, mid)</span><br><span class="line">                build(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r)</span><br><span class="line">                <span class="variable language_">self</span>.minv[node] = <span class="built_in">min</span>(<span class="variable language_">self</span>.minv[node * <span class="number">2</span>], <span class="variable language_">self</span>.minv[node * <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span>, <span class="number">0</span>, <span class="variable language_">self</span>.n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_apply_lazy</span>(<span class="params">self, node, delta</span>):</span><br><span class="line">        <span class="variable language_">self</span>.minv[node] -= delta</span><br><span class="line">        <span class="variable language_">self</span>.lazy[node] += delta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_push_down</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.lazy[node] != <span class="number">0</span>:</span><br><span class="line">            delta = <span class="variable language_">self</span>.lazy[node]</span><br><span class="line">            <span class="variable language_">self</span>._apply_lazy(node * <span class="number">2</span>, delta)</span><br><span class="line">            <span class="variable language_">self</span>._apply_lazy(node * <span class="number">2</span> + <span class="number">1</span>, delta)</span><br><span class="line">            <span class="variable language_">self</span>.lazy[node] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_push_up</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="variable language_">self</span>.minv[node] = <span class="built_in">min</span>(<span class="variable language_">self</span>.minv[node * <span class="number">2</span>], <span class="variable language_">self</span>.minv[node * <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">range_sub</span>(<span class="params">self, node, l, r, ql, qr, v</span>):</span><br><span class="line">        <span class="keyword">if</span> ql &lt;= l <span class="keyword">and</span> r &lt;= qr:</span><br><span class="line">            <span class="variable language_">self</span>._apply_lazy(node, v)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._push_down(node)</span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> qr &lt;= mid:</span><br><span class="line">            <span class="variable language_">self</span>.range_sub(node * <span class="number">2</span>, l, mid, ql, qr, v)</span><br><span class="line">        <span class="keyword">elif</span> ql &gt; mid:</span><br><span class="line">            <span class="variable language_">self</span>.range_sub(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, v)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.range_sub(node * <span class="number">2</span>, l, mid, ql, qr, v)</span><br><span class="line">            <span class="variable language_">self</span>.range_sub(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, v)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._push_up(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query_global_min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.minv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_any_nonpos</span>(<span class="params">self, node, l, r</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.minv[node] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._push_down(node)</span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.minv[node * <span class="number">2</span>] &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.find_any_nonpos(node * <span class="number">2</span>, l, mid)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.find_any_nonpos(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_inf</span>(<span class="params">self, node, l, r, idx</span>):</span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="variable language_">self</span>.minv[node] = <span class="variable language_">self</span>.INF</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._push_down(node)</span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> idx &lt;= mid:</span><br><span class="line">            <span class="variable language_">self</span>.set_inf(node * <span class="number">2</span>, l, mid, idx)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.set_inf(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, idx)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._push_up(node)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minZeroArray</span>(<span class="params">self, nums, queries</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        m = <span class="built_in">len</span>(queries)</span><br><span class="line">        rem = nums[:]</span><br><span class="line">        INF = <span class="number">10</span>**<span class="number">18</span></span><br><span class="line">        ans = [INF] * n</span><br><span class="line">        st = SegmentTree(rem)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理原本就为0的下标</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> st.query_global_min() &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i0 = st.find_any_nonpos(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> i0 == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            ans[i0] = <span class="number">0</span></span><br><span class="line">            st.set_inf(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i0)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 依次处理每条查询</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            l, r, v = queries[idx - <span class="number">1</span>]</span><br><span class="line">            st.range_sub(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, l, r, v)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> st.query_global_min() &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                i0 = st.find_any_nonpos(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> i0 == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> ans[i0] == INF:</span><br><span class="line">                    ans[i0] = idx</span><br><span class="line">                st.set_inf(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i0)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否全部 &lt;= 0</span></span><br><span class="line">        final_ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> ans[i] == INF:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            final_ans = <span class="built_in">max</span>(final_ans, ans[i])</span><br><span class="line">        <span class="keyword">return</span> final_ans</span><br></pre></td></tr></table></figure><h2 id="算法思路2">算法思路2</h2><ol><li><p><strong>差分+验证模型</strong></p><ul><li><p>对于某个固定的 k（只考虑前 k 条查询），要判断是否能把 nums 完全减为 0，需要检查每个位置 i 在这 k 条查询中，允许的“最大累计减量”之和是否 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\geq nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。</p></li><li><p>原因：每个查询在覆盖区间 [l, r] 内，对位置 i 可以最多减去 v；若该位置被多条查询覆盖，那么这些查询各自能提供的“最大减量额度”加起来，就形成了“可用的整体减量上限”。只有当前 k 条查询对位置 i 的“减量额度之和” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span> nums[i]，才能让它有机会被减到 0。</p></li><li><p>判定条件转化为：</p><blockquote><p>定义数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mtext> </mtext><msub><mi>l</mi><mi>j</mi></msub><mo>≤</mo><mi>i</mi><mo>≤</mo><msub><mi>r</mi><mi>j</mi></msub></mrow></msubsup><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">cap[i] = \sum_{j=0}^{k-1,\ l_j \leq i \leq r_j} v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4412em;vertical-align:-0.413em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0282em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2421em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。<br>如果对所有 i 都有 cap[i] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span> nums[i]，则这 k 条查询可以通过合理分配将 nums 全部扣为 0。否则不能。</p></blockquote></li></ul></li><li><p>计算 cap[]——<strong>差分+前缀和</strong></p><ul><li><p>维护一个长度为 n+1 的差分数组 diff，初始化全为 0。</p></li><li><p>对于查询 [l, r, v]（下标从 0 开始），做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff[l] += v</span><br><span class="line">diff[r+1] -= v</span><br></pre></td></tr></table></figure></li><li><p>所有前 k 条查询都更新后，对 diff 做一次前缀和，在线性时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 内得到每个位置 i 的 cap[i]。</p></li><li><p>最后只需检验：对每个 i，cap[i] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span> nums[i] 吗？</p></li></ul></li><li><p><strong>二分查找</strong></p><ul><li>如果对于某个 k₀ 满足“前 k₀ 条查询可以凑出零数组”，则对于任何 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><msub><mi>k</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">k \geq k_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，cap[i] 只会更大，所以“可行性”是单调的。</li><li>可在 [0, m] 区间二分，找第一个可行的 k。若整个区间都不可，返回 -1。</li></ul></li><li><p>实现思路</p><ul><li><p>定义函数 check(k)：判断前 k 条查询能否凑成零数组<br>a. 初始化长度为 n+1 的 diff 数组，全 0。<br>b. 对于 j=0…k-1，每条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>l</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l_j, r_j, v_j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>：执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mo stretchy="false">[</mo><msub><mi>l</mi><mi>j</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">diff[l_j] += v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>j</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>−</mo><mo>=</mo><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">diff[r_j+1] -= v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。<br>c. 对 diff 做前缀和，得到 cap 数组长度为 n：cap[i] = 能够提供给位置 i 的累计减量额度。<br>d. 遍历 i=0…n-1，如果 cap[i] &lt; nums[i]，直接返回 False；否则全部通过返回 True。</p></li><li><p>在主函数，对 k 在 [0, m] 做二分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a. lo = 0, hi = m, answer = m+1。</span><br><span class="line">b. while lo $\leq$ hi：</span><br><span class="line">    mid = (lo+hi)//2</span><br><span class="line">    if check(mid)：answer = mid; hi = mid-1</span><br><span class="line">    else：lo = mid+1</span><br><span class="line">c. 最终如果 answer $$\leq$$ m 则返回 answer，否则返回 -1。</span><br></pre></td></tr></table></figure></li><li><p>允许 k = 0 进入 check(0)：没有任何查询时，只有当 nums 全为 0 才判通过。</p></li></ul></li></ol><p><strong>时间复杂度</strong></p><ul><li>一次 check(k)：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。</li><li>二分最多调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 次。</li><li>总复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((n+m)\log m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</li></ul><p><strong>空间复杂度</strong></p><ul><li>差分数组 diff 长度 n+1，cap 长度 n，以及 zerolithx 变量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minZeroArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        m = <span class="built_in">len</span>(queries)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查函数：检查前 k 条查询能否把 nums 减为零数组</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="comment"># 差分数组，长度 n+1，初始全 0</span></span><br><span class="line">            diff = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果 k &gt; 0，则把前 k 条查询都叠加到 diff 上</span></span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                l, r, v = queries[idx]</span><br><span class="line">                diff[l] += v</span><br><span class="line">                <span class="keyword">if</span> r + <span class="number">1</span> &lt; n:</span><br><span class="line">                    diff[r + <span class="number">1</span>] -= v</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 前缀和得到 cap[i]，并随即验证 cap[i] 是否 &gt;= nums[i]</span></span><br><span class="line">            running = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                running += diff[i]</span><br><span class="line">                <span class="comment"># cap[i] = running</span></span><br><span class="line">                <span class="keyword">if</span> running &lt; nums[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 在 k ∈ [0, m] 上二分，寻找最小的 k 使 check(k) 为 True</span></span><br><span class="line">        lo, hi = <span class="number">0</span>, m</span><br><span class="line">        answer = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                answer = mid</span><br><span class="line">                hi = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer <span class="keyword">if</span> answer &lt;= m <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法思路3">算法思路3</h2><p>我们需要求出最小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，使得“前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 条查询”能够<strong>同时</strong>满足</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∀</mi><mtext> </mtext><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi><mo separator="true">,</mo><mspace width="1em"/><munder><mo>∑</mo><mstyle scriptlevel="1"><mtable rowspacing="0.1em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="1" displaystyle="false"><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>k</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="1" displaystyle="false"><mrow><msub><mi>l</mi><mi>j</mi></msub><mo>≤</mo><mi>i</mi><mo>≤</mo><msub><mi>r</mi><mi>j</mi></msub></mrow></mstyle></mtd></mtr></mtable></mstyle></munder><msub><mi>v</mi><mi>j</mi></msub><mtext>  </mtext><mtext>  </mtext><mo>≥</mo><mtext>  </mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\forall\,0 \le i &lt; n,\quad \sum_{\substack{0 \le j &lt; k \\ l_j \le i \le r_j}} v_j \;\; \ge\; nums[i].</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord">∀</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1717em;vertical-align:-2.1216em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.5062em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1826em;"><span style="top:-3.1882em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.2993em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6826em;"><span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1216em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">.</span></span></span></span></span></p><p>如果把</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>cap</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>=</mo><mtext>  </mtext><munder><mo>∑</mo><mstyle scriptlevel="1"><mtable rowspacing="0.1em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="1" displaystyle="false"><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>k</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="1" displaystyle="false"><mrow><msub><mi>l</mi><mi>j</mi></msub><mo>≤</mo><mi>i</mi><mo>≤</mo><msub><mi>r</mi><mi>j</mi></msub></mrow></mstyle></mtd></mtr></mtable></mstyle></munder><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\text{cap}[i](k) \;=\; \sum_{\substack{0 \le j &lt; k \\ l_j \le i \le r_j}} v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">cap</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1717em;vertical-align:-2.1216em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.5062em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1826em;"><span style="top:-3.1882em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.2993em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0197em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6826em;"><span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1216em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>看作“在下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 处，前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 条查询最多能提供的扣减总量”，那么题目要求找最小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>cap</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>≥</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> </mtext><mi mathvariant="normal">∀</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">\text{cap}[i](k) \ge nums[i],\,\forall i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">cap</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∀</span><span class="mord mathnormal">i</span></span></span></span>。<br>这本质上等同于：对每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，我们单独去看“最早满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>cap</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>≥</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\text{cap}[i](k) \ge nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">cap</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 的那个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>”；答案就是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo>=</mo><munder><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow></munder><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k = \max_{0 \le i &lt; n} k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5173em;vertical-align:-0.8228em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.3723em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8228em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>（如果某个位置永远加不够，那整个答案就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。）</p><ul><li><p><strong>贪心地求出每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的思路</strong></p><ul><li><p>把下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 依次“排队”，</p></li><li><p>维护一个“差分数组” <code>cnt[0..n]</code>，它可以让我们以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的方式“把新的一条查询 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b, v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span> 加入到以后所有下标的可用额度里”：</p><ul><li><code>cnt[a] += v; cnt[b+1] -= v</code>，</li><li>然后每推进一个下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 时，只要做 <code>s += cnt[i]</code>，就能得到“前面已经加入到差分结构的那些查询，在位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 处的总叠加额度”。</li></ul></li><li><p>于是，如果当前 <code>s &lt; nums[i]</code>（说明已经加到差分里的查询还不够把 <code>nums[i]</code> 扣成 0），我们就<strong>继续</strong>把第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 条、第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 条……查询“投进来”——也就是执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt[a_j] += v_j</span><br><span class="line">cnt[b_j + <span class="number">1</span>] -= v_j</span><br></pre></td></tr></table></figure></li></ul><p>在差分里给它记号，然后如果这条新加的查询确实覆盖到了位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>（<code>if a_j &lt;= i &lt;= b_j</code>），就 <code>s += v_j</code>，因为此时“对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>”就立刻生效——把 <code>s</code> 补 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。</p><ul><li>只要 <code>s</code> 还小于 <code>nums[i]</code>，就再把下一条查询“投进来”，直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>≥</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s \ge nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 或者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">j == m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>（查完所有查询）为止。<ul><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s &lt; nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">j == m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，说明“所有查询投完”都还是凑不够<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，直接 <code>return -1</code>。</li><li>否则在“退出 while”后，必然有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>≥</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s \ge nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，说明此时我们已经用了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 条查询第一个时刻让 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 处达标。把这个“时刻”记下来，对更大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 来说，我们不会再减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>，因为我们要保证所有小于当前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的下标也都满足。在前面迭代过的所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">i&#x27; &lt; i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 都已经被保证：它们的 “累计额度” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span> “我们此刻用的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 条查询的额度”，自然它们也都能凑够。</li></ul></li><li>最终结束所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 就是满足每个位置的需求（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>cap</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≥</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\text{cap}[i] \ge nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">cap</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>）的 <strong>最小</strong> 查询数。<ul><li>若有任何一个 iii 走到一半就发现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 用光、又<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s &lt; nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，就 <code>return -1</code>。</li><li>反之，最后返回的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 恰好等同于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>max</mi><mo>⁡</mo></mrow><mi>i</mi></msub><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\max_i k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul></li></ul></li></ul><p><strong>时间复杂度</strong></p><ul><li>外层 <code>for i in range(n)</code> 总共循环 <code>n</code> 次。</li><li>内部的 <code>while j &lt; m and s &lt; nums[i]</code>：<ul><li>每次循环体都会做一次 <code>j += 1</code>，因此 <code>j</code> 最多从 0 增加到 <code>m</code>，循环体总共进不超过 <code>m</code> 次。</li><li>换句话说，所有 <code>i</code> 累积在一起，<code>j</code> 只会单调增长，从 0 到最多 <code>m</code>，绝不会回退或重复。</li></ul></li><li>差分 <code>cnt[a] += c; cnt[b+1] -= c;</code> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 操作。</li><li>每进 <code>for i</code> 一次，都先做 <code>s += cnt[i]</code>，也是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li><li>其余判断、下标范围判断、加法、比较都只是常数操作。</li></ul><p>因此，总体的执行步骤：</p><ol><li>外层走 <code>n</code> 步（<code>i = 0 … n-1</code>）。</li><li>内层的 <code>j</code> 累计至多走 <code>m</code> 步（从 <code>j=0</code> 一直加到不满足条件为止）。</li></ol><p>没有任何嵌套导致 <code>m</code> 与 <code>n</code> 相乘，只是把这两段“线性扫描”交织在一起，最终耗时正好 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</p><p><strong>代码实现</strong></p><ul><li><p><code>n = len(nums)</code>，<code>m = len(queries)</code>。</p></li><li><p><code>cnt</code> 是一个长度为 <code>n+1</code> 的「差分数组」，用于在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间内模拟对任意区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> 做一次 “所有下标各自减去 c” 的操作。</p><ul><li><p>当我们想对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> 区间整体去掉 “最多减 c” 这一额度时，就写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt[a] += c</span><br><span class="line">cnt[b+<span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure></li><li><p>然后在遍历到下标 <code>i</code> 时，保留一个滚动变量 <code>s</code>，先做 <code>s += cnt[i]</code>，此时 <code>s</code> 就相当于 “下标 i 处所有已加入（也就是 <code>j</code> 之前的）查询对 i 的累积可用额度之和”。</p></li></ul></li><li><p><code>s</code>： 表示“当前下标 <code>i</code> 被所有已用查询（前 <code>j</code> 条）覆盖时累计能减去的总量”。</p></li><li><p><code>j</code>：代表「已经把 <code>queries[0], queries[1], …, queries[j-1]</code> 这 <code>j</code> 条查询全部用到差分 <code>cnt</code> 里了」。</p></li></ul><p>从 <code>i=0</code> 开始，遍历每个位置 <code>i</code>，保证在走到下标 <code>i</code> 时，<code>s</code>（累积能减的额度）足以满足 <code>nums[i]</code>。如果 <code>s &lt; nums[i]</code>，就再从 <code>queries[j]</code> 开始把第 <code>j</code> 条、第 <code>j+1</code> 条……不断「添加到差分」直到让 <code>s &gt;= nums[i]</code> 或者查询用完为止。一旦 <code>s &lt; nums[i]</code> 并且 <code>j == m</code>（没有更多查询可加），就无法把 <code>nums[i]</code> 扣到 0，直接 <code>return -1</code>。如果所有 <code>i</code> 都能满足过，那么用到的查询数就是 <code>j</code>，返回它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minZeroArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(nums), <span class="built_in">len</span>(queries)</span><br><span class="line">        cnt = [<span class="number">0</span>] * (n + <span class="number">1</span>)   <span class="comment"># 差分数组，长度 n+1</span></span><br><span class="line">        s = <span class="number">0</span>                 <span class="comment"># 当前在下标 i 处的“累计已减”总量</span></span><br><span class="line">        j = <span class="number">0</span>                 <span class="comment"># 已经用了多少条查询</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 1) 先把差分 cnt[i] 累加到 s，得到“到下标 i 时，所有已用查询对 i 的累积贡献”：</span></span><br><span class="line">            s += cnt[i]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 2) 如果到目前位置 i，s &lt; nums[i]，说明“还不够把 nums[i] 扣成 0”</span></span><br><span class="line">            <span class="comment">#    那就从 queries[j] 开始，依次把第 j 条查询加进来，直到 s &gt;= nums[i] 或 j 用完为止</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> s &lt; nums[i]:</span><br><span class="line">                a, b, c = queries[j]</span><br><span class="line">                <span class="comment"># 把 queries[j] 对区间 [a, b] 的“最多减 c”转化成差分:</span></span><br><span class="line">                cnt[a] += c</span><br><span class="line">                cnt[b + <span class="number">1</span>] -= c</span><br><span class="line">                <span class="comment"># 如果 i 恰好被 [a,b] 覆盖，那么要立刻把 s += c，因为在下标 i 处，这条查询就生效了</span></span><br><span class="line">                <span class="keyword">if</span> a &lt;= i &lt;= b:</span><br><span class="line">                    s += c</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 3) 退出 while 以后，要么 s &gt;= nums[i]，说明“前 j 条查询对 i 的累计贡献至少 nums[i]”，可以把 nums[i] 扣到0；</span></span><br><span class="line">            <span class="comment">#    要么 j == m 且 s &lt; nums[i]，说明所有查询都用完了，i 处还是扣不够，直接返回 -1</span></span><br><span class="line">            <span class="keyword">if</span> s &lt; nums[i]:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4) 如果走到这里，说明对所有 0 ≤ i &lt; n，都有 “前 j 条查询能把 nums[i] 扣成 0”。</span></span><br><span class="line">        <span class="comment">#    此时 j 就是最小 k，使得处理前 k 条查询后，nums 全部变成零数组。</span></span><br><span class="line">        <span class="keyword">return</span> j</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>差分数组 cnt + 滚动和 s</strong></p><ul><li>当我们刚进入循环、到达 <code>i</code> 时，用 <code>s += cnt[i]</code> 把“这一格的前缀差分”补上。</li><li>这样 <code>s</code> 始终表示“所有已经加进 <code>cnt</code> 的查询，对 <code>i</code> 这个位置在累计能减的总量”——与我们要的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>cap</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\text{cap}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">cap</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 一一对应。</li></ul><p><strong>while j&lt;m and s&lt;nums[i] 里“如果 a≤i≤b 就 s += c”</strong></p><ul><li>这一步很重要：我们先在差分里做了 <code>cnt[a]+=c; cnt[b+1]-=c</code>，这保证了“从下标 <code>a</code> 开始”到“下标 <code>b</code> 结束”每个位置最终前缀和会多 <code>c</code>。</li><li>但是此时指针还在 <code>i</code> 上，如果 <code>a ≤ i ≤ b</code>，说明这个新加的区间 <strong>立刻影响</strong> 到了位置 <code>i</code>，所以 <code>s</code> 要马上加上那份 <code>c</code>。</li><li>如果 <code>i &lt; a</code> 或者 <code>i &gt; b</code>，新加的区间对 <code>i</code> 还不生效（会在后面 <code>i</code> 推到 <code>a</code> 时再生效，具体表现为执行到 <code>i=a</code> 后的 <code>s += cnt[a]</code> 就扣上去了）。</li></ul><p><strong>一旦 s &lt; nums[i] 且 j==m，直接返回 -1</strong></p><ul><li>因为此时所有 <code>m</code> 条查询都加入到差分里，可是走到 <code>i</code> 时却依旧 <code>s &lt; nums[i]</code>，说明在 <strong>所有查询</strong> 覆盖的累积额度下，<code>nums[i]</code> 也凑不成 0，后面没办法了。</li></ul><p><strong>最小性保证：贪心不会跳过更优解</strong></p><ul><li>你需要最小的 <code>j</code>，使得每个位置的“累积额度”都足够。如果在某个 <code>i</code> 上，<code>s &lt; nums[i]</code>，你就一定要把 <code>queries[j]</code> 拿出来打一把，才能继续往前走——否则你根本没法保证这个 <code>i</code> 处的需求被满足。</li><li>你无法“跳过”某条查询，因为如果你不把它算在内，<code>s</code> 不可能「突然」跳到够用。</li><li>另一方面，一旦满足了 <code>i</code>，你也不会再撤回以前的查询——因为如果你撤回，就可能会让更小的下标变得不满足。但要想让 <strong>所有</strong> 下标都凑够，只能向右“多用”查询或者“用到恰好满足”为止。</li><li>因此你在 “遇到 <code>i</code> 还不够就把查询往里扔” 这一步上，实际上是严格按下标顺序寻找每个 <code>i</code> 的最早 “凑够它的那条查询编号”。这样遍历完所有 <code>i</code>，得到的 <code>j</code> 恰好就是最大的那一个“把 <code>i</code> 扣成 0 的查询编号”；也就是等同于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>max</mi><mo>⁡</mo></mrow><mi>i</mi></msub><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\max_i k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/zero-array-transformation-ii/&quot;&gt;3356. 零数组变换 II&lt;/a&gt; M&lt;/h1&gt;
&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;num</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="数据结构" scheme="https://blog.icjlu.eu.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="中等" scheme="https://blog.icjlu.eu.org/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="前缀和" scheme="https://blog.icjlu.eu.org/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="双指针" scheme="https://blog.icjlu.eu.org/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="二分查找" scheme="https://blog.icjlu.eu.org/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="贪心" scheme="https://blog.icjlu.eu.org/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="线段树" scheme="https://blog.icjlu.eu.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-20</title>
    <link href="https://blog.icjlu.eu.org/post/zero-array-transformation-i.html"/>
    <id>https://blog.icjlu.eu.org/post/zero-array-transformation-i.html</id>
    <published>2025-05-20T12:23:42.000Z</published>
    <updated>2025-05-20T13:14:37.014Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/zero-array-transformation-i/">3355. 零数组变换 I</a> M</h1><p>给定一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个二维数组 <code>queries</code>，其中 <code>queries[i] = [li, ri]</code>。</p><p>对于每个查询 <code>queries[i]</code>：</p><ul><li>在 <code>nums</code> 的下标范围 <code>[li, ri]</code> 内选择一个下标 子集。</li><li>将选中的每个下标对应的元素值减 1。</li></ul><p><strong>零数组</strong> 是指所有元素都等于 0 的数组。</p><p>如果在按顺序处理所有查询后，可以将 <code>nums</code> 转换为 <strong>零数组</strong> ，则返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> nums = [1,0,1], queries = [[0,2]]</p><p><strong>输出：</strong> true</p><p><strong>解释：</strong></p><ul><li>对于 i = 0：<ul><li>选择下标子集 <code>[0, 2]</code> 并将这些下标处的值减 1。</li><li>数组将变为 <code>[0, 0, 0]</code>，这是一个零数组。</li></ul></li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> nums = [4,3,2,1], queries = [[1,3],[0,2]]</p><p><strong>输出：</strong> false</p><p><strong>解释：</strong></p><ul><li>对于 i = 0：<ul><li>选择下标子集 <code>[1, 2, 3]</code> 并将这些下标处的值减 1。</li><li>数组将变为 <code>[4, 2, 1, 0]</code>。</li></ul></li><li>对于 i = 1：<ul><li>选择下标子集 <code>[0, 1, 2]</code> 并将这些下标处的值减 1。</li><li>数组将变为 <code>[3, 1, 0, 0]</code>，这不是一个零数组。</li></ul></li></ul></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10⁵</code></li><li><code>0 &lt;= nums[i] &lt;= 10⁵</code></li><li><code>1 &lt;= queries.length &lt;= 10⁵</code></li><li><code>queries[i].length == 2</code></li><li><code>0 &lt;= lᵢ &lt;= rᵢ &lt; nums.length</code></li></ul><h2 id="问题分析">问题分析</h2><p>给定长度为 <em>n</em> 的整数数组 <code>nums</code> 和 <em>m</em> 个查询 <code>queries[i] = [l_i, r_i]</code>。对于每个查询，我们可以在区间 <code>[l_i, r_i]</code> 内任意选取一些下标，将这些位置对应的元素减 1。要在“按顺序”处理完所有 <em>m</em> 个查询之后，将原始数组 <code>nums</code> 变成“零数组”（即所有元素都恰好被减为 0），需要满足：</p><blockquote><p>对于每个位置 <code>j</code>，它最终被减去的次数必须恰好等于 <code>nums[j]</code>。<br>而每次查询只能在它指定的区间内对某个位置减 1，并且每个查询对同一个位置最多减 1 次。</p></blockquote><h2 id="算法思路">算法思路</h2><p>设 <code>cover[j]</code> 表示有多少个查询区间 <code>[l_i, r_i]</code> 覆盖位置 <code>j</code>。</p><p>如果 <code>cover[j] &lt; nums[j]</code>，那么位置 <code>j</code> 即使在所有能覆盖它的查询中都“选中”它去减 1，最大也只能被减 <code>cover[j]</code> 次，仍然无法将 <code>nums[j]</code> 减到 0，直接返回 <code>false</code>。</p><p>如果对每个 <code>j</code> 都满足 <code>cover[j] &gt;= nums[j]</code>，理论上我们可以在所有覆盖 <code>j</code> 的查询中选取任意 <code>nums[j]</code> 次去对 <code>j</code> 减 1。由于不同位置的选择互不干扰（每次查询可以对区间内任意多个下标同时减 1，没有上限），只要每个位置都有足够的“机会”被减，就能找到一种方案使得最终所有位置正好被减到 0。</p><p>考虑“按顺序”执行查询的限制：即使我们在前面的查询选择了“跳过”某些位置，只要剩下“未来的查询”依然足够覆盖剩余需要减的次数字段，就没问题。实际上，只需满足总体上 <code>cover[j] &gt;= nums[j]</code> 即可，因为可以把对于每个 <code>j</code> 的 <code>nums[j]</code> 次减操作安排在它被覆盖的最后 <code>nums[j]</code> 个查询上。</p><ol><li><p>先用一个差分数组（长度 <code>n+1</code>）来累积每个查询对各下标的覆盖次数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">diff = new int[n+1];</span><br><span class="line">对于每个 query = [l, r]:</span><br><span class="line">    diff[l] += 1;</span><br><span class="line">    diff[r+1] -= 1;    // 若 r+1 越界则跳过</span><br><span class="line">再对 diff 做前缀和，得到 cover[0…n-1]。</span><br></pre></td></tr></table></figure></li><li><p>这样就能在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 的时间内算出 <code>cover[j]</code> = 该下标被多少查询覆盖。</p></li><li><p>遍历 <code>j=0…n-1</code>，若发现 <code>cover[j] &lt; nums[j]</code>，立即返回 <code>false</code>。</p></li><li><p>如果所有 <code>j</code> 都通过检查，则返回 <code>true</code>。</p></li></ol><h2 id="时间复杂度">时间复杂度</h2><ul><li>差分数组初始化及累计： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></li><li>计算前缀和： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>最终逐位检查： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br>整体为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>（存储 diff/cover）。</li><li>使用了长度为 <code>n+1</code> 的差分数组 <code>diff</code>，以及长度为 <code>n</code> 的覆盖次数数组 <code>cover</code>，总计 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 额外空间。</li></ul><h2 id="代码分解">代码分解</h2><ol><li>差分数组 <code>diff</code> 在索引 <code>l</code> 处 +1、在 <code>r+1</code> 处 −1，最终对 <code>diff</code> 做前缀和就相当于：每个查询在 <code>[l, r]</code> 区间内为 <code>cover[j]</code> 累加了 1。</li><li>得到的 <code>cover[j]</code> 就是“有多少个查询区间覆盖位置 j”。</li><li>对于位置 <code>j</code> 来说，如果总共被覆盖的次数少于它当前需要减的次数 <code>nums[j]</code>，无论怎么选都不够，将来无法把它减到 0；否则只要“用掉”它需要的 <code>nums[j]</code> 次就行。</li><li>由于不同下标在同一次查询中是否选取互不干扰（每次查询可以对区间里任意子集进行减操作），所以只用全局判断 <code>cover[j] &gt;= nums[j]</code> 即可。</li></ol><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isZeroArray</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>], queries: <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        m = <span class="built_in">len</span>(queries)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 构造差分数组 diff，长度为 n+1，初始全 0</span></span><br><span class="line">        diff = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (l, r) <span class="keyword">in</span> queries:</span><br><span class="line">            diff[l] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r + <span class="number">1</span> &lt; n:</span><br><span class="line">                diff[r + <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 用 diff 计算前缀和，得到 cover[j]</span></span><br><span class="line">        cover = [<span class="number">0</span>] * n</span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            curr += diff[j]</span><br><span class="line">            cover[j] = curr</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 检查每个位置 j：如果被查询覆盖的次数 &lt; nums[j]，则不可能</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> cover[j] &lt; nums[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 全部通过，说明可以分配减操作，返回 True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/zero-array-transformation-i/&quot;&gt;3355. 零数组变换 I&lt;/a&gt; M&lt;/h1&gt;
&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;nums&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="数据结构" scheme="https://blog.icjlu.eu.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="中等" scheme="https://blog.icjlu.eu.org/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="前缀和" scheme="https://blog.icjlu.eu.org/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="贪心" scheme="https://blog.icjlu.eu.org/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-19</title>
    <link href="https://blog.icjlu.eu.org/post/type-of-triangle.html"/>
    <id>https://blog.icjlu.eu.org/post/type-of-triangle.html</id>
    <published>2025-05-19T08:13:48.000Z</published>
    <updated>2025-05-19T08:27:40.650Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/type-of-triangle/">3024. 三角形类型</a> E</h1><p>给你一个下标从 <strong>0</strong> 开始长度为 <code>3</code> 的整数数组 <code>nums</code> ，需要用它们来构造三角形。</p><ul><li>如果一个三角形的所有边长度相等，那么这个三角形称为 <strong>equilateral</strong> 。</li><li>如果一个三角形恰好有两条边长度相等，那么这个三角形称为 <strong>isosceles</strong> 。</li><li>如果一个三角形三条边的长度互不相同，那么这个三角形称为 <strong>scalene</strong> 。</li></ul><p>如果这个数组无法构成一个三角形，请你返回字符串 <code>&quot;none&quot;</code> ，否则返回一个字符串表示这个三角形的类型。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [3,3,3]<br>输出：“equilateral”<br>解释：由于三条边长度相等，所以可以构成一个等边三角形，返回 “equilateral” 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [3,4,5]<br>输出：“scalene”<br>解释：<br>nums[0] + nums[1] = 3 + 4 = 7 ，大于 nums[2] = 5 。<br>nums[0] + nums[2] = 3 + 5 = 8 ，大于 nums[1] = 4 。<br>nums[1] + nums[2] = 4 + 5 = 9 ，大于 nums[0] = 3 。<br>由于任意两边之和都大于第三边，所以可以构成一个三角形，因为三条边的长度互不相等，所以返回 “scalene”。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>nums.length == 3</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="问题分析">问题分析</h2><p>给定三个正整数边长 <code>nums[0], nums[1], nums[2]</code>，判断它们能否构成三角形。如果不能，返回 <code>&quot;none&quot;</code>；如果可以，再根据三边相等情况返回对应类型：</p><ul><li>三条边相等 → <code>equilateral</code></li><li>正好两条边相等 → <code>isosceles</code></li><li>三条边互不相等 → <code>scalene</code></li></ul><h2 id="算法思路">算法思路</h2><p>首先，对这三个边长进行排序（标签：排序），记为 <code>a ≤ b ≤ c</code>。排序不仅能让后续判断更清晰，也方便验证三角形的必要且充分条件，只需要判断 <code>a + b &gt; c</code> 即可。</p><p>如果 <code>a + b ≤ c</code>，则无法构成三角形，直接返回 <code>&quot;none&quot;</code>。</p><p>否则，根据 <code>a, b, c</code> 三者是否相等做分类：</p><ul><li>如果 <code>a == c</code>，说明三条边都相等，返回 <code>&quot;equilateral&quot;</code>。</li><li>否则如果 <code>a == b</code> 或 <code>b == c</code>，则恰有两条相等，返回 <code>&quot;isosceles&quot;</code>。</li><li>否则三条边互不相等，返回 <code>&quot;scalene&quot;</code>。</li></ul><h2 id="时间复杂度">时间复杂度</h2><ul><li><p>对 <code>nums</code> 长度为 3 的数组排序，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>（可以认为是常数级操作）。其余比较操作也是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。因此整体时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p></li><li><p>空间复杂度也为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，只使用了常数级的额外变量。</p></li></ul><h2 id="代码分解">代码分解</h2><p><strong>排序</strong>：对 <code>[x, y, z]</code> 三个数进行排序，得到 <code>a ≤ b ≤ c</code>。排序的本质是为了简化三角形最基本的判定：只需判断最小的两个数之和是否大于最大的数即可。此时不必反复考虑全部三种两边之和情况，因为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>&gt;</mo><mi>c</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>&gt;</mo><mi>c</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>+</mo><mi>c</mi><mo>&gt;</mo><mi>b</mi><mtext>(总是成立，因为 </mtext><mi>c</mi><mo>≥</mo><mi>b</mi><mtext>)</mtext><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>b</mi><mo>+</mo><mi>c</mi><mo>&gt;</mo><mi>a</mi><mtext>(总是成立，因为 </mtext><mi>c</mi><mo>≥</mo><mi>a</mi><mtext>)</mtext><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">a + b &gt; c \iff   \begin{cases}     a + b &gt; c, \\     a + c &gt; b \text{(总是成立，因为 } c \ge b\text{)},\\     b + c &gt; a \text{(总是成立，因为 } c \ge a\text{)}.   \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span><span class="mord text"><span class="mord">(</span><span class="mord cjk_fallback">总是成立，因为</span><span class="mord"> </span></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span><span class="mord text"><span class="mord">)</span></span><span class="mpunct">,</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">a</span><span class="mord text"><span class="mord">(</span><span class="mord cjk_fallback">总是成立，因为</span><span class="mord"> </span></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">a</span><span class="mord text"><span class="mord">)</span></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>若 <code>a + b ≤ c</code>，直接返回 <code>&quot;none&quot;</code>。</p><p>否则，继续比较 <code>a, b, c</code>：</p><ul><li>若 <code>a == c</code>，三个元素全等 → <code>equilateral</code>。</li><li>若 <code>a == b</code> 或 <code>b == c</code>，则恰好两边相等 → <code>isosceles</code>。</li><li>否则 → <code>scalene</code>。</li></ul><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleType</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 1. 排序：a &lt;= b &lt;= c</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        a, b, c = nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 三角形的必要且充分条件：最短两边之和要大于最长边</span></span><br><span class="line">        <span class="keyword">if</span> a + b &lt;= c:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;none&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 根据相等情况分类</span></span><br><span class="line">        <span class="keyword">if</span> a == c:</span><br><span class="line">            <span class="comment"># a == b == c</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;equilateral&quot;</span></span><br><span class="line">        <span class="keyword">if</span> a == b <span class="keyword">or</span> b == c:</span><br><span class="line">            <span class="comment"># 恰有两条边相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;isosceles&quot;</span></span><br><span class="line">        <span class="comment"># 三条边互不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;scalene&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为输入规模固定且极小，性能开销几乎忽略不计；若后续需要对大量三元组进行批量判定，也可以把这段逻辑放到循环或向量化环境中（如 NumPy）来做批量处理，但基本思路一致。</p><p>若需要校验输入是否全是正整数，也可在最前面加一步验证，比如 <code>if min(nums) &lt; 1: return &quot;none&quot;</code>，但题目已保证 <code>1 &lt;= nums[i] &lt;= 100</code>，故此处略去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/type-of-triangle/&quot;&gt;3024. 三角形类型&lt;/a&gt; E&lt;/h1&gt;
&lt;p&gt;给你一个下标从 &lt;strong&gt;0&lt;/strong&gt; 开始长度为 &lt;code&gt;3&lt;/code&gt; 的整数数组</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="简单" scheme="https://blog.icjlu.eu.org/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="排序" scheme="https://blog.icjlu.eu.org/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 与数据清洗</title>
    <link href="https://blog.icjlu.eu.org/post/data-cleaning.html"/>
    <id>https://blog.icjlu.eu.org/post/data-cleaning.html</id>
    <published>2025-05-19T00:52:10.000Z</published>
    <updated>2025-05-19T13:38:38.669Z</updated>
    
    <content type="html"><![CDATA[<h1>Python 与数据清洗</h1><h2 id="1-数据清洗的重要性">1. 数据清洗的重要性</h2><p>在机器学习项目中，<strong>数据清洗</strong>是至关重要的第一步。它指的是识别并修正数据集中的错误、不一致性、不准确性或缺失部分，以保证数据的质量和适用性。高质量的数据是构建可靠机器学习模型的基石。如果输入到模型中的数据存在缺陷，即使是最先进的算法也无法产生有意义的结果。这正如一句谚语所说：“垃圾进，垃圾出”。</p><p>不良的数据质量可能导致：</p><ul><li>模型训练不准确</li><li>预测结果不可靠</li><li>最终损害整个项目的价值与可用性</li></ul><p>因此，投入时间和精力进行彻底的数据清洗，是项目成功的先决条件。</p><h3 id="1-1-“脏数据”的常见来源">1.1 “脏数据”的常见来源</h3><ul><li><strong>人为错误</strong><ul><li>拼写错误</li><li>数值录入失误</li></ul></li><li><strong>测量设备故障或精度限制</strong><ul><li>传感器数据偏差</li><li>仪器读数不稳定</li></ul></li><li><strong>数据记录不完整</strong><ul><li>用户注册时未填写某些字段</li><li>采集过程丢失数据</li></ul></li><li><strong>多源数据格式不一致</strong><ul><li>日期格式（如 <code>YYYY-MM-DD</code> vs <code>DD/MM/YYYY</code>）</li><li>单位表示差异（如米 vs 英尺）</li></ul></li></ul><hr><h2 id="2-处理缺失值">2. 处理缺失值</h2><p>缺失值是指在数据集中某些观测的特定特征没有记录或无法获取的情况。理解缺失值的类型对于选择合适的处理方法至关重要。</p><h3 id="2-1-缺失值的类型">2.1 缺失值的类型</h3><ol><li><p><strong>完全随机缺失（MCAR，Missing Completely At Random）</strong></p><ul><li>数据缺失的概率与其他任何观测或特征都无关。</li><li>例如：实验室设备偶然故障导致部分测量结果丢失。</li></ul></li><li><p><strong>随机缺失（MAR，Missing At Random）</strong></p><ul><li>数据缺失的概率可能与某些已观测到的特征有关，但与缺失值本身无关。</li><li>例如：收入高的人倾向于不填写“家庭收入”字段，但缺失并不依赖于收入数值本身。</li></ul></li><li><p><strong>非随机缺失（MNAR，Missing Not At Random）</strong></p><ul><li>数据缺失的概率与缺失值本身有关。</li><li>例如：抑郁症患者可能因为症状严重而不愿意填写精神健康调查。</li></ul></li></ol><h3 id="2-2-处理缺失值的主要方法">2.2 处理缺失值的主要方法</h3><blockquote><p><strong>Tip:</strong> 选择何种方法，要综合考虑数据量、缺失比例及其分布机制。</p></blockquote><h4 id="2-2-1-删除（Deletion）">2.2.1 删除（Deletion）</h4><ol><li><p><strong>行删除</strong></p><ul><li>删除包含任何缺失值的整行。</li><li>优点：简单易行；</li><li>缺点：可能丢失大量信息，尤其在缺失比例较高时容易引入偏差。</li><li>适用场景：数据集很大且缺失值非常少时。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取示例 DataFrame</span></span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">None</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: [<span class="number">5</span>, <span class="literal">None</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="literal">None</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除任何含有缺失值的行</span></span><br><span class="line">df_drop_rows = df.dropna()</span><br><span class="line"><span class="built_in">print</span>(df_drop_rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>列删除</strong></p><ul><li>删除缺失值比例超过某个阈值的列。</li><li>优点：避免模型被缺失信息大规模干扰；</li><li>缺点：可能丢失重要特征，需要谨慎判断。</li><li>适用场景：某个特征缺失比例过高且无法合理填充时。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设阈值为 50%</span></span><br><span class="line">threshold = <span class="number">0.5</span></span><br><span class="line">df_drop_cols = df.dropna(axis=<span class="number">1</span>, thresh=<span class="built_in">int</span>((<span class="number">1</span> - threshold) * <span class="built_in">len</span>(df)))</span><br><span class="line"><span class="built_in">print</span>(df_drop_cols)</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-2-填充（Imputation）">2.2.2 填充（Imputation）</h4><ol><li><p><strong>统计填充</strong></p><ul><li><p><strong>均值填充</strong>：用该特征的平均值替换缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_mean = df.copy()</span><br><span class="line">df_mean[<span class="string">&#x27;A&#x27;</span>] = df_mean[<span class="string">&#x27;A&#x27;</span>].fillna(df_mean[<span class="string">&#x27;A&#x27;</span>].mean())</span><br><span class="line"><span class="built_in">print</span>(df_mean)</span><br></pre></td></tr></table></figure></li><li><p><strong>中位数填充</strong>：用该特征的中位数替换缺失值，对异常值更鲁棒。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_median = df.copy()</span><br><span class="line">df_median[<span class="string">&#x27;A&#x27;</span>] = df_median[<span class="string">&#x27;A&#x27;</span>].fillna(df_median[<span class="string">&#x27;A&#x27;</span>].median())</span><br><span class="line"><span class="built_in">print</span>(df_median)</span><br></pre></td></tr></table></figure></li><li><p><strong>众数填充</strong>：常用于类别型特征，用最频繁出现的值替换缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df_mode = df.copy()</span><br><span class="line">mode_value = df_mode[<span class="string">&#x27;C&#x27;</span>].mode()[<span class="number">0</span>]</span><br><span class="line">df_mode[<span class="string">&#x27;C&#x27;</span>] = df_mode[<span class="string">&#x27;C&#x27;</span>].fillna(mode_value)</span><br><span class="line"><span class="built_in">print</span>(df_mode)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>基于模型的填充</strong></p><ul><li>使用回归、KNN 等模型，根据其他特征预测缺失值。</li><li>优点：能够捕捉各变量之间的关系，更准确；</li><li>缺点：实现复杂、计算成本高。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> KNNImputer</span><br><span class="line"></span><br><span class="line">imputer = KNNImputer(n_neighbors=<span class="number">3</span>)</span><br><span class="line">df_knn = pd.DataFrame(imputer.fit_transform(df[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]]), columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df_knn)</span><br></pre></td></tr></table></figure></li><li><p><strong>创建缺失值指示器（Missing Indicator）</strong></p><ul><li>不直接填充缺失值，而是生成一个二元特征，标记原始位置是否缺失。</li><li>优点：保留了“缺失”本身的信息，有时缺失就是一个信号；</li><li>缺点：增加数据维度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df_indicator = df.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建指示器列，1 表示原始值缺失，0 表示不缺失</span></span><br><span class="line">df_indicator[<span class="string">&#x27;A_missing&#x27;</span>] = df_indicator[<span class="string">&#x27;A&#x27;</span>].isnull().astype(<span class="built_in">int</span>)</span><br><span class="line">df_indicator[<span class="string">&#x27;B_missing&#x27;</span>] = df_indicator[<span class="string">&#x27;B&#x27;</span>].isnull().astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对缺失值进行填充（这里以均值为例）</span></span><br><span class="line">df_indicator[<span class="string">&#x27;A&#x27;</span>] = df_indicator[<span class="string">&#x27;A&#x27;</span>].fillna(df_indicator[<span class="string">&#x27;A&#x27;</span>].mean())</span><br><span class="line">df_indicator[<span class="string">&#x27;B&#x27;</span>] = df_indicator[<span class="string">&#x27;B&#x27;</span>].fillna(df_indicator[<span class="string">&#x27;B&#x27;</span>].mean())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df_indicator)</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-小结">2.3 小结</h3><ul><li>没有“万能方法”，要根据数据缺失类型和业务场景选择合适策略。</li><li>如果缺失不随机，简单的统计填充会扭曲数据分布；</li><li>理解缺失背后的原因，才能做出明智的处理决定。</li></ul><p><strong>表 1: 处理缺失值的常用技术</strong></p><table><thead><tr><th><strong>技术</strong></th><th><strong>描述</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>典型应用场景</strong></th></tr></thead><tbody><tr><td>行删除</td><td>删除包含任何缺失值的行</td><td>简单易行</td><td>可能丢失宝贵信息，引入偏差</td><td>数据集很大且缺失值很少</td></tr><tr><td>列删除</td><td>删除包含大量缺失值的列</td><td>可以避免模型被缺失值干扰</td><td>可能丢失重要特征</td><td>某特征缺失值过多，难以合理填充</td></tr><tr><td>均值填充</td><td>使用特征的平均值填充缺失值</td><td>简单快速</td><td>降低方差，对异常值敏感</td><td>缺失值较少，数据分布近似正态</td></tr><tr><td>中位数填充</td><td>使用特征的中位数填充缺失值</td><td>对异常值不敏感</td><td>可能改变原始数据分布</td><td>数据存在较多异常值</td></tr><tr><td>众数填充</td><td>使用特征的众数填充缺失值</td><td>适用于类别型特征</td><td>可能引入偏差</td><td>类别型特征存在缺失值</td></tr><tr><td>基于模型的填充</td><td>使用统计模型预测缺失值</td><td>可以捕捉变量间关系，填充更准确</td><td>实现复杂，计算成本高</td><td>缺失值模式复杂，需要更精确的填充</td></tr><tr><td>缺失值指示器</td><td>创建一个二元特征标记缺失情况</td><td>保留缺失信息</td><td>增加数据维度</td><td>缺失本身可能包含有用信息</td></tr></tbody></table><h2 id="3-处理异常值">3. 处理异常值</h2><p>异常值指的是与其他观测值显著不同的数据点。它们可能源于测量误差、录入错误，也可能是真实世界中罕见事件的反映。异常值会对模型产生扰动，扭曲分布、降低性能，甚至导致错误结论。</p><h3 id="3-1-检测异常值的方法">3.1 检测异常值的方法</h3><h4 id="3-1-1-可视化方法">3.1.1 可视化方法</h4><ol><li><p><strong>箱线图（Box Plot）</strong></p><ul><li>显示数据的四分位数（Q1、Q2、Q3）和四分位距（IQR）。</li><li>将超出 <code>Q1 - 1.5·IQR</code> 或 <code>Q3 + 1.5·IQR</code> 的点视为潜在异常值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.boxplot(df[<span class="string">&#x27;A&#x27;</span>].dropna())</span><br><span class="line">plt.title(<span class="string">&quot;Boxplot of A&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p><strong>散点图（Scatter Plot）</strong></p><ul><li>适用于双变量数据，直观发现与其他点显著分离的观测。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(df[<span class="string">&#x27;A&#x27;</span>], df[<span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">plt.xlabel(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Scatter Plot of A vs B&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p><strong>直方图（Histogram）</strong></p><ul><li>显示数据分布，可观察尾部是否有孤立的条柱。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.hist(df[<span class="string">&#x27;A&#x27;</span>].dropna(), bins=<span class="number">10</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Frequency&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Histogram of A&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-1-2-统计方法">3.1.2 统计方法</h4><ol><li><p><strong>Z-分数（Z-Score）</strong></p><ul><li>计算每个数据点与均值的距离，以标准差为单位。</li><li>通常 |Z| &gt; 3 的值被认为是异常。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">mean_A = df[<span class="string">&#x27;A&#x27;</span>].mean()</span><br><span class="line">std_A = df[<span class="string">&#x27;A&#x27;</span>].std()</span><br><span class="line">df[<span class="string">&#x27;A_zscore&#x27;</span>] = (df[<span class="string">&#x27;A&#x27;</span>] - mean_A) / std_A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记异常值</span></span><br><span class="line">outliers_z = df[np.<span class="built_in">abs</span>(df[<span class="string">&#x27;A_zscore&#x27;</span>]) &gt; <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(outliers_z)</span><br></pre></td></tr></table></figure></li><li><p><strong>IQR 方法</strong></p><ul><li>基于箱线图思想，将落在 <code>Q1 - 1.5·IQR</code> 或 <code>Q3 + 1.5·IQR</code> 之外的值视为异常。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Q1 = df[<span class="string">&#x27;A&#x27;</span>].quantile(<span class="number">0.25</span>)</span><br><span class="line">Q3 = df[<span class="string">&#x27;A&#x27;</span>].quantile(<span class="number">0.75</span>)</span><br><span class="line">IQR = Q3 - Q1</span><br><span class="line"></span><br><span class="line">lower_bound = Q1 - <span class="number">1.5</span> * IQR</span><br><span class="line">upper_bound = Q3 + <span class="number">1.5</span> * IQR</span><br><span class="line"></span><br><span class="line">outliers_iqr = df[(df[<span class="string">&#x27;A&#x27;</span>] &lt; lower_bound) | (df[<span class="string">&#x27;A&#x27;</span>] &gt; upper_bound)]</span><br><span class="line"><span class="built_in">print</span>(outliers_iqr)</span><br></pre></td></tr></table></figure></li><li><p><strong>Isolation Forest</strong>（孤立森林）</p><ul><li>基于树的集成方法，通过不断随机切分特征空间来“隔离”异常值。</li><li>适用于高维数据，检测复杂模式的异常。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> IsolationForest</span><br><span class="line"></span><br><span class="line">iso = IsolationForest(contamination=<span class="number">0.1</span>, random_state=<span class="number">42</span>)</span><br><span class="line">df_nonull = df[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]].dropna()</span><br><span class="line">iso.fit(df_nonull)</span><br><span class="line"></span><br><span class="line">df_nonull[<span class="string">&#x27;anomaly_score&#x27;</span>] = iso.decision_function(df_nonull)</span><br><span class="line">df_nonull[<span class="string">&#x27;anomaly_flag&#x27;</span>] = iso.predict(df_nonull)  <span class="comment"># -1 为异常，1 为正常</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df_nonull[df_nonull[<span class="string">&#x27;anomaly_flag&#x27;</span>] == -<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-处理异常值的策略">3.2 处理异常值的策略</h3><ol><li><p><strong>删除</strong></p><ul><li>直接移除被识别的异常点。</li><li>适用于确认是数据输入错误或设备误差时，需谨慎避免丢失真实但极端的观测。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_clean = df[~((df[&#x27;A&#x27;] &lt; lower_bound) | (df[&#x27;A&#x27;] &gt; upper_bound))]</span><br></pre></td></tr></table></figure></li><li><p><strong>转换</strong></p><ul><li>使用 <strong>对数转换</strong>、<strong>截尾（Winsorizing）</strong> 等方法，减小极端值影响。</li><li>例如，对数转换：<code>A_log = np.log(df['A'])</code>，适用于正值且偏态分布的数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[&#x27;A_log&#x27;] = np.log(df[&#x27;A&#x27;].replace(0, np.nan).dropna())</span><br></pre></td></tr></table></figure></li><li><p><strong>填充</strong></p><ul><li>用更合理的边界值或均值、中位数替换异常值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[&#x27;A_clipped&#x27;] = df[&#x27;A&#x27;].clip(lower=lower_bound, upper=upper_bound)</span><br></pre></td></tr></table></figure></li><li><p><strong>保留</strong></p><ul><li>不做处理，将异常值视为潜在信号。</li><li>常见于 <strong>异常检测</strong>、<strong>欺诈识别</strong> 等场景。</li></ul></li></ol><p><strong>表 2: 检测和处理异常值的常用技术</strong></p><table><thead><tr><th><strong>技术</strong></th><th><strong>描述</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>典型应用场景</strong></th></tr></thead><tbody><tr><td>箱线图</td><td>可视化数据的分布和潜在异常值</td><td>直观易懂</td><td>对高维数据不适用</td><td>初步探索性数据分析</td></tr><tr><td>Z-分数</td><td>衡量数据点距离均值的标准差个数</td><td>易于计算</td><td>对数据分布有要求，对异常值敏感</td><td>数据分布近似正态</td></tr><tr><td>IQR方法</td><td>基于四分位数间距识别异常值</td><td>对异常值不敏感</td><td>可能遗漏极端异常值</td><td>数据存在异常值</td></tr><tr><td>孤立森林</td><td>基于树的集成方法，通过隔离异常值进行检测</td><td>适用于高维数据，性能较好</td><td>参数调整可能复杂</td><td>复杂数据集的异常值检测</td></tr><tr><td>删除</td><td>移除被识别为异常值的数据点</td><td>简单直接</td><td>可能丢失信息</td><td>明显的错误数据或噪声</td></tr><tr><td>转换</td><td>使用数学函数（如对数）调整数据分布</td><td>降低极端值的影响</td><td>可能改变数据的原始含义</td><td>数据偏态分布</td></tr><tr><td>填充</td><td>用其他值（如均值、中位数或边界值）替换异常值</td><td>保留数据量</td><td>可能引入偏差</td><td>异常值数量不多，且有合理的替换值</td></tr><tr><td>保留</td><td>不对异常值进行处理</td><td>避免丢失潜在重要信息</td><td>异常值可能影响模型性能</td><td>异常值可能代表重要事件或模式</td></tr></tbody></table><h2 id="4-数据转换技术">4. 数据转换技术</h2><p>数据转换是将原始数据转换为更适合模型处理的格式或分布。合理的转换能够提升模型性能与稳定性。</p><h3 id="4-1-缩放与归一化">4.1 缩放与归一化</h3><ol><li><p><strong>最小–最大缩放（Min–Max Scaling）</strong></p><ul><li><p>将数值线性映射到 <code>[0, 1]</code> 区间：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>x</mi><mtext>scaled</mtext></msub><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><msub><mi>x</mi><mtext>min</mtext></msub></mrow><mrow><msub><mi>x</mi><mtext>max</mtext></msub><mo>−</mo><msub><mi>x</mi><mtext>min</mtext></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">x_{\text{scaled}} = \frac{x - x_{\text{min}}}{x_{\text{max}} - x_{\text{min}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">scaled</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0963em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">min</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">min</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><p>优点：直观；</p></li><li><p>缺点：对异常值敏感。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">df_scaled = scaler.fit_transform(df[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]].dropna())</span><br><span class="line"><span class="built_in">print</span>(df_scaled[:<span class="number">5</span>])</span><br></pre></td></tr></table></figure></li><li><p><strong>标准化（Standardization，Z-Score Scaling）</strong></p><ul><li><p>转换为均值为 0、标准差为 1 的分布：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>x</mi><mtext>standardized</mtext></msub><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac></mrow><annotation encoding="application/x-tex">x_{\text{standardized}} = \frac{x - \mu}{\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">standardized</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.9463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">μ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><p>对异常值相对鲁棒一些，但对极端值仍有影响。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">std_scaler = StandardScaler()</span><br><span class="line">df_standard = std_scaler.fit_transform(df[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]].dropna())</span><br><span class="line"><span class="built_in">print</span>(df_standard[:<span class="number">5</span>])</span><br></pre></td></tr></table></figure></li><li><p><strong>鲁棒缩放（Robust Scaling）</strong></p><ul><li>基于中位数和四分位数进行缩放，对异常值更不敏感。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.preprocessing import RobustScaler</span><br><span class="line"></span><br><span class="line">robust_scaler = RobustScaler()</span><br><span class="line">df_robust = robust_scaler.fit_transform(df[[&#x27;A&#x27;, &#x27;B&#x27;]].dropna())</span><br><span class="line">print(df_robust[:5])**鲁棒缩放**是一种对异常值不太敏感的缩放方法，例如scikit-learn中的`RobustScaler`，它基于数据的百分位数进行缩放。</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-2-非线性转换">4.2 非线性转换</h3><ol><li><p><strong>对数转换（Log Transformation）</strong></p><ul><li>用于处理偏态分布，将大值压缩。</li><li>仅适用于正值数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[&#x27;A_log&#x27;] = np.log(df[&#x27;A&#x27;].replace(0, np.nan)).dropna()</span><br></pre></td></tr></table></figure></li><li><p><strong>幂转换（Power Transformation，如 Box–Cox、Yeo–Johnson）</strong></p><ul><li>更通用的方法，常用于稳定方差、使数据更接近正态分布。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PowerTransformer</span><br><span class="line"></span><br><span class="line">pt = PowerTransformer(method=<span class="string">&#x27;yeo-johnson&#x27;</span>)</span><br><span class="line">df_power = pt.fit_transform(df[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]].dropna())</span><br><span class="line"><span class="built_in">print</span>(df_power[:<span class="number">5</span>])</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-3-类别型变量编码">4.3 类别型变量编码</h3><ol><li><p><strong>独热编码（One-Hot Encoding）</strong></p><ul><li>对于机器学习模型，类别型变量通常需要转换为数值形式。<strong>独热编码</strong>是一种常用的方法，它为每个类别创建一个新的二元特征，如果某个观测属于该类别，则该特征的值为1，否则为0。</li><li>为每个类别生成一个二元特征。</li><li>适用于无序类别变量，但会增加维度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_cat = pd.DataFrame(&#123;<span class="string">&#x27;color&#x27;</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="literal">None</span>]&#125;)</span><br><span class="line">df_cat_onehot = pd.get_dummies(df_cat[<span class="string">&#x27;color&#x27;</span>], dummy_na=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(df_cat_onehot)</span><br></pre></td></tr></table></figure></li><li><p><strong>标签编码（Label Encoding）</strong></p><ul><li><strong>标签编码</strong>将每个类别分配一个唯一的整数。</li><li>将类别变量映射为整数。</li><li>适用于有序类别，可能会引入无意义的顺序关系。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line">le = LabelEncoder()</span><br><span class="line">df_cat[<span class="string">&#x27;color_encoded&#x27;</span>] = le.fit_transform(df_cat[<span class="string">&#x27;color&#x27;</span>].astype(<span class="built_in">str</span>))</span><br><span class="line"><span class="built_in">print</span>(df_cat)</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-4-选择合适的转换方法">4.4 选择合适的转换方法</h3><ul><li><strong>基于距离的算法</strong>（如 KNN、K-Means）：对特征尺度敏感，通常需要缩放<br>因为基于距离的算法依赖于特征之间的距离计算，尺度较大的特征可能会在距离计算中占据主导地位，即使它们的重要性并非更高。缩放可以确保所有特征对距离计算的贡献更加均衡。</li><li><strong>树模型</strong>（如 决策树、随机森林）：对尺度不敏感，但对异常值和分布可能敏感。<br>树模型基于单个特征内部值的顺序进行决策，因此对整体尺度不敏感</li></ul><h2 id="Python实现示例">Python实现示例</h2><p>Pandas的<code>isnull()</code>和<code>sum()</code>方法来检查缺失值，使用<code>fillna()</code>方法进行填充，使用<code>dropna()</code>方法删除缺失值。<br>可以使用Matplotlib和Seaborn库进行可视化以检测异常值，并使用NumPy进行统计计算。<br>可以使用<code>sklearn.preprocessing</code>模块中的各种类进行数据缩放、归一化和编码。</p><p>一个简单的数据清洗工作流程包括以下步骤：</p><p>首先，加载数据并使用Pandas进行初步的探索性分析，例如查看数据的基本统计信息和缺失值情况。<br>然后，根据数据的特性和业务需求，选择合适的缺失值处理方法，并使用Pandas或scikit-learn进行填充或删除。<br>接下来，可以使用可视化方法和统计方法检测异常值，并根据情况选择删除、转换或保留。<br>最后，根据所选的机器学习算法的要求，对数据进行缩放、归一化或编码等转换。</p><p>下面展示一个端到端的数据清洗示例，包含：加载数据、检查/处理缺失值、检测/处理异常值、数据转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer, KNNImputer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler, OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> IsolationForest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加载示例数据</span></span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, np.nan, <span class="number">22</span>, <span class="number">40</span>, <span class="number">120</span>, <span class="number">28</span>],</span><br><span class="line">    <span class="string">&#x27;income&#x27;</span>: [<span class="number">50000</span>, <span class="number">60000</span>, <span class="number">55000</span>, np.nan, <span class="number">65000</span>, <span class="number">70000</span>, <span class="number">58000</span>],</span><br><span class="line">    <span class="string">&#x27;gender&#x27;</span>: [<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, np.nan, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 初步探索</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;缺失值情况：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.isnull().<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 处理缺失值</span></span><br><span class="line"><span class="comment"># 3.1 对数值特征使用均值填充</span></span><br><span class="line">num_cols = [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;income&#x27;</span>]</span><br><span class="line">imp_mean = SimpleImputer(strategy=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">df[num_cols] = imp_mean.fit_transform(df[num_cols])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2 对类别特征使用众数填充</span></span><br><span class="line">imp_mode = SimpleImputer(strategy=<span class="string">&#x27;most_frequent&#x27;</span>)</span><br><span class="line">df[[<span class="string">&#x27;gender&#x27;</span>]] = imp_mode.fit_transform(df[[<span class="string">&#x27;gender&#x27;</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n填充后数据：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 检测异常值（Isolation Forest）</span></span><br><span class="line">iso = IsolationForest(contamination=<span class="number">0.15</span>, random_state=<span class="number">42</span>)</span><br><span class="line">df[[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;income&#x27;</span>]] = df[[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;income&#x27;</span>]].astype(<span class="built_in">float</span>)</span><br><span class="line">iso.fit(df[[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;income&#x27;</span>]])</span><br><span class="line">df[<span class="string">&#x27;anomaly_flag&#x27;</span>] = iso.predict(df[[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;income&#x27;</span>]])  <span class="comment"># -1 异常，1 正常</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n异常检测结果：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df[df[<span class="string">&#x27;anomaly_flag&#x27;</span>] == -<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 处理异常值（这里以删除为例）</span></span><br><span class="line">df_clean = df[df[<span class="string">&#x27;anomaly_flag&#x27;</span>] == <span class="number">1</span>].drop(columns=[<span class="string">&#x27;anomaly_flag&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n删除异常值后的数据：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df_clean)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 数据转换</span></span><br><span class="line"><span class="comment"># 6.1 连续特征标准化</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">df_clean[[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;income&#x27;</span>]] = scaler.fit_transform(df_clean[[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;income&#x27;</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.2 类别特征独热编码</span></span><br><span class="line">encoder = OneHotEncoder(sparse=<span class="literal">False</span>, handle_unknown=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">gender_encoded = encoder.fit_transform(df_clean[[<span class="string">&#x27;gender&#x27;</span>]])</span><br><span class="line">df_gender = pd.DataFrame(gender_encoded, columns=encoder.get_feature_names_out([<span class="string">&#x27;gender&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并特征</span></span><br><span class="line">df_final = pd.concat([df_clean.drop(columns=[<span class="string">&#x27;gender&#x27;</span>]).reset_index(drop=<span class="literal">True</span>),</span><br><span class="line">                      df_gender.reset_index(drop=<span class="literal">True</span>)], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n最终处理后数据：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df_final)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释解读：</strong></p><ol><li>使用 <code>SimpleImputer</code> 分别对数值特征（均值）和类别特征（众数）进行填充。</li><li><code>IsolationForest</code> 标记异常值，并将异常样本剔除。</li><li>对数值特征进行标准化、类别特征进行独热编码，得到最终可用于建模的数据集。</li></ol></blockquote><h2 id="总结">总结</h2><ul><li><strong>数据清洗</strong>是机器学习流程中的核心步骤，良好的数据清洗能显著提升模型质量与稳定性。</li><li>针对 <strong>缺失值</strong> 要区分 MCAR、MAR、MNAR，不盲目删除或填充。</li><li>对 <strong>异常值</strong> 的处理需结合业务背景，可能选择删除、转换、填充或保留。</li><li><strong>数据转换</strong>（缩放、编码）应根据所用算法特点进行选择。</li><li>在 Python 中，Pandas、NumPy、Scikit-learn 等库提供了便捷的接口，能够高效地完成各类数据清洗操作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Python 与数据清洗&lt;/h1&gt;
&lt;h2 id=&quot;1-数据清洗的重要性&quot;&gt;1. 数据清洗的重要性&lt;/h2&gt;
&lt;p&gt;在机器学习项目中，&lt;strong&gt;数据清洗&lt;/strong&gt;是至关重要的第一步。它指的是识别并修正数据集中的错误、不一致性、不准确性或缺失部分，以保证数据的</summary>
      
    
    
    
    <category term="数据分析" scheme="https://blog.icjlu.eu.org/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据操作" scheme="https://blog.icjlu.eu.org/tags/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    
    <category term="python" scheme="https://blog.icjlu.eu.org/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Pandas操作方式笔记</title>
    <link href="https://blog.icjlu.eu.org/post/pandas.html"/>
    <id>https://blog.icjlu.eu.org/post/pandas.html</id>
    <published>2025-05-19T00:52:05.000Z</published>
    <updated>2025-05-19T13:44:19.866Z</updated>
    
    <content type="html"><![CDATA[<h1>Pandas 操作方式笔记</h1><h2 id="1-Pandas-简介">1. Pandas 简介</h2><p>Pandas 是一个在 Python 编程语言中广泛使用的数据操作和分析的开源库。它建立在另一个基础库 NumPy 之上，NumPy 主要用于数值计算。Pandas 的出现极大地简化了使用 Python 进行数据清洗、转换和分析的过程，提供了高性能且易于使用的数据结构和数据分析工具。在当前数据科学和机器学习的工作流程中，Pandas 扮演着至关重要的角色。</p><p>Pandas 依赖于 NumPy，这意味着理解一些基本的 NumPy 概念对于优化 Pandas 的操作非常有益，尤其是在处理大型数据集时。例如，NumPy 的数组操作和广播规则直接影响着 Pandas 的性能。因此，在掌握 Pandas 的基础知识后，进一步探索 NumPy 将有助于用户编写更高效的 Pandas 代码。</p><p>此外，Pandas 在数据科学领域被广泛采用，这使得精通 Pandas 成为任何希望在 Python 中处理数据的人的一项非常有价值的技能。无论是进行学术研究、商业分析还是开发机器学习模型，Pandas 都是一个不可或缺的工具。因此，学习 Pandas 的长期收益是显著的，它将为用户打开数据相关职业发展的大门。</p><p>相较于标准的 Python 数据结构（如列表和字典），使用 Pandas 进行数据分析具有显著的优势。Pandas 提供了表格数据的表示方式，即 DataFrame，它类似于电子表格和数据库中的表结构。这种结构使得数据的组织和理解更加直观。此外，Pandas 具有带标签的轴（行和列），这使得数据的访问更加方便和有意义。</p><p>Pandas 提供了强大且灵活的数据操作功能，包括数据过滤、排序、合并等。它还内置了处理缺失数据的功能，并提供了数据对齐和整合的工具。更重要的是，Pandas 可以与其他 Python 库（如 NumPy、Matplotlib 和 Scikit-learn）无缝集成，形成一个强大的数据分析生态系统。最后，Pandas 在处理大型数据集时也表现出高效性，这使得它成为处理各种规模数据的理想选择。</p><p>Pandas DataFrame 中带标签的轴相比于 NumPy 数组或列表的列表仅使用数字索引，极大地提高了数据的可读性和操作性。对于初学者来说，使用有意义的列名和行索引进行复杂的数据操作会更加直观，减少出错的可能性。传统的 Python 数据结构通常依赖于位置索引，当数据集变得复杂时，这种方式可能会显得笨拙。而 Pandas 的标签索引允许用户通过名称引用数据，从而提高了代码的清晰度和可维护性。</p><p>Pandas 与其他数据科学库的无缝集成创建了一个强大的端到端数据分析工作流程。从数据加载和清洗到可视化和模型构建，Pandas 都可以作为核心组件。例如，Pandas 可以轻松地将数据传递给 Matplotlib 进行绘图，或传递给 Scikit-learn 进行机器学习模型的训练。这种集成性突显了 Pandas 在更广泛的 Python 数据科学领域中的核心地位。</p><h2 id="2-Pandas-数据结构：Series-和-DataFrame">2. Pandas 数据结构：Series 和 DataFrame</h2><p>Pandas 中最核心的两个数据结构是 Series 和 DataFrame。理解这两种数据结构是掌握 Pandas 的关键。</p><h3 id="Series-介绍"><strong>Series 介绍</strong></h3><p>Series 是一种一维的带标签的数组，它可以存储任何数据类型（整数、字符串、浮点数、Python 对象等）。可以将 Series 想象成电子表格中的一列，或者一个带标签的列表。</p><p>一个 Series 由两个主要部分组成：<strong>索引（Index）</strong> 和 <strong>值（Values）</strong>。索引是数据的标签，可以是整数、字符串或任何其他可哈希的 Python 对象。如果创建 Series 时没有明确指定索引，Pandas 会自动创建一个默认的整数索引，从 0 开始递增。值是 Series 中存储的实际数据。</p><p>与普通的 Python 列表不同，Series 拥有显式的索引。这种显式的索引使得数据的访问和对齐更加有意义。尤其是在处理时间序列数据或具有内在标签的数据时，Series 的优势更加明显。例如，在一个存储产品价格的 Series 中，可以使用产品名称作为索引，这样就可以直接通过产品名称来查找其价格，而不需要记住它在列表中的位置。</p><h3 id="DataFrame-介绍"><strong>DataFrame 介绍</strong></h3><p>DataFrame 是一种二维的带标签的数据结构，可以看作是由多个 Series 组成的表格。DataFrame 的每一列可以是不同的数据类型。它是 Pandas 中最核心的数据结构，用于表示表格数据。</p><p>DataFrame 由三个主要部分组成：<strong>索引（Index）</strong>、<strong>列（Columns）</strong> 和 <strong>值（Values）</strong>。索引是行的标签，类似于 Series 中的索引。列是数据的标签，每一列都可以看作是一个 Series。值是实际的数据，以表格的形式排列在行和列中。</p><p>可以将 DataFrame 类比为一个电子表格或一个 SQL 数据库中的表。它提供了一种非常直观的方式来组织和处理结构化数据。例如，在一个存储学生信息的 DataFrame 中，每一行可能代表一个学生，而每一列可能代表学生的姓名、年龄、成绩等信息。</p><p>DataFrame 能够容纳不同数据类型的列，这与 NumPy 数组通常要求所有元素具有相同类型形成了鲜明的对比。现实世界中的数据往往包含各种不同的类型，例如数值型的测量数据、类别型的标签以及日期时间信息。Pandas DataFrame 的这种灵活性使其非常适合表示和处理各种真实世界的数据集。</p><p>此外，Pandas 中一个非常重要的概念是按照索引和列标签对齐数据。这简化了涉及多个 Series 或 DataFrame 的操作。当对两个 Pandas 对象进行操作时（例如，将两个 DataFrame 相加），Pandas 会自动根据它们的行和列标签对齐数据。即使这些对象的初始顺序不同或存在缺失的标签，这种自动对齐也能确保操作在对应的数据点上执行，从而避免了常见的错误，并使得数据操作更加健壮。</p><h2 id="3-创建-Series-和-DataFrame">3. 创建 Series 和 DataFrame</h2><p>Pandas 提供了多种灵活的方法来创建 Series 和 DataFrame 对象。了解这些方法对于开始使用 Pandas 至关重要。</p><h3 id="创建-Series"><strong>创建 Series</strong></h3><ul><li><p><strong>从列表创建：</strong> 可以使用 Python 列表来创建一个 Series。Pandas 会自动为列表中的每个元素分配一个从 0 开始的整数索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = </span><br><span class="line">s = pd.Series(data)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>输出结果会显示每个值及其对应的默认整数索引。</p></li><li><p><strong>从 NumPy 数组创建：</strong> 也可以从 NumPy 数组创建 Series。数据会直接从 NumPy 数组转移到 Series 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.array()</span><br><span class="line">s = pd.Series(arr)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>与从列表创建类似，Pandas 会为数组中的每个元素分配一个默认的整数索引。</p></li><li><p><strong>从字典创建：</strong> 从 Python 字典创建 Series 是一种非常强大的方式。字典的键会成为 Series 的索引标签，而字典的值会成为 Series 的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;Alice&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;Charlie&#x27;</span>: <span class="number">30</span>&#125;</span><br><span class="line">s = pd.Series(data)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>在这种情况下，Series 的索引将是 ‘Alice’, ‘Bob’, ‘Charlie’，对应的值分别是 10, 20, 30。这种方式非常适合表示带有明确标签的数据。</p></li><li><p><strong>指定索引：</strong> 在从列表或 NumPy 数组创建 Series 时，可以显式地指定索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = </span><br><span class="line">index =</span><br><span class="line">s = pd.Series(data, index=index)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>通过 <code>index</code> 参数，我们可以自定义 Series 的索引标签。</p></li></ul><p>从字典创建 Series 是一种表示带有内在含义标签的数据的强大方法，例如将产品名称映射到价格。字典本身就存储着键值对，当转换为 Pandas Series 时，这些键会直接转化为有意义的索引标签，使得数据更具描述性。例如，一个字典 <code>&#123;'apple': 2.5, 'banana': 1.0, 'orange': 1.5&#125;</code> 转换为 Series 后，可以直接通过产品名称（如 ‘apple’）来访问其价格（2.5）。</p><h3 id="创建-DataFrame"><strong>创建 DataFrame</strong></h3><ul><li><p><strong>从字典列表创建：</strong> 可以使用包含字典的列表来创建 DataFrame。列表中的每个字典代表 DataFrame 中的一行，字典的键会成为列名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data =</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p>DataFrame 将会包含 ‘name’ 和 ‘age’ 两列，每一行对应列表中的一个字典。</p></li><li><p><strong>从列表的字典或 NumPy 数组的字典创建：</strong> 可以使用字典来创建 DataFrame，其中字典的每个键代表一个列名，而对应的值是一个列表或 NumPy 数组，包含该列的数据。需要确保所有列表或数组的长度相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:, <span class="string">&#x27;age&#x27;</span>: &#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p>这里，‘name’ 列对应一个包含姓名的列表，‘age’ 列对应一个包含年龄的列表。</p></li><li><p><strong>从 Series 的字典创建：</strong> 还可以使用字典来创建 DataFrame，其中字典的每个键代表一个列名，而对应的值是一个 Series。DataFrame 的索引将与 Series 的索引对齐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series(, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">s2 = pd.Series(, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">data = &#123;<span class="string">&#x27;col1&#x27;</span>: s1, <span class="string">&#x27;col2&#x27;</span>: s2&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>s1</code> 和 <code>s2</code> 的索引略有不同。Pandas 会根据索引进行对齐，对于 <code>s2</code> 中没有 ‘c’ 索引，以及 <code>s1</code> 中没有 ‘d’ 索引的地方，会填充缺失值（NaN）。</p></li><li><p><strong>从 NumPy 数组创建：</strong> 可以从一个二维 NumPy 数组创建 DataFrame。可以指定列名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([, , ])</span><br><span class="line">columns =</span><br><span class="line">df = pd.DataFrame(arr, columns=columns)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p>这里，NumPy 数组的数据被放入 DataFrame 中，并使用指定的列名 ‘A’, ‘B’, ‘C’。</p></li><li><p><strong>从另一个 Series 或 DataFrame 创建：</strong> 可以通过复制或修改现有的 Series 或 DataFrame 来创建新的 DataFrame。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series()</span><br><span class="line">df1 = pd.DataFrame(s)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"></span><br><span class="line">df2 = df.DataFrame(&#123;<span class="string">&#x27;col1&#x27;</span>: , <span class="string">&#x27;col2&#x27;</span>: &#125;)</span><br><span class="line">df3 = pd.DataFrame(df2) <span class="comment"># 复制 df2</span></span><br><span class="line"><span class="built_in">print</span>(df3)</span><br></pre></td></tr></table></figure><p>这些方法提供了创建 DataFrame 的多种途径，可以根据不同的数据来源和结构选择最合适的方法。</p></li></ul><p>从 Series 的字典创建 DataFrame 提供了处理具有潜在不同索引的数据的灵活性，因为 Pandas 会自动对齐这些索引，并在必要时填充缺失值。当使用不同来源的数据创建 DataFrame 时，各个 Series 可能具有不同的索引标签。Pandas 在将这些 Series 合并为 DataFrame 的列时，会根据它们的索引进行对齐。如果某个 Series 在 DataFrame 的索引中缺少某个标签，Pandas 会在该位置填充 <code>NaN</code>（Not a Number），表示缺失值。这种自动对齐的功能对于整合来自不同来源、可能存在不一致标签的数据非常有用。</p><p>创建 DataFrame 的各种方法能够适应不同的数据输入格式，这使得 Pandas 在处理来自各种来源的数据时非常通用。无论数据是以记录列表的形式存在，还是以命名列的集合，或者是一个原始的数值数组，Pandas 都提供了便捷的方式将其导入到 DataFrame 中，而 DataFrame 是进行后续分析的核心数据结构。</p><h3 id="创建-Series-和-DataFrame-的方法小结"><strong>创建 Series 和 DataFrame 的方法小结</strong></h3><table><thead><tr><th><strong>方法</strong></th><th><strong>数据来源</strong></th><th><strong>描述</strong></th><th><strong>示例代码片段</strong></th></tr></thead><tbody><tr><td><code>pd.Series(data)</code></td><td>列表，NumPy 数组</td><td>从列表或 NumPy 数组创建 Series，自动生成整数索引。</td><td><code>pd.Series()</code></td></tr><tr><td><code>pd.Series(data, index=index)</code></td><td>列表，NumPy 数组</td><td>从列表或 NumPy 数组创建 Series，并指定索引。</td><td><code>pd.Series(, index=['a', 'b', 'c'])</code></td></tr><tr><td><code>pd.Series(data)</code></td><td>字典</td><td>从字典创建 Series，字典的键成为索引，值成为 Series 的值。</td><td><code>pd.Series(&#123;'a': 1, 'b': 2&#125;)</code></td></tr><tr><td><code>pd.DataFrame(data)</code></td><td>字典列表</td><td>从字典列表创建 DataFrame，每个字典代表一行，键成为列名。</td><td><code>pd.DataFrame([&#123;'a': 1, 'b': 2&#125;, &#123;'a': 3, 'b': 4&#125;])</code></td></tr><tr><td><code>pd.DataFrame(data)</code></td><td>字典（列表或 NumPy 数组的值）</td><td>从字典创建 DataFrame，每个键代表一列名，值是列表或 NumPy 数组。</td><td><code>pd.DataFrame(&#123;'col1': , 'col2': &#125;)</code></td></tr><tr><td><code>pd.DataFrame(data)</code></td><td>字典（Series 的值）</td><td>从字典创建 DataFrame，每个键代表一列名，值是 Series，DataFrame 的索引与 Series 的索引对齐。</td><td><code>pd.DataFrame(&#123;'col1': pd.Series(), 'col2': pd.Series()&#125;)</code></td></tr><tr><td><code>pd.DataFrame(data)</code></td><td>二维 NumPy 数组</td><td>从二维 NumPy 数组创建 DataFrame，可以指定列名。</td><td><code>pd.DataFrame(np.array([, ]), columns=)</code></td></tr><tr><td><code>pd.DataFrame(series)</code></td><td>Series</td><td>从一个 Series 创建 DataFrame，Series 成为 DataFrame 的一列。</td><td><code>pd.DataFrame(pd.Series())</code></td></tr><tr><td><code>pd.DataFrame(dataframe)</code></td><td>DataFrame</td><td>复制现有的 DataFrame。</td><td><code>pd.DataFrame(existing_df)</code></td></tr></tbody></table><h2 id="4-索引和选择数据">4. 索引和选择数据</h2><p>一旦创建了 Series 或 DataFrame，接下来的重要步骤就是如何访问和选择其中的数据。Pandas 提供了多种灵活的方式来实现这一点。</p><h3 id="Series-的索引和选择"><strong>Series 的索引和选择</strong></h3><p>对于 Series，可以使用索引标签或位置进行数据访问。</p><ul><li><p><strong>使用标签索引：</strong> 如果 Series 有明确的标签索引，可以直接使用这些标签来访问数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series(, index=)</span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;A&#x27;</span>])  <span class="comment"># 输出 10</span></span><br><span class="line"><span class="built_in">print</span>(s[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]]) <span class="comment"># 输出包含索引 &#x27;A&#x27; 和 &#x27;C&#x27; 的 Series</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用位置索引：</strong> 即使 Series 有标签索引，仍然可以使用整数位置索引（从 0 开始）来访问数据，类似于 Python 列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(s)   <span class="comment"># 输出 10</span></span><br><span class="line"><span class="built_in">print</span>(s[]) <span class="comment"># 输出包含位置 0 和 2 的 Series</span></span><br></pre></td></tr></table></figure></li><li><p><strong>切片：</strong> 可以使用标签或位置进行切片操作来选择 Series 的一部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(s) <span class="comment"># 使用标签切片，注意包含结束标签 &#x27;B&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">2</span>])   <span class="comment"># 使用位置切片，不包含结束位置 2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>布尔索引：</strong> 可以使用布尔条件来选择满足条件的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series()</span><br><span class="line"><span class="built_in">print</span>(s[s &gt; <span class="number">20</span>]) <span class="comment"># 输出值大于 20 的元素</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="DataFrame-的索引和选择"><strong>DataFrame 的索引和选择</strong></h3><p>DataFrame 的数据选择更加复杂，因为它是二维结构。主要有以下几种方法：</p><ul><li><p><strong>选择列：</strong> 可以像访问字典的键一样，使用列名来选择 DataFrame 的单个列，返回一个 Series。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:, <span class="string">&#x27;age&#x27;</span>: &#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;name&#x27;</span>]) <span class="comment"># 输出 &#x27;name&#x27; 列的 Series</span></span><br></pre></td></tr></table></figure><p>也可以使用属性访问的方式选择列（当列名是有效的 Python 标识符时）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.name) <span class="comment"># 与 df[&#x27;name&#x27;] 等效</span></span><br></pre></td></tr></table></figure><p>要选择多个列，可以使用包含列名的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df[[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]]) <span class="comment"># 输出包含 &#x27;name&#x27; 和 &#x27;age&#x27; 列的 DataFrame</span></span><br></pre></td></tr></table></figure></li><li><p><strong>选择行：</strong> 选择行主要使用 <code>.loc</code> 和 <code>.iloc</code> 索引器。</p><ul><li><p><strong>.loc：</strong> 基于标签进行索引。可以使用行索引标签选择单行或多行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;row1&#x27;</span>, <span class="string">&#x27;row2&#x27;</span>, <span class="string">&#x27;row3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;row1&#x27;</span>])       <span class="comment"># 输出标签为 &#x27;row1&#x27; 的行，以 Series 形式</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="string">&#x27;row1&#x27;</span>, <span class="string">&#x27;row3&#x27;</span>]]) <span class="comment"># 输出标签为 &#x27;row1&#x27; 和 &#x27;row3&#x27; 的行，以 DataFrame 形式</span></span><br></pre></td></tr></table></figure><p>也可以使用标签进行切片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;row1&#x27;</span>:<span class="string">&#x27;row2&#x27;</span>]) <span class="comment"># 选择标签从 &#x27;row1&#x27; 到 &#x27;row2&#x27; 的行（包含 &#x27;row2&#x27;）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>.iloc：</strong> 基于整数位置进行索引。可以使用整数位置选择单行或多行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.iloc)        <span class="comment"># 输出第一行（位置索引为 0），以 Series 形式</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[])     <span class="comment"># 输出第一行和第三行，以 DataFrame 形式</span></span><br></pre></td></tr></table></figure><p>也可以使用整数位置进行切片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">0</span>:<span class="number">2</span>])      <span class="comment"># 选择位置索引从 0 到 1 的行（不包含 2）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>选择特定单元格：</strong> 可以结合行和列的选择来访问 DataFrame 中的特定单元格。</p><ul><li><p>使用 <code>.loc</code>：先指定行标签，再指定列标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;row1&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]) <span class="comment"># 输出标签为 &#x27;row1&#x27; 的行的 &#x27;name&#x27; 列的值</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="string">&#x27;row1&#x27;</span>, <span class="string">&#x27;row2&#x27;</span>], [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]]) <span class="comment"># 选择指定行和列的子集</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>.iloc</code>：先指定行位置，再指定列位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.iloc)      <span class="comment"># 输出第一行第一列的值</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[, ]) <span class="comment"># 选择指定位置的行和列的子集</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>布尔索引：</strong> 可以使用列的条件来选择满足条件的行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df[df[<span class="string">&#x27;age&#x27;</span>] &gt; <span class="number">25</span>]) <span class="comment"># 输出 &#x27;age&#x27; 列中值大于 25 的所有行</span></span><br></pre></td></tr></table></figure><p>可以组合多个条件，使用 <code>&amp;</code> (and) 和 <code>|</code> (or) 运算符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df[(df[<span class="string">&#x27;age&#x27;</span>] &gt; <span class="number">25</span>) &amp; (df[<span class="string">&#x27;name&#x27;</span>]!= <span class="string">&#x27;Bob&#x27;</span>)])</span><br></pre></td></tr></table></figure></li></ul><p>理解不同的索引和选择方法是有效使用 Pandas 进行数据分析的关键。<code>.loc</code> 基于标签，更易于理解数据的含义，而 <code>.iloc</code> 基于位置，更类似于传统的数组索引。在实际应用中，根据具体的需求选择合适的方法。</p><h2 id="5-数据操作">5. 数据操作</h2><p>Pandas 提供了丰富的功能来操作 Series 和 DataFrame 中的数据，包括过滤、排序、添加或删除列、以及应用函数等。</p><h3 id="过滤数据"><strong>过滤数据</strong></h3><p>在前面的索引和选择部分已经介绍过布尔索引，这是过滤 DataFrame 中数据的常用方法。通过创建一个布尔 Series，根据条件判断每一行是否保留。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:, <span class="string">&#x27;age&#x27;</span>: , <span class="string">&#x27;city&#x27;</span>:&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择年龄大于 25 的行</span></span><br><span class="line">older_than_25 = df[df[<span class="string">&#x27;age&#x27;</span>] &gt; <span class="number">25</span>]</span><br><span class="line"><span class="built_in">print</span>(older_than_25)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择城市为 &#x27;New York&#x27; 或 &#x27;Paris&#x27; 的行</span></span><br><span class="line">in_ny_or_paris = df[df[<span class="string">&#x27;city&#x27;</span>].isin([<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Paris&#x27;</span>])]</span><br><span class="line"><span class="built_in">print</span>(in_ny_or_paris)</span><br></pre></td></tr></table></figure><h3 id="排序数据"><strong>排序数据</strong></h3><p>可以使用 <code>.sort_values()</code> 方法根据一个或多个列的值对 DataFrame 进行排序。对于 Series，可以使用 <code>.sort_values()</code> 方法按值排序，或使用 <code>.sort_index()</code> 方法按索引排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按 &#x27;age&#x27; 列升序排序</span></span><br><span class="line">sorted_by_age = df.sort_values(by=<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_by_age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按 &#x27;age&#x27; 列降序排序</span></span><br><span class="line">sorted_by_age_desc = df.sort_values(by=<span class="string">&#x27;age&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_by_age_desc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按多个列排序，先按 &#x27;age&#x27; 升序，再按 &#x27;name&#x27; 升序</span></span><br><span class="line">sorted_by_age_name = df.sort_values(by=[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(sorted_by_age_name)</span><br><span class="line"></span><br><span class="line">s = pd.Series(, index=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment"># 按值排序</span></span><br><span class="line">sorted_series_values = s.sort_values()</span><br><span class="line"><span class="built_in">print</span>(sorted_series_values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按索引排序</span></span><br><span class="line">sorted_series_index = s.sort_index()</span><br><span class="line"><span class="built_in">print</span>(sorted_series_index)</span><br></pre></td></tr></table></figure><h3 id="添加或删除列"><strong>添加或删除列</strong></h3><ul><li><p><strong>添加新列：</strong> 可以像操作字典一样，直接为 DataFrame 添加新的列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;salary&#x27;</span>] = </span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于现有列计算新列</span></span><br><span class="line">df[<span class="string">&#x27;age_plus_5&#x27;</span>] = df[<span class="string">&#x27;age&#x27;</span>] + <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></li><li><p><strong>删除列：</strong> 可以使用 <code>.drop()</code> 方法删除列。需要指定 <code>axis=1</code> 来表示删除的是列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df_dropped_salary = df.drop(<span class="string">&#x27;salary&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df_dropped_salary)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除多个列</span></span><br><span class="line">columns_to_drop = [<span class="string">&#x27;age_plus_5&#x27;</span>, <span class="string">&#x27;city&#x27;</span>]</span><br><span class="line">df_dropped_multiple = df.drop(columns_to_drop, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df_dropped_multiple)</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用函数"><strong>应用函数</strong></h3><p>Pandas 提供了将函数应用于 Series 或 DataFrame 的强大功能，包括 <code>.apply()</code>, <code>.map()</code> 和 <code>.applymap()</code> 方法。</p><ul><li><p><strong>.apply()：</strong> 可以应用于 Series 的每个值或 DataFrame 的每一行或每一列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">s = pd.Series()</span><br><span class="line">squared_series = s.apply(square)</span><br><span class="line"><span class="built_in">print</span>(squared_series)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用于 DataFrame 的列</span></span><br><span class="line">df_sum_age = df[[<span class="string">&#x27;age&#x27;</span>]].apply(<span class="built_in">sum</span>)</span><br><span class="line"><span class="built_in">print</span>(df_sum_age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用于 DataFrame 的行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">describe_row</span>(<span class="params">row</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;row[<span class="string">&#x27;name&#x27;</span>]&#125;</span> is <span class="subst">&#123;row[<span class="string">&#x27;age&#x27;</span>]&#125;</span> years old and lives in <span class="subst">&#123;row[<span class="string">&#x27;city&#x27;</span>]&#125;</span>.&quot;</span></span><br><span class="line"></span><br><span class="line">row_descriptions = df.apply(describe_row, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(row_descriptions)</span><br></pre></td></tr></table></figure></li><li><p><strong>.map()：</strong> 主要用于 Series，将函数或字典映射应用于 Series 的每个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">city_map = &#123;<span class="string">&#x27;New York&#x27;</span>: <span class="string">&#x27;NY&#x27;</span>, <span class="string">&#x27;London&#x27;</span>: <span class="string">&#x27;LDN&#x27;</span>, <span class="string">&#x27;Paris&#x27;</span>: <span class="string">&#x27;PR&#x27;</span>, <span class="string">&#x27;Tokyo&#x27;</span>: <span class="string">&#x27;TK&#x27;</span>&#125;</span><br><span class="line">df[<span class="string">&#x27;city_code&#x27;</span>] = df[<span class="string">&#x27;city&#x27;</span>].<span class="built_in">map</span>(city_map)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></li><li><p><strong>.applymap()：</strong> 只能应用于 DataFrame，将函数应用于 DataFrame 的每个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df_numeric = df[[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;salary&#x27;</span>]]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_100</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">100</span></span><br><span class="line"></span><br><span class="line">df_added = df_numeric.applymap(add_100)</span><br><span class="line"><span class="built_in">print</span>(df_added)</span><br></pre></td></tr></table></figure></li></ul><p>这些数据操作功能使得 Pandas 成为处理和转换数据的强大工具。通过灵活地组合这些操作，可以完成复杂的数据清洗和准备任务。</p><h2 id="6-基本数据分析">6. 基本数据分析</h2><p>Pandas 不仅用于数据操作，还提供了进行基本数据分析的功能，例如统计计算、聚合和分组等。</p><h3 id="统计计算"><strong>统计计算</strong></h3><p>Pandas Series 和 DataFrame 提供了许多内置的统计方法，用于快速计算数据的描述性统计信息。</p><ul><li><p><strong>常用统计方法：</strong></p><ul><li><code>.count()</code>：计算非缺失值的数量。</li><li><code>.sum()</code>：计算总和。</li><li><code>.mean()</code>：计算均值。</li><li><code>.median()</code>：计算中位数。</li><li><code>.min()</code>：计算最小值。</li><li><code>.max()</code>：计算最大值。</li><li><code>.std()</code>：计算标准差。</li><li><code>.describe()</code>：生成包含计数、均值、标准差、最小值、四分位数和最大值的描述性统计信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, np.nan])</span><br><span class="line"><span class="built_in">print</span>(s.count())   <span class="comment"># 输出 5</span></span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">sum</span>())     <span class="comment"># 输出 15.0</span></span><br><span class="line"><span class="built_in">print</span>(s.mean())    <span class="comment"># 输出 3.0</span></span><br><span class="line"><span class="built_in">print</span>(s.median())  <span class="comment"># 输出 3.0</span></span><br><span class="line"><span class="built_in">print</span>(s.describe()) <span class="comment"># 输出 Series 的描述性统计信息</span></span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;col1&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, np.nan], <span class="string">&#x27;col2&#x27;</span>: &#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df.mean())   <span class="comment"># 输出每列的均值</span></span><br><span class="line"><span class="built_in">print</span>(df.describe()) <span class="comment"># 输出 DataFrame 的描述性统计信息</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="聚合"><strong>聚合</strong></h3><p>聚合操作是指将多个值汇总为一个值的过程。Pandas 提供了 <code>.agg()</code> 方法来执行各种聚合操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.agg([<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;max&#x27;</span>])) <span class="comment"># 对 DataFrame 的每一列应用多个聚合函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.agg(&#123;<span class="string">&#x27;col1&#x27;</span>: [<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;min&#x27;</span>], <span class="string">&#x27;col2&#x27;</span>: [<span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;max&#x27;</span>]&#125;)) <span class="comment"># 对不同的列应用不同的聚合函数</span></span><br></pre></td></tr></table></figure><h3 id="分组"><strong>分组</strong></h3><p>分组是指根据一个或多个列的值将数据分成不同的组，然后对每个组应用聚合或其他操作。Pandas 使用 <code>.groupby()</code> 方法来实现分组操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;team&#x27;</span>:,</span><br><span class="line">        <span class="string">&#x27;player&#x27;</span>: [<span class="string">&#x27;P1&#x27;</span>, <span class="string">&#x27;P2&#x27;</span>, <span class="string">&#x27;P3&#x27;</span>, <span class="string">&#x27;P4&#x27;</span>, <span class="string">&#x27;P5&#x27;</span>, <span class="string">&#x27;P6&#x27;</span>, <span class="string">&#x27;P7&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;points&#x27;</span>: &#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按 &#x27;team&#x27; 列分组，并计算每个组的平均 points</span></span><br><span class="line">grouped_by_team = df.groupby(<span class="string">&#x27;team&#x27;</span>)[<span class="string">&#x27;points&#x27;</span>].mean()</span><br><span class="line"><span class="built_in">print</span>(grouped_by_team)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按 &#x27;team&#x27; 列分组，并计算每个组的 points 的总和和最大值</span></span><br><span class="line">grouped_agg = df.groupby(<span class="string">&#x27;team&#x27;</span>)[<span class="string">&#x27;points&#x27;</span>].agg([<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;max&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(grouped_agg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按多个列分组</span></span><br><span class="line">grouped_multiple = df.groupby([<span class="string">&#x27;team&#x27;</span>, <span class="string">&#x27;player&#x27;</span>])[<span class="string">&#x27;points&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(grouped_multiple)</span><br></pre></td></tr></table></figure><p>分组操作是数据分析中非常重要的技术，可以帮助我们理解数据中不同类别之间的差异和关系。</p><h2 id="7-处理缺失数据">7. 处理缺失数据</h2><p>在实际数据分析中，经常会遇到缺失数据。Pandas 使用 <code>NaN</code>（Not a Number）来表示浮点数和非浮点数组中的缺失值。Python 本身也有一个 <code>None</code> 值，Pandas 在某些情况下也会将其视为缺失值。</p><h3 id="检测缺失数据"><strong>检测缺失数据</strong></h3><p>可以使用 <code>.isnull()</code> 和 <code>.notnull()</code> 方法来检测 DataFrame 或 Series 中的缺失值。这两个方法会返回一个布尔型的 DataFrame 或 Series，指示每个值是否为缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;col1&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, np.nan, <span class="number">4</span>], <span class="string">&#x27;col2&#x27;</span>: [np.nan, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.isnull())</span><br><span class="line"><span class="built_in">print</span>(df.notnull())</span><br></pre></td></tr></table></figure><p>可以使用 <code>.sum()</code> 方法结合 <code>.isnull()</code> 或 <code>.notnull()</code> 来统计每列或每行的缺失值数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.isnull().<span class="built_in">sum</span>()) <span class="comment"># 统计每列的缺失值数量</span></span><br><span class="line"><span class="built_in">print</span>(df.isnull().<span class="built_in">sum</span>(axis=<span class="number">1</span>)) <span class="comment"># 统计每行的缺失值数量</span></span><br></pre></td></tr></table></figure><h3 id="处理缺失数据的方法"><strong>处理缺失数据的方法</strong></h3><p>Pandas 提供了几种处理缺失数据的方法：</p><ul><li><p><strong>删除缺失值：</strong> 可以使用 <code>.dropna()</code> 方法删除包含缺失值的行或列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除包含任何缺失值的行</span></span><br><span class="line">df_dropped_rows = df.dropna()</span><br><span class="line"><span class="built_in">print</span>(df_dropped_rows)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除包含任何缺失值的列</span></span><br><span class="line">df_dropped_cols = df.dropna(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df_dropped_cols)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有值都缺失的行</span></span><br><span class="line">df_dropped_all_na_rows = df.dropna(how=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df_dropped_all_na_rows)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除至少有两个非缺失值的行</span></span><br><span class="line">df_dropped_thresh_rows = df.dropna(thresh=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(df_dropped_thresh_rows)</span><br></pre></td></tr></table></figure></li><li><p><strong>填充缺失值：</strong> 可以使用 <code>.fillna()</code> 方法用指定的值或方法填充缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 0 填充所有缺失值</span></span><br><span class="line">df_filled_zero = df.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df_filled_zero)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用列的均值填充缺失值</span></span><br><span class="line">df_filled_mean = df.fillna(df.mean())</span><br><span class="line"><span class="built_in">print</span>(df_filled_mean)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用前一个有效值填充（向前填充）</span></span><br><span class="line">df_filled_ffill = df.fillna(method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df_filled_ffill)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用后一个有效值填充（向后填充）</span></span><br><span class="line">df_filled_bfill = df.fillna(method=<span class="string">&#x27;bfill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df_filled_bfill)</span><br></pre></td></tr></table></figure></li></ul><p>选择哪种方法处理缺失数据取决于具体的数据和分析需求。删除缺失值可能会导致数据丢失，而填充缺失值则需要选择合适的填充策略，避免引入偏差。</p><h2 id="8-合并和连接-DataFrame">8. 合并和连接 DataFrame</h2><p>Pandas 提供了将多个 DataFrame 合并或连接在一起的功能，类似于 SQL 中的 JOIN 操作。主要使用 <code>pd.merge()</code> 和 <code>pd.concat()</code> 函数。</p><h3 id="pd-merge"><strong>pd.merge()</strong></h3><p><code>pd.merge()</code> 函数用于基于一个或多个共同的列将两个 DataFrame 连接起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>:, <span class="string">&#x27;value&#x27;</span>: &#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>:, <span class="string">&#x27;value2&#x27;</span>: &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内连接：只保留两个 DataFrame 中 &#x27;key&#x27; 列都存在的行</span></span><br><span class="line">merged_inner = pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(merged_inner)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左连接：保留左边的 DataFrame 的所有行，右边的 DataFrame 中匹配的行。如果右边没有匹配，则填充 NaN。</span></span><br><span class="line">merged_left = pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(merged_left)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 右连接：保留右边的 DataFrame 的所有行，左边的 DataFrame 中匹配的行。如果左边没有匹配，则填充 NaN。</span></span><br><span class="line">merged_right = pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(merged_right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外连接：保留两个 DataFrame 的所有行。如果某个键在一个 DataFrame 中不存在，则填充 NaN。</span></span><br><span class="line">merged_outer = pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(merged_outer)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于多个列进行连接</span></span><br><span class="line">df3 = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>:, <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;W&#x27;</span>], <span class="string">&#x27;value&#x27;</span>: &#125;)</span><br><span class="line">df4 = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>:, <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;U&#x27;</span>], <span class="string">&#x27;value2&#x27;</span>: &#125;)</span><br><span class="line">merged_multi_key = pd.merge(df3, df4, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(merged_multi_key)</span><br></pre></td></tr></table></figure><h3 id="pd-concat"><strong>pd.concat()</strong></h3><p><code>pd.concat()</code> 函数用于沿着指定的轴将多个 Series 或 DataFrame 拼接在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series()</span><br><span class="line">s2 = pd.Series()</span><br><span class="line">concatenated_series = pd.concat([s1, s2])</span><br><span class="line"><span class="built_in">print</span>(concatenated_series)</span><br><span class="line"></span><br><span class="line">df5 = pd.DataFrame(&#123;<span class="string">&#x27;col1&#x27;</span>: , <span class="string">&#x27;col2&#x27;</span>: &#125;)</span><br><span class="line">df6 = pd.DataFrame(&#123;<span class="string">&#x27;col1&#x27;</span>: , <span class="string">&#x27;col2&#x27;</span>: &#125;)</span><br><span class="line">concatenated_df_rows = pd.concat([df5, df6]) <span class="comment"># 默认按行拼接 (axis=0)</span></span><br><span class="line"><span class="built_in">print</span>(concatenated_df_rows)</span><br><span class="line"></span><br><span class="line">concatenated_df_cols = pd.concat([df5, df6], axis=<span class="number">1</span>) <span class="comment"># 按列拼接</span></span><br><span class="line"><span class="built_in">print</span>(concatenated_df_cols)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 keys 参数为拼接后的 DataFrame 添加一个额外的层级索引</span></span><br><span class="line">concatenated_keys = pd.concat([df5, df6], keys=[<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(concatenated_keys)</span><br></pre></td></tr></table></figure><p>合并和连接操作是整合来自不同数据源的数据的关键步骤，使得我们可以进行更全面的分析。</p><h2 id="9-输入与输出">9. 输入与输出</h2><p>Pandas 提供了方便的方法来读取和写入各种格式的文件，例如 CSV、Excel、SQL 数据库等。</p><h3 id="读取文件"><strong>读取文件</strong></h3><ul><li><p><strong>CSV 文件：</strong> 使用 <code>pd.read_csv()</code> 函数读取 CSV 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># df = pd.read_csv(&#x27;your_file.csv&#x27;)</span></span><br><span class="line"><span class="comment"># 可以指定分隔符、编码等参数</span></span><br><span class="line"><span class="comment"># df = pd.read_csv(&#x27;your_file.csv&#x27;, sep=&#x27;,&#x27;, encoding=&#x27;utf-8&#x27;)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Excel 文件：</strong> 使用 <code>pd.read_excel()</code> 函数读取 Excel 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># df = pd.read_excel(&#x27;your_file.xlsx&#x27;)</span></span><br><span class="line"><span class="comment"># 可以指定 sheet 名称或索引</span></span><br><span class="line"><span class="comment"># df = pd.read_excel(&#x27;your_file.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>其他格式：</strong> Pandas 还支持读取 JSON (<code>pd.read_json()</code>)、HTML (<code>pd.read_html()</code>)、SQL 数据库 (<code>pd.read_sql()</code>) 等多种格式的文件。</p></li></ul><h3 id="写入文件"><strong>写入文件</strong></h3><ul><li><p><strong>CSV 文件：</strong> 使用 <code>.to_csv()</code> 方法将 DataFrame 写入 CSV 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># df.to_csv(&#x27;output.csv&#x27;)</span></span><br><span class="line"><span class="comment"># 可以设置是否包含索引、分隔符等参数</span></span><br><span class="line"><span class="comment"># df.to_csv(&#x27;output.csv&#x27;, index=False, sep=&#x27;;&#x27;)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Excel 文件：</strong> 使用 <code>.to_excel()</code> 方法将 DataFrame 写入 Excel 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># df.to_excel(&#x27;output.xlsx&#x27;)</span></span><br><span class="line"><span class="comment"># 可以设置 sheet 名称、是否包含索引等参数</span></span><br><span class="line"><span class="comment"># df.to_excel(&#x27;output.xlsx&#x27;, sheet_name=&#x27;Sheet2&#x27;, index=False)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>其他格式：</strong> 类似地，Pandas 也提供了将 DataFrame 写入 JSON (<code>.to_json()</code>)、HTML (<code>.to_html()</code>)、SQL 数据库 (<code>.to_sql()</code>) 等格式的方法。</p></li></ul><p>输入输出功能使得 Pandas 能够方便地与外部数据进行交互，是数据分析流程中不可或缺的一环。</p><h2 id="10-总结">10. 总结</h2><p>Pandas 是 Python 中用于数据操作和分析的核心库。本指南介绍了 Pandas 的基本概念，包括其核心数据结构 Series 和 DataFrame，以及如何创建、索引、选择、操作、分析、处理缺失数据、合并连接数据以及进行文件输入输出。掌握这些基本操作是使用 Pandas 进行更高级数据分析的基础。</p><p>对于 Python 初学者来说，Pandas 提供了一种强大且直观的方式来处理和理解数据。通过不断地练习和应用，可以更深入地掌握 Pandas 的各种功能，并将其应用于实际的数据分析项目中。建议在掌握本指南中的内容后，进一步探索 Pandas 的高级特性，例如时间序列分析、更复杂的数据聚合和转换等，以提升数据分析的能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Pandas 操作方式笔记&lt;/h1&gt;
&lt;h2 id=&quot;1-Pandas-简介&quot;&gt;1. Pandas 简介&lt;/h2&gt;
&lt;p&gt;Pandas 是一个在 Python 编程语言中广泛使用的数据操作和分析的开源库。它建立在另一个基础库 NumPy 之上，NumPy 主要用于数值计算</summary>
      
    
    
    
    <category term="数据分析" scheme="https://blog.icjlu.eu.org/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据操作" scheme="https://blog.icjlu.eu.org/tags/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    
    <category term="python" scheme="https://blog.icjlu.eu.org/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>NumPy操作方式笔记</title>
    <link href="https://blog.icjlu.eu.org/post/numpy.html"/>
    <id>https://blog.icjlu.eu.org/post/numpy.html</id>
    <published>2025-05-19T00:52:00.000Z</published>
    <updated>2025-05-19T13:44:46.550Z</updated>
    
    <content type="html"><![CDATA[<h1>NumPy操作方式笔记</h1><p>NumPy，全称为 Numerical Python，是Python语言中用于科学计算的基础库之一。它为Python提供了强大的多维数组和矩阵的支持，以及一套用于在这些数组上执行高性能计算的数学函数集合。NumPy的核心在于其引入的 <code>ndarray</code> 对象，这是一个可以存储同类型数据（如数字）的多维数组结构，为处理大型数据集提供了内存效率极高的存储和操作方式。与Python内置的列表不同，NumPy数组中的所有元素都必须是相同的数据类型，这一特性使得NumPy能够实现更快的运算速度。实际上，NumPy的许多操作都是通过优化过的C语言代码实现的，这使得其在处理数值计算任务时，性能远超使用标准Python列表和循环的实现方式。此外，NumPy还具备广播（broadcasting）功能，允许不同形状的数组之间进行运算，而无需显式地进行循环操作。这种设计极大地简化了代码，并提升了处理大规模数据的效率。</p><h2 id="NumPy的重要性与优势">NumPy的重要性与优势</h2><p>NumPy之所以在科学计算领域如此重要，原因在于其多方面的优势：</p><ul><li><strong>提升运算速度</strong>：它能够显著提升数学运算的速度，尤其是在处理包含大量数字的数组时，其效率远高于标准的Python实现。</li><li><strong>简化数据处理</strong>：NumPy简化了对大型数值列表（即数组）的处理，避免了编写复杂的循环结构。</li><li><strong>丰富的函数库</strong>：NumPy还提供了丰富的、可以直接使用的函数，用于执行统计分析、线性代数运算以及生成随机数等任务。</li><li><strong>科学计算库的基础</strong>：更重要的是，NumPy是许多其他重要的科学计算库（如Pandas、SciPy、TensorFlow和scikit-learn）的基础。这些库在数据分析、高级科学计算和机器学习等领域发挥着关键作用，它们都依赖于NumPy数组作为其核心数据结构。</li><li><strong>高效的内存管理</strong>：最后，与Python列表相比，NumPy在存储和管理大量数据时，占用的内存更少，效率更高，这对于处理庞大的数据集至关重要。</li></ul><h2 id="NumPy的应用领域">NumPy的应用领域</h2><p>由于其强大的功能和高效的性能，NumPy被广泛应用于各种领域：</p><ul><li><strong>数据分析</strong>：NumPy可以用于创建、筛选和操作以数组形式存在的数据，并执行诸如计算均值和标准差等各种操作。</li><li><strong>机器学习与人工智能</strong>：流行的工具如TensorFlow和PyTorch都使用NumPy来管理输入数据、处理模型参数和输出值。</li><li><strong>数组操作</strong>：NumPy还提供了强大的数组操作功能，包括创建、调整大小、切片、索引、堆叠、分割和组合数组。</li><li><strong>金融与经济</strong>：NumPy被用于财务分析，包括投资组合优化、风险评估、时间序列分析和统计建模。</li><li><strong>图像与信号处理</strong>：NumPy能够帮助处理和分析图像和信号数据。</li><li><strong>数据可视化</strong>：虽然NumPy本身不直接创建可视化图表，但它与Matplotlib和Seaborn等库紧密集成，可以从数值数据生成各种图表。</li></ul><p>NumPy的这些应用表明，无论是在基础的数据处理还是在复杂的算法实现中，它都扮演着至关重要的角色。</p><h2 id="NumPy的安装与导入">NumPy的安装与导入</h2><p>要开始使用NumPy，首先需要在Python环境中安装它。这可以通过Python的包管理器pip轻松完成，只需在命令行中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure><p>这个命令会自动从Python的包索引中下载并安装NumPy及其依赖项。</p><p>安装完成后，在Python代码中需要导入NumPy库才能使用其功能。按照惯例，我们通常会使用别名 <code>np</code> 来导入NumPy，即使用语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>这样做的好处是，在后续的代码中，我们可以通过 <code>np</code> 这个更简洁的名称来引用NumPy的函数和对象，这提高了代码的可读性，并且是Python科学计算社区广泛采用的一种标准做法。这种一致性使得不同开发者编写的代码更容易被理解和协作。</p><h2 id="NumPy的核心：ndarray对象">NumPy的核心：ndarray对象</h2><p>NumPy的核心是其多维数组对象，即 <code>ndarray</code>。理解 <code>ndarray</code> 的核心属性对于有效地使用NumPy至关重要。</p><ul><li><strong>同质性</strong>：NumPy数组是同质的，这意味着数组中的所有元素都必须是相同的数据类型。这与Python列表可以包含不同类型的元素形成了鲜明的对比。同质性是NumPy实现高效数值计算的关键，因为它允许NumPy在内存中以连续的方式存储数据，并针对特定的数据类型进行优化。</li><li><strong>多维性</strong>：NumPy数组可以是多维的。一维数组类似于Python中的列表，可以看作是向量。二维数组则更像是一个表格或矩阵，具有行和列。NumPy还支持更高维度的数组，例如三维数组可以想象成由多个二维数组堆叠而成，更高维度的数组在处理更复杂的数据结构时非常有用，通常被称为张量。</li></ul><h3 id="ndarray的核心属性">ndarray的核心属性</h3><ul><li><strong>形状 (shape)</strong>：描述数组结构的一个重要属性，它是一个由整数组成的元组，每个整数表示数组在相应维度上的大小。例如，对于一个二维数组，其形状表示为 <code>(行数, 列数)</code>。理解数组的形状对于进行需要兼容数组尺寸的操作（如算术运算和矩阵乘法）至关重要。</li><li><strong>数据类型 (dtype)</strong>：指定了数组中元素的数据类型。NumPy支持多种数据类型，包括整数（如 <code>int64</code>）、浮点数（如 <code>float64</code>）、复数（如 <code>complex32</code>）等。在创建数组时，如果没有显式指定数据类型，NumPy通常会根据输入数据的类型进行推断，默认的数据类型通常是 <code>float64</code>。用户也可以在创建数组时通过 <code>dtype</code> 参数显式地指定所需的数据类型，这有助于更好地管理内存使用和控制计算精度。</li><li>其他基本属性：<ul><li><code>ndim</code>: 数组的维度（轴）的数量。</li><li><code>size</code>: 数组中元素的总数。</li><li><code>itemsize</code>: 数组中每个元素占用的字节数。</li><li><code>data</code>: 一个缓冲区，包含了数组中实际的元素数据，但通常不直接使用。</li></ul></li><li><strong>可变性</strong>：与Python列表类似，NumPy数组是可变的，这意味着在数组创建后，可以修改其元素的值。</li></ul><p>这些属性共同构成了对NumPy数组的基本理解，为后续学习更复杂的操作打下了基础。</p><h2 id="创建NumPy数组">创建NumPy数组</h2><p>创建NumPy数组有多种方法。</p><ul><li><strong>从Python序列创建</strong>：一种常见的方法是使用 <code>np.array()</code> 函数，该函数可以从常规的Python列表或元组创建NumPy数组。<code>np.array()</code> 会尝试根据序列中元素的类型推断出结果数组的数据类型。例如，如果传入的列表包含整数，则创建的数组将是整数类型的；如果包含浮点数，则数组将是浮点数类型的。对于多维数组，可以传入由列表组成的列表（或元组组成的元组），NumPy会将其转换为相应的多维数组结构。需要注意的是，在调用 <code>np.array()</code> 时，应该将要转换的序列作为一个单独的参数传入，而不是将序列中的元素作为多个独立的参数传入，否则会导致类型错误。</li><li><strong>使用专门函数创建具有特定初始值的数组</strong>：<ul><li><code>np.zeros(shape, dtype=float, order='C')</code>: 创建一个指定形状和数据类型的数组，并用零填充所有元素。例如，<code>np.zeros((3, 4))</code> 将创建一个 3 行 4 列的二维数组，所有元素都初始化为 <code>0.0</code>。</li><li><code>np.ones(shape, dtype=None, order='C')</code>: 创建一个用 1 填充的数组。例如，<code>np.ones((2, 3, 4), dtype=np.int16)</code> 将创建一个 2x3x4 的三维数组，所有元素都初始化为整数 <code>1</code>。</li><li><code>np.empty(shape, dtype=float, order='C')</code>: 创建一个指定形状和数据类型的数组，但不会对其进行初始化，数组中的初始值是内存中已有的任意数据。使用 <code>np.empty()</code> 的优势在于速度可能比 <code>np.zeros()</code> 或 <code>np.ones()</code> 快，因为它不需要进行初始化，但这也意味着在使用之前必须确保数组的所有元素都被赋予了有意义的值。</li></ul></li><li><strong>创建数值序列</strong>：<ul><li><code>np.arange([start,] stop[, step,], dtype=None, *, like=None)</code>: 类似于Python内置的 <code>range()</code> 函数，但返回的是一个NumPy数组。<code>np.arange()</code> 可以接受浮点数参数，例如 <code>np.arange(0, 2, 0.3)</code> 将生成 <code>[0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]</code>。然而，当使用浮点数步长时，由于浮点数精度的限制，可能无法准确预测生成的元素数量。</li><li><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)</code>: 通常建议使用此函数来创建指定数量的在给定间隔内均匀分布的数值。<code>np.linspace()</code> 接收起始值、结束值以及期望生成的元素数量作为参数，例如 <code>np.linspace(0, 2, 9)</code> 将生成 9 个从 0 到 2（包含 2）均匀分布的数值。</li></ul></li></ul><p>这些函数为创建各种类型的NumPy数组提供了灵活的方式。</p><h2 id="NumPy数组的基本操作">NumPy数组的基本操作</h2><p>NumPy在数组上执行基本操作时，通常是**逐元素 (element-wise)**进行的。这意味着当对两个形状相同的数组进行算术运算时（例如加法、减法、乘法、除法、乘方和取模），运算会对应地应用到数组中的每个元素，并产生一个新的包含结果的数组。 例如，如果 <code>a = np.array([20, 30, 40, 50])</code> 且 <code>b = np.arange(4)</code>，那么 <code>a - b</code> 将得到 <code>array([20, 29, 38, 47])</code>，而 <code>b**2</code> 将得到 <code>array([0, 1, 4, 9])</code>。 同样，标量与数组之间的运算也会被广播到数组的每个元素上，例如 <code>10 * np.sin(a)</code> 会先计算数组 <code>a</code> 中每个元素的正弦值，然后将结果乘以 10。这种逐元素的操作方式使得对整个数据集进行数学运算变得简洁高效，无需编写显式的循环。</p><h3 id="通用函数-ufuncs">通用函数 (ufuncs)</h3><p>NumPy为这些基本的算术运算提供了相应的<strong>通用函数 (universal functions，简称 ufuncs)</strong>。例如：</p><ul><li><code>np.add()</code> 对应于加法 (<code>+</code>)</li><li><code>np.subtract()</code> 对应于减法 (<code>-</code>)</li><li><code>np.multiply()</code> 对应于乘法 (<code>*</code>)</li><li><code>np.divide()</code> 对应于除法 (<code>/</code>)</li><li><code>np.power()</code> 对应于乘方 (<code>**</code>)</li><li><code>np.mod()</code> 对应于取模 (<code>%</code>)</li></ul><p>这些 ufuncs 不仅执行逐元素操作，而且通常经过高度优化，能够提供比标准Python操作更高的性能。它们是NumPy向量化操作的基础，直接在NumPy数组的内存缓冲区上操作，避免了为每个元素调用Python函数的开销。</p><h3 id="其他数学函数">其他数学函数</h3><p>除了基本的算术运算，NumPy还提供了大量的通用数学函数，这些函数同样以逐元素的方式应用于数组。这包括：</p><ul><li><strong>三角函数</strong>: 如 <code>np.sin()</code> (正弦)、<code>np.cos()</code> (余弦)、<code>np.tan()</code> (正切)、<code>np.arcsin()</code> (反正弦)等。</li><li><strong>指数和对数函数</strong>: 如 <code>np.exp()</code> (指数)、<code>np.log()</code> (自然对数)、<code>np.log10()</code> (以 10 为底的对数)等。</li><li><strong>舍入函数</strong>: 如 <code>np.round()</code> (四舍五入)、<code>np.floor()</code> (向下取整)、<code>np.ceil()</code> (向上取整)等。</li><li><strong>绝对值函数</strong>: <code>np.abs()</code>。</li></ul><p>NumPy的文档中包含了完整的数学函数列表，这些函数极大地扩展了在NumPy数组上进行复杂数值计算的能力。</p><h2 id="NumPy数组的索引和切片">NumPy数组的索引和切片</h2><h3 id="单个元素访问">单个元素访问</h3><p>访问NumPy数组中的单个元素与Python列表类似，都是通过索引来实现的，索引从 0 开始。</p><ul><li><strong>一维数组</strong>: 可以直接使用方括号内的索引来访问元素，例如 <code>a[0]</code> 将访问数组 <code>a</code> 的第一个元素。</li><li><strong>多维数组</strong>: 可以使用逗号分隔的索引元组来访问特定位置的元素，每个索引对应数组的一个维度。例如，对于一个二维数组 <code>a</code>，<code>a[1, 3]</code> 将访问第二行（索引为 1）第四列（索引为 3）的元素。</li><li><strong>负索引</strong>: NumPy还支持负索引，可以从数组的末尾开始计数，例如 <code>a[-1]</code> 将访问数组的最后一个元素。</li></ul><p>这种灵活的索引方式使得可以方便地访问数组中的特定元素。</p><h3 id="切片-Slicing">切片 (Slicing)</h3><p>除了访问单个元素，NumPy还提供了强大的切片（slicing）功能，用于提取数组的子数组。切片使用 <code>[start:stop:step]</code> 这样的表示法，其中 <code>start</code> 是切片的起始索引（包含），<code>stop</code> 是结束索引（不包含），<code>step</code> 是步长。</p><ul><li>如果没有指定 <code>start</code>，则默认为 0。</li><li>如果没有指定 <code>stop</code>，则默认为数组的长度。</li><li>如果没有指定 <code>step</code>，则默认为 1。</li></ul><p>一个重要的特性是，NumPy的切片操作创建的是原始数组的<strong>视图 (view)</strong>，而不是数据的副本。这意味着对切片进行修改会直接影响到原始数组。这种行为可以提高效率，避免不必要的数据复制，但需要注意，如果需要一个独立的副本，应该使用 <code>.copy()</code> 方法。</p><p>对于多维数组，切片可以应用于每个维度，通过逗号分隔每个维度的切片规格。例如：</p><ul><li><code>a[0:2, :]</code> 选择数组 <code>a</code> 的前两行（所有列）。</li><li><code>a[:, 1:4]</code> 选择所有行的第 2 到第 4 列（不包括第 4 列）。</li><li><code>a[1, :]</code> 选择第二行的所有元素。</li><li><code>a[:, 2]</code> 选择第三列的所有元素。</li></ul><h3 id="高级索引">高级索引</h3><p>NumPy还支持更高级的索引方式。</p><ul><li><strong>布尔数组索引 (Boolean array indexing / Masking)</strong>：通过创建一个与原始数组形状相同的布尔数组作为索引，可以根据布尔数组中 <code>True</code> 值对应的位置来选择原始数组中的元素。例如，<code>a[a &gt; 5]</code> 将选择数组 <code>a</code> 中所有大于 5 的元素。布尔索引是根据条件过滤数据的强大工具。</li><li><strong>整数数组索引 (Integer array indexing / Fancy indexing)</strong>：通过传递一个包含整数索引的NumPy数组作为索引，可以选择原始数组中特定位置的元素。这允许以非连续的方式选择元素，甚至可以重复选择相同的元素。例如，<code>a[[0, 2, 4]]</code> 将选择数组 <code>a</code> 中索引为 0、2 和 4 的元素。对于二维数组，可以传递两个整数数组，分别表示要选择的元素的行索引和列索引。例如，<code>a[[0, 1, 2], [0, 1, 0]]</code> 将选择位于 <code>(0, 0)</code>、<code>(1, 1)</code> 和 <code>(2, 0)</code> 的元素。与基本的切片不同，整数数组索引<strong>总是返回原始数据的一个副本</strong>。</li></ul><h2 id="NumPy数组的形状操作">NumPy数组的形状操作</h2><p>NumPy提供了多种方法来改变数组的形状而不改变其数据内容。</p><ul><li><strong>ndarray.reshape(new_shape, order=‘C’)</strong>: 将数组重塑为指定的形状，<code>new_shape</code> 参数是一个表示新形状的元组。重要的是，重塑后的数组必须包含与原始数组相同数量的元素。如果可能，<code>reshape()</code> 会返回原始数组的一个视图，否则会返回一个副本。例如，如果 <code>a</code> 是一个包含 12 个元素的一维数组，<code>a.reshape((3, 4))</code> 将其转换为一个 3 行 4 列的二维数组。</li><li><strong>数组的扁平化 (Flattening)</strong>：是将多维数组转换为一维数组的过程。<ul><li><code>ndarray.flatten(order='C')</code>: 返回一个原始数组的副本，并将其展平为一维数组。</li><li><code>ndarray.ravel(order='C')</code>: 也执行相同的操作，但它会尝试返回原始数组的视图，只有在必要时才会返回副本，因此在可能的情况下，<code>ravel()</code> 通常比 <code>flatten()</code> 更节省内存。 例如，对于一个多维数组 <code>a</code>，<code>a.flatten()</code> 和 <code>a.ravel()</code> 都会得到一个包含相同元素的一维数组。</li></ul></li><li><strong>转置 (Transposing)</strong>：是另一种常见的数组形状操作。对于二维数组（矩阵），转置会交换其行和列。在NumPy中，可以使用 <code>ndarray.T</code> 属性来获取数组的转置视图，或者使用 <code>np.transpose(a, axes=None)</code> 函数，该函数返回一个转置后的数组。通过 <code>axes</code> 参数，可以指定更复杂的轴交换顺序。例如，对于一个数组 <code>a</code>，<code>a.T</code> 或 <code>np.transpose(a)</code> 将返回其转置。转置在线性代数中非常重要，例如在进行矩阵乘法时，可能需要先对矩阵进行转置。</li></ul><p>这些形状操作为处理和组织NumPy数组中的数据提供了灵活性。</p><h2 id="NumPy的线性代数运算">NumPy的线性代数运算</h2><p>NumPy还为线性代数运算提供了强大的支持。</p><ul><li><strong>点积 (Dot product)</strong>：可以使用 <code>np.dot(a, b)</code> 函数来计算两个数组的点积。<ul><li>如果 <code>a</code> 和 <code>b</code> 都是一维数组，<code>np.dot()</code> 返回向量的内积。</li><li>如果它们都是二维数组，则执行矩阵乘法（在较新的NumPy版本中，推荐使用 <code>np.matmul()</code> 或 <code>a @ b</code> 进行矩阵乘法）。</li><li>对于更高维度的数组，点积的计算方式更为复杂，涉及到最后一个轴的求和乘积。 点积是线性代数中的基本运算，广泛应用于物理学和机器学习等领域。</li></ul></li><li><strong>矩阵乘法 (Matrix multiplication)</strong>：可以使用 <code>np.matmul(a, b)</code> 或 <code>a @ b</code> 来执行。对于二维数组，这是标准的矩阵乘法。需要注意的是，进行矩阵乘法时，第一个矩阵的列数必须等于第二个矩阵的行数。</li><li><strong>逐元素乘法 (Element-wise multiplication)</strong>：可以使用 <code>np.multiply(a, b)</code> 或简单的 <code>a * b</code> 来实现，它将两个形状相同的数组中对应位置的元素相乘。这与矩阵乘法是不同的。</li></ul><h3 id="linalg-模块"><code>linalg</code> 模块</h3><p>NumPy的 <code>linalg</code> 模块还包含许多其他有用的线性代数函数，例如：</p><ul><li><code>np.linalg.solve(a, b)</code>: 求解线性方程组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">Ax = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>。</li><li><code>np.linalg.inv(a)</code>: 计算矩阵的逆。</li><li><code>np.linalg.eig(a)</code>: 计算方阵的特征值和特征向量。</li><li><code>np.linalg.det(a)</code>: 计算矩阵的行列式。</li><li><code>np.linalg.norm(x)</code>: 计算矩阵或向量的范数。</li></ul><p>这些函数构成了进行高级数值计算和解决复杂数学问题的基础。</p><h2 id="NumPy的随机数生成">NumPy的随机数生成</h2><p>NumPy还提供了强大的随机数生成功能，这些功能在模拟、机器学习等领域非常有用。</p><ul><li><code>np.random.rand(d0, d1,..., dn)</code>: 创建一个指定形状的数组，并用从均匀分布（区间 <code>[0, 1)</code>）中抽取的随机浮点数填充。例如，<code>np.random.rand(5)</code> 将创建一个包含 5 个随机数的 1D 数组，而 <code>np.random.rand(2, 3)</code> 将创建一个 2x3 的随机数数组。</li><li><code>np.random.randn(d0, d1,..., dn)</code>: 类似，但它从标准正态分布（均值为 0，方差为 1）中抽取随机数。</li><li><code>np.random.randint(low, high=None, size=None, dtype=int)</code>: 返回在指定范围内（从 <code>low</code>（包含）到 <code>high</code>（不包含））的随机整数，形状由 <code>size</code> 参数指定。如果只提供一个参数，则返回 0 到该参数之间的随机整数。例如，<code>np.random.randint(10, size=5)</code> 将创建一个包含 5 个 0 到 9 之间随机整数的数组。</li></ul><p>对于更新的NumPy代码（版本 1.17 及更高版本），推荐使用 <code>np.random.default_rng()</code> 创建一个随机数生成器对象，该对象提供了更结构化的方式来生成来自各种分布的随机数，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.default_rng()</span><br><span class="line">random_array = rng.random((<span class="number">3</span>, <span class="number">2</span>)) <span class="comment"># 使用 random 而非 rand</span></span><br><span class="line">random_integers = rng.integers(<span class="number">0</span>, <span class="number">10</span>, size=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这种方式提供了更好的控制和更广泛的分布选择。</p><h2 id="NumPy数组的复制与视图">NumPy数组的复制与视图</h2><p>在使用NumPy数组时，理解**复制 (copy)<strong>数组和创建</strong>视图 (view)**之间的区别非常重要。</p><ul><li><strong>赋值操作 (b = a)</strong>: 并不会创建数组 <code>a</code> 的一个新副本，而是使 <code>b</code> 成为对 <code>a</code> 所指向的同一数组对象的另一个引用。这意味着，如果修改 <code>b</code> 中的元素，<code>a</code> 中的相应元素也会被修改。</li><li><strong>切片操作 (b = a[0:5])</strong>: 通常会创建原始数组的一个视图。视图本质上是原始数组数据的一个窗口，它本身不存储任何数据，而是引用原始数组的一部分。因此，通过视图对数组进行的修改可能会影响到原始数组。</li><li><strong>.copy() 方法 (b = a.copy())</strong>: 如果需要创建数组及其数据的完全独立副本，应该使用 <code>.copy()</code> 方法。在这种情况下，对 <code>b</code> 的修改不会影响到 <code>a</code>。</li></ul><p>理解这种行为对于避免在程序中出现意外的副作用至关重要。</p><h2 id="NumPy数组的保存与加载">NumPy数组的保存与加载</h2><p>NumPy还提供了方便的方法来将数组数据保存到磁盘以及从磁盘加载数组数据。</p><ul><li><code>np.save('filename.npy', array)</code>: 将单个NumPy数组以二进制格式保存到扩展名为 <code>.npy</code> 的文件中。</li><li><code>np.load('filename.npy')</code>: 将保存的数组从 <code>.npy</code> 文件加载回来。</li><li><code>np.savetxt('filename.txt', array)</code>: 将数组保存到文本文件中。</li><li><code>np.loadtxt('filename.txt')</code>: 从文本文件中加载数组。</li><li><code>np.genfromtxt('data.txt', delimiter=',')</code>: 可以从文本文件加载数据，并且更灵活，可以处理缺失值和不同的数据类型。</li></ul><p>这些功能使得NumPy能够有效地处理大型数据集，这些数据集可能无法一次性加载到内存中。</p><h2 id="总结">总结</h2><p>NumPy作为Python科学计算的核心库，为处理多维数组和执行数值计算提供了强大且高效的工具。通过理解NumPy数组的特性、掌握创建数组的多种方式、熟悉基本的逐元素操作和数学函数、灵活运用索引和切片技术、以及了解数组形状的变换和基本的线性代数运算，Python初学者可以为后续更深入的数据分析、机器学习和科学研究打下坚实的基础。理解复制和视图的区别以及学会保存和加载数组数据，将有助于更有效地管理和处理实际应用中的数据。NumPy的高效性和广泛的功能使其成为Python科学计算生态系统中不可或缺的一部分。</p><h2 id="NumPy数组创建函数比较表">NumPy数组创建函数比较表</h2><table><thead><tr><th>函数名称</th><th>描述</th><th>主要参数</th><th>用途示例</th></tr></thead><tbody><tr><td><code>np.array</code></td><td>从列表、元组或其他序列创建数组</td><td><code>object</code> (要转换的序列), <code>dtype</code> (数据类型), <code>copy</code> (是否复制)</td><td><code>np.array([1,2,3])</code>, <code>np.array([[1,2], [3,4]])</code></td></tr><tr><td><code>np.zeros</code></td><td>创建一个用零填充的数组</td><td><code>shape</code> (数组形状), <code>dtype</code> (数据类型)</td><td><code>np.zeros((2, 3))</code>, <code>np.zeros(5, dtype=int)</code></td></tr><tr><td><code>np.ones</code></td><td>创建一个用一填充的数组</td><td><code>shape</code> (数组形状), <code>dtype</code> (数据类型)</td><td><code>np.ones((3, 2))</code>, <code>np.ones((2, 2), dtype=float)</code></td></tr><tr><td><code>np.empty</code></td><td>创建一个未初始化的数组</td><td><code>shape</code> (数组形状), <code>dtype</code> (数据类型)</td><td><code>np.empty((2, 2))</code>, <code>np.empty(3, dtype=complex)</code></td></tr><tr><td><code>np.arange</code></td><td>在给定范围内创建均匀间隔的值的数组</td><td><code>start</code> (起始值), <code>stop</code> (结束值), <code>step</code> (步长), <code>dtype</code> (数据类型)</td><td><code>np.arange(0, 10, 2)</code>, <code>np.arange(5)</code></td></tr><tr><td><code>np.linspace</code></td><td>在指定间隔内创建均匀间隔的数字序列</td><td><code>start</code> (起始值), <code>stop</code> (结束值), <code>num</code> (元素数量), <code>dtype</code> (数据类型)</td><td><code>np.linspace(0, 1, 5)</code>, <code>np.linspace(0, np.pi, 10)</code></td></tr><tr><td><code>np.full</code></td><td>创建一个用指定值填充的数组</td><td><code>shape</code> (数组形状), <code>fill_value</code> (填充值), <code>dtype</code> (数据类型)</td><td><code>np.full((2, 2), 7)</code>, <code>np.full(5, 'test', dtype=object)</code></td></tr><tr><td><code>np.eye</code></td><td>创建一个单位矩阵</td><td><code>N</code> (行数), <code>M</code> (列数，可选), <code>k</code> (对角线索引), <code>dtype</code> (数据类型)</td><td><code>np.eye(3)</code>, <code>np.eye(4, M=5, k=1)</code></td></tr><tr><td><code>np.diag</code></td><td>提取对角线或创建对角数组</td><td><code>v</code> (对角线元素), <code>k</code> (对角线索引)</td><td><code>np.diag([1,2,3])</code>, <code>np.diag(np.array([[1,2], [3,4]]))</code></td></tr></tbody></table><h2 id="基本算术通用函数比较表">基本算术通用函数比较表</h2><table><thead><tr><th>运算符</th><th>等效通用函数</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code></td><td><code>np.add</code></td><td>逐元素相加</td></tr><tr><td><code>-</code></td><td><code>np.subtract</code></td><td>逐元素相减</td></tr><tr><td><code>*</code></td><td><code>np.multiply</code></td><td>逐元素相乘</td></tr><tr><td><code>/</code></td><td><code>np.divide</code></td><td>逐元素相除</td></tr><tr><td><code>**</code></td><td><code>np.power</code></td><td>逐元素乘方</td></tr><tr><td><code>%</code></td><td><code>np.mod</code></td><td>逐元素取模（余数）</td></tr></tbody></table><h2 id="数组扁平化方法比较表">数组扁平化方法比较表</h2><table><thead><tr><th>方法</th><th>返回值</th><th>内存效率</th><th>对原始数组的影响</th><th>适用场景</th></tr></thead><tbody><tr><td><code>flatten()</code></td><td>原始数组的副本</td><td>较低</td><td>不影响</td><td>需要一个原始数组的独立副本时</td></tr><tr><td><code>ravel()</code></td><td>原始数组的视图</td><td>较高</td><td>可能影响</td><td>当不需要副本且希望尽可能节省内存时</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;NumPy操作方式笔记&lt;/h1&gt;
&lt;p&gt;NumPy，全称为 Numerical Python，是Python语言中用于科学计算的基础库之一。它为Python提供了强大的多维数组和矩阵的支持，以及一套用于在这些数组上执行高性能计算的数学函数集合。NumPy的核心在于其引入的</summary>
      
    
    
    
    <category term="数据分析" scheme="https://blog.icjlu.eu.org/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据操作" scheme="https://blog.icjlu.eu.org/tags/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    
    <category term="python" scheme="https://blog.icjlu.eu.org/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-18</title>
    <link href="https://blog.icjlu.eu.org/post/count-equal-and-divisible-pairs.html"/>
    <id>https://blog.icjlu.eu.org/post/count-equal-and-divisible-pairs.html</id>
    <published>2025-05-18T08:25:55.000Z</published>
    <updated>2025-05-18T14:35:43.123Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/">1931. 用三种不同颜色为网格涂色</a> H</h1><p>给你两个整数 <code>m</code> 和 <code>n</code> 。构造一个 <code>m x n</code> 的网格，其中每个单元格最开始是白色。请你用 <strong>红、绿、蓝</strong> 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p><p>涂色方案需要满足：<strong>不存在相邻两个单元格颜色相同的情况</strong> 。返回网格涂色的方法数。因为答案可能非常大， 返回 <strong>对</strong> <code>10⁹ + 7</code> <strong>取余</strong> 的结果。</p><p><strong>示例 1：</strong></p><p><img src="https://s2.loli.net/2025/05/18/mDHT6orlxOePg3M.png" alt="colorthegrid"></p><blockquote><p>输入：m = 1, n = 1<br>输出：3<br>解释：如上图所示，存在三种可能的涂色方案。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="https://s2.loli.net/2025/05/18/J82rswYUVe1yCz3.png" alt="copy-of-colorthegrid"></p><blockquote><p>输入：m = 1, n = 2<br>输出：6<br>解释：如上图所示，存在六种可能的涂色方案。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：m = 5, n = 5<br>输出：580986</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m &lt;= 5</code></li><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h2 id="问题分析">问题分析</h2><p>给定 m×n 的网格（1 ≤ m ≤ 5，1 ≤ n ≤ 1000），每个格子都要用三种颜色之一（红/绿/蓝）上色，且要求 <strong>无两相邻格子颜色相同</strong>。邻接关系包括水平方向（左右）和垂直方向（上下）。</p><p>由于 m 较小（至多 5），可以把“同一列的 m 个格子”看作一个整体状态。对于一列内部，必须保证上下相邻的颜色不同；对于两列之间，必须保证同一行的两个格子颜色不同。</p><h2 id="算法思路">算法思路</h2><h3 id="1-合法列状态数">1. 合法列状态数</h3><ul><li>对于一列，逐格向下涂色：<ul><li>第一行格子有 3 种颜色可选；</li><li>之后每增加一格，颜色只能是剩下的 2 种（不能与上一格相同）；</li></ul></li><li>因此一列共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><msup><mn>2</mn><mrow><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">3 \times 2^{,m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 种合法的“列颜色方案”。</li><li>当 m=5 时，合法状态数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>3</mn><mo>×</mo><msup><mn>2</mn><mn>4</mn></msup><mo>=</mo><mn>48</mn></mrow><annotation encoding="application/x-tex">=3×2^4=48</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">48</span></span></span></span>；当 m=1 时，合法状态数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>；依此类推。</li></ul><p>我们可以把每个“列方案”用长度为 m 的元组（或一个整数掩码）来表示。例如：若 m=3，用 (0,1,2) 表示第一行红、第二行绿、第三行蓝。然后预先枚举出全部合法的列状态列表 <code>states</code>。</p><h3 id="2-列与列之间的兼容性">2. 列与列之间的兼容性</h3><ul><li><p>若列 A 和列 B 在同一行颜色相同，则它们不能相邻摆放。</p></li><li><p>因此，对所有合法状态对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_i, s_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，检查：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∀</mi><mtext> </mtext><mn>0</mn><mo>≤</mo><mi>r</mi><mo>&lt;</mo><mi>m</mi><mo>:</mo><mtext>  </mtext><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\forall\,0\le r&lt;m:\; s_i[r] \ne s_j[r].</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord">∀</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mord">.</span></span></span></span></span></p></li><li><p>枚举时可得到一个邻接列表（邻接矩阵／邻接表）<code>compat[i]</code> 记录状态 i 能与哪些状态 j 配对。</p></li></ul><h3 id="3-动态规划">3. 动态规划</h3><p>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>dp</mtext><mo stretchy="false">[</mo><mi>c</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\text{dp}[c][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">dp</span></span><span class="mopen">[</span><span class="mord mathnormal">c</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 列选择状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 时的方案总数。</p><ul><li><p>初始化 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 时：对于任意合法状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>dp</mtext><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\text{dp}[1][i]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">dp</span></span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p></li><li><p>状态转移（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>c</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2\le c\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>dp</mtext><mo stretchy="false">[</mo><mi>c</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mstyle scriptlevel="1"><mtable rowspacing="0.1em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="1" displaystyle="false"><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="1" displaystyle="false"><mrow><mi>i</mi><mspace width="0.1952em"/><mtext>与</mtext><mspace width="0.1952em"/><mi>j</mi><mspace width="0.1952em"/><mtext>兼容</mtext></mrow></mstyle></mtd></mtr></mtable></mstyle><mrow><mi>S</mi><mo>−</mo><mn>1</mn></mrow></munderover><mtext>dp</mtext><mo stretchy="false">[</mo><mi>c</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\text{dp}[c][j]   = \sum_{\substack{i=0\\ i\,\text{与}\,j\,\text{兼容}}}^{S-1} \text{dp}[c-1][i].</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">dp</span></span><span class="mopen">[</span><span class="mord mathnormal">c</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.8464em;vertical-align:-2.0181em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.5579em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1086em;"><span style="top:-3.1491em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span><span style="top:-2.2858em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord text mtight"><span class="mord cjk_fallback mtight">与</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord text mtight"><span class="mord cjk_fallback mtight">兼容</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6086em;"><span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0181em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">dp</span></span><span class="mopen">[</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">.</span></span></span></span></span></p></li><li><p>最终答案 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>S</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mtext>dp</mtext><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mo stretchy="false">(</mo><msup><mn>10</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">=\sum_{i=0}^{S-1}\text{dp}[n][i] \bmod (10^9+7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2809em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9812em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">dp</span></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span>。</p></li><li><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mn>3</mn><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">S=3\times2^{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 是合法列状态数。</p></li></ul><h2 id="时间复杂度">时间复杂度</h2><ul><li><strong>预处理列状态</strong>：枚举每个长度为 m 的染色情况，共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">3^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 种，筛选出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mn>3</mn><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">S=3\times2^{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个合法；时间约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>3</mn><mi>m</mi></msup><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3^m \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，当 m≤5 时常数小（最多 3^5=243）；</li><li><strong>预处理兼容矩阵</strong>：两两枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">S\times S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 对，检查 m 行是否同色；时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>S</mi><mn>2</mn></msup><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(S^2 \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，当 m=5 时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mn>48</mn></mrow><annotation encoding="application/x-tex">S=48</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">48</span></span></span></span>，约 48^2×5≈11520 步；</li><li><strong>动态规划</strong>：共 n 列，每列从上一列的兼容状态中累加，时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msub><mi>S</mi><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">s</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times S_{\mathrm{avg\_neighbors}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">avg_neighbors</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。最坏的邻居数约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msup><mi>S</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nS^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。<ul><li>当 m=5, S=48, S^2≈2304, n≤1000 时，总步数 ≈2.3×10^6，完全可行。</li></ul></li><li><strong>空间</strong>：若保存整个 dp 表，为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nS)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>；也可以用滚动数组仅保留上一列，总空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>。</li></ul><p>若 n 更大（例如 n 接近 10⁹ ），可以把兼容关系矩阵看作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">S×S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 的转移矩阵，用矩阵快速幂将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 次转移压缩为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>S</mi><mn>3</mn></msup><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(S^3\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。在本题 n≤1000 的规模下，直接DP已足够高效。</p><p>经测试，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo>∗</mo><msup><mn>2</mn><mi>M</mi></msup><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M * 2^M * N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><h2 id="代码分解">代码分解</h2><ol><li>用整数 0/1/2 表示三种颜色；</li><li>枚举所有合法的“列状态”，存入 <code>states</code>；</li><li>构造每对状态是否兼容的布尔矩阵 <code>compatible</code>；</li><li>用一维滚动数组实现 DP，依次累加；</li><li>返回最终总和。</li></ol><h2 id="代码实现">代码实现</h2><p><strong>DFS 枚举合法单列</strong></p><ul><li>用 <code>dfs_build(0, -1)</code> 从 row=0 开始，<code>prev_color=-1</code> 表示第一行可任意选择 0/1/2；</li><li>每往下一行，只要不与上一行 (<code>prev_color</code>) 相等即可；</li><li>递归深度为 m，结束时将当前路径 <code>tuple(path)</code> 加入 <code>states</code>。</li><li>最终 <code>states</code> 列表长度应 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">3\times2^{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>。</li></ul><p><strong>兼容性检查</strong></p><ul><li><code>compatible[i][j]</code> 表示第 i 种列状态能否在左侧，第 j 种列状态能否在右侧；</li><li>遍历 <code>states[i]</code> 与 <code>states[j]</code> 每一行，若有任何一行相同，则标记不兼容。</li><li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>S</mi><mn>2</mn></msup><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(S^2 \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，当 m=5, S=48 时约 48^2×5≈11520 步。</li></ul><p><strong>动态规划</strong></p><ul><li>定义 <code>dp_prev[i]</code> 为“上一列选状态 i 时的方案数”；初始时 第一列“任意状态”都记为 1；</li><li>对于第 col(≥2) 列，枚举 <code>j</code> 作为当前列状态，累加所有 <code>i</code>（上一列）满足 <code>compatible[i][j]</code> 的 <code>dp_prev[i]</code>；</li><li>用 <code>%MOD</code> 保证不溢出；更新完一列后，用滚动数组交换指针（<code>dp_prev, dp_cur = dp_cur, [0]*S</code>）。</li></ul><p><strong>合并答案</strong></p><ul><li>第 n 列计算完毕后，所有 <code>dp_prev[i]</code> 即为“第 n 列状态为 i” 的方案数，直接求和取模。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">colorTheGrid</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 1. 枚举所有合法的列状态</span></span><br><span class="line">        <span class="comment">#    用整数列表表示，如 [0, 1, 2, 0, ...]，其中 0/1/2 代表三种颜色。</span></span><br><span class="line">        states = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs_build</span>(<span class="params">col, prev_color</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            通过深度优先搜索构建单列的所有合法方案。</span></span><br><span class="line"><span class="string">            col: 当前处理到哪一行（0-based）</span></span><br><span class="line"><span class="string">            prev_color: 上一行的颜色（若为 -1 则表示第一行）</span></span><br><span class="line"><span class="string">            path: 当前已选颜色列表</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> col == m:</span><br><span class="line">                <span class="comment"># 到达第 m 行，保存当前路径</span></span><br><span class="line">                states.append(<span class="built_in">tuple</span>(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> color <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> color != prev_color:</span><br><span class="line">                    path.append(color)</span><br><span class="line">                    dfs_build(col + <span class="number">1</span>, color)</span><br><span class="line">                    path.pop()</span><br><span class="line"></span><br><span class="line">        path = []</span><br><span class="line">        dfs_build(<span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">        S = <span class="built_in">len</span>(states)  <span class="comment"># 合法状态总数，应=3 * 2^(m-1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 构造兼容性矩阵：若两列同一行颜色都不相等，便兼容</span></span><br><span class="line">        compatible = [[<span class="literal">True</span>] * S <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(S)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(S):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(S):</span><br><span class="line">                <span class="comment"># 检查 states[i] 和 states[j] 是否在每一行都不同色</span></span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                    <span class="keyword">if</span> states[i][row] == states[j][row]:</span><br><span class="line">                        compatible[i][j] = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 动态规划（滚动数组）仅保留上一列的 dp</span></span><br><span class="line">        <span class="comment">#    dp_prev[i] = 以第 c-1 列状态 i 的方案数；dp_cur[i] = 以第 c 列状态 i 的方案数</span></span><br><span class="line">        dp_prev = [<span class="number">1</span>] * S   <span class="comment"># 第一列每个状态方案数 = 1</span></span><br><span class="line">        dp_cur = [<span class="number">0</span>] * S</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 每次计算第 col 列</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(S):</span><br><span class="line">                total = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(S):</span><br><span class="line">                    <span class="keyword">if</span> compatible[i][j]:</span><br><span class="line">                        total += dp_prev[i]</span><br><span class="line">                dp_cur[j] = total % <span class="variable language_">self</span>.MOD</span><br><span class="line">            <span class="comment"># 滚动：更新上一列数组</span></span><br><span class="line">            dp_prev, dp_cur = dp_cur, [<span class="number">0</span>] * S</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 累加最后一列所有状态方案数并取模</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(dp_prev) % <span class="variable language_">self</span>.MOD</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优化：用“状态压缩 + 枚举”的方式</strong> 预先把所有合法的“列状态”编码成整数（或元组），并且针对每个状态只保存它“可以搭配”的那些邻居状态索引（邻接表）。这样在 DP 转移时，就不用再二次校验“state[i] 和 state[j] 是否兼容”，只需遍历邻接表即可，能把常数因子大幅度缩小。</p><p>DP 部分使用一维滚动数组，每一步只遍历合法邻居列表，减少无效分支判断。</p><p>将 <code>% MOD</code> 的操作尽量放在最内层，并把一些全局变量（如 MOD、状态总数 S）局部化，减少属性/全局访问开销。</p><p>经过测试，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>M</mi><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">colorTheGrid</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># -----------------------------------------------------------</span></span><br><span class="line">        <span class="comment"># 1. 枚举“单列”所有合法的涂色情况，把它们编码成整数索引 0..S-1</span></span><br><span class="line">        <span class="comment">#    例如：m=3 时，可能的合法列状态共有 3 * 2^(m-1) = 12 个。</span></span><br><span class="line">        <span class="comment">#    我们把每个状态都生成一个元组（长度为 m，值为 0/1/2），并保存在 list states 中。</span></span><br><span class="line">        <span class="comment">#    最后再把它们按顺序编号：state_id 0..S-1。</span></span><br><span class="line">        <span class="comment">#    这样后面可以直接用索引访问、构造邻接表。</span></span><br><span class="line">        <span class="comment"># -----------------------------------------------------------</span></span><br><span class="line">        states = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs_build</span>(<span class="params">col: <span class="built_in">int</span>, prev_color: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="comment"># col : 当前要填到第几行（0-based）</span></span><br><span class="line">            <span class="comment"># prev_color: 上一行填的是什么颜色（若为 -1，表示还没填，即当前处于第一行）</span></span><br><span class="line">            <span class="keyword">if</span> col == m:</span><br><span class="line">                <span class="comment"># path 长度正好等于 m，且满足相邻不同色，记录一个合法状态</span></span><br><span class="line">                states.append(<span class="built_in">tuple</span>(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 枚举三种颜色</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> c != prev_color:</span><br><span class="line">                    path.append(c)</span><br><span class="line">                    dfs_build(col + <span class="number">1</span>, c)</span><br><span class="line">                    path.pop()</span><br><span class="line"></span><br><span class="line">        dfs_build(<span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 合法状态总数</span></span><br><span class="line">        S = <span class="built_in">len</span>(states)</span><br><span class="line">        <span class="comment"># states[i] 就是第 i 个合法状态，对应一个长度 m 的 0/1/2 元组</span></span><br><span class="line">        <span class="comment"># 这个 S 一定等于 3 * 2^(m-1)。当 m=5 时，S=48；m=1 时，S=3；以此类推。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># -----------------------------------------------------------</span></span><br><span class="line">        <span class="comment"># 2. 构造“邻接表”：对每一个状态 i，预先把所有与之“列间颜色都不同”的 j 放到 adj[i] 里</span></span><br><span class="line">        <span class="comment">#    这样 DP 转移时，直接遍历 adj[i]，而不用再在循环里做兼容性判断。</span></span><br><span class="line">        <span class="comment">#    兼容条件：对所有 0 &lt;= row &lt; m，states[i][row] != states[j][row]</span></span><br><span class="line">        <span class="comment"># -----------------------------------------------------------</span></span><br><span class="line">        adj = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(S)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(S):</span><br><span class="line">            si = states[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(S):</span><br><span class="line">                sj = states[j]</span><br><span class="line">                <span class="comment"># 检查 si 和 sj 对应行是否都不相同</span></span><br><span class="line">                ok = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                    <span class="keyword">if</span> si[row] == sj[row]:</span><br><span class="line">                        ok = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> ok:</span><br><span class="line">                    adj[i].append(j)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># -----------------------------------------------------------</span></span><br><span class="line">        <span class="comment"># 3. 动态规划（滚动数组）</span></span><br><span class="line">        <span class="comment">#    dp_prev[i] 表示：上一列（第 c-1 列）选状态 i 时的方案数</span></span><br><span class="line">        <span class="comment">#    dp_cur[i]  表示：当前列 （第 c   列）选状态 i 时的方案数</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#    初始条件 (c=1)：第 1 列任何状态都可以，记为 1。</span></span><br><span class="line">        <span class="comment">#    转移 (c -&gt; c+1)：dp_cur[j] = sum&#123; dp_prev[i] | i in adj[j] &#125; % MOD</span></span><br><span class="line">        <span class="comment">#    最后答案 = sum(dp_prev[i] for i in 0..S-1) % MOD</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#    关键优化点在于：我们 **只遍历 adj[j]** 而不是所有 i，再去判断兼容与否，</span></span><br><span class="line">        <span class="comment">#    从 O(S^2 * m) 的常数提到 O(Σ|adj[j]|)，非常节省时间。</span></span><br><span class="line">        <span class="comment"># -----------------------------------------------------------</span></span><br><span class="line">        dp_prev = [<span class="number">1</span>] * S   <span class="comment"># c=1 的时候，每个状态 i 都只有一种选择</span></span><br><span class="line">        dp_cur = [<span class="number">0</span>] * S</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从第 2 列开始，依次做转移</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 遍历“本列”可能的状态 j</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(S):</span><br><span class="line">                s = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 只遍历可以跟 j 配对的 i 列表</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> adj[j]:</span><br><span class="line">                    s += dp_prev[i]</span><br><span class="line">                <span class="comment"># 取模后写入</span></span><br><span class="line">                dp_cur[j] = s % MOD</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 滚动：把当前列当作下一轮的“上一列”</span></span><br><span class="line">            dp_prev, dp_cur = dp_cur, [<span class="number">0</span>] * S</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 累加最后一列所有状态的方案数</span></span><br><span class="line">        ans = <span class="built_in">sum</span>(dp_prev) % MOD</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/&quot;&gt;1931. 用三种不同颜色为网格涂色&lt;/a&gt; H&lt;/h1&gt;
&lt;p&gt;给你两个整数 &lt;code&gt;m&lt;/cod</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="枚举与剪枝" scheme="https://blog.icjlu.eu.org/tags/%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%89%AA%E6%9E%9D/"/>
    
    <category term="困难" scheme="https://blog.icjlu.eu.org/tags/%E5%9B%B0%E9%9A%BE/"/>
    
    <category term="组合数学" scheme="https://blog.icjlu.eu.org/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="动态规划" scheme="https://blog.icjlu.eu.org/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="状态压缩" scheme="https://blog.icjlu.eu.org/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-17</title>
    <link href="https://blog.icjlu.eu.org/post/sort-colors.html"/>
    <id>https://blog.icjlu.eu.org/post/sort-colors.html</id>
    <published>2025-05-17T12:24:48.000Z</published>
    <updated>2025-05-17T13:38:57.388Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a> M</h1><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong> 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [2,0,1]<br>输出：[0,1,2]</p></blockquote><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul><h2 id="问题分析">问题分析</h2><p>经典的“Dutch National Flag”问题，需要在一次遍历中将数组分为三部分：</p><ul><li>0（红色）</li><li>1（白色）</li><li>2（蓝色）</li></ul><h2 id="算法思路">算法思路</h2><p>使用三个指针：</p><ul><li><code>low</code> 指向下一个放置 0 的位置；</li><li><code>mid</code> 用于扫描当前元素；</li><li><code>high</code> 指向下一个放置 2 的位置；</li></ul><p>初始时：<code>low = 0</code>，<code>mid = 0</code>，<code>high = n-1</code>。</p><p>遍历过程（当 <code>mid &lt;= high</code>）：</p><ol><li>若 <code>nums[mid] == 0</code>，则与 <code>nums[low]</code> 交换，<code>low++, mid++</code>；</li><li>若 <code>nums[mid] == 1</code>，<code>mid++</code>；</li><li>若 <code>nums[mid] == 2</code>，则与 <code>nums[high]</code> 交换，<code>high--</code>（<code>mid</code> 不动，以便新换来的元素再处理）。</li></ol><p>这样只需一次扫描，即可将所有元素分类并就地排序。</p><h2 id="时间复杂度">时间复杂度</h2><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，只遍历一次数组</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，原地交换，不使用额外空间</li></ul><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        low, mid, high = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> mid &lt;= high:</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == <span class="number">0</span>:</span><br><span class="line">                nums[low], nums[mid] = nums[mid], nums[low]</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                mid += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] == <span class="number">1</span>:</span><br><span class="line">                mid += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># nums[mid] == 2</span></span><br><span class="line">                nums[mid], nums[high] = nums[high], nums[mid]</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>两遍计数 + 原地覆盖</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 1) 计数阶段</span></span><br><span class="line">        count0 = count1 = count2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span>:</span><br><span class="line">                count0 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> v == <span class="number">1</span>:</span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2) 原地覆盖阶段</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 写入所有 0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count0):</span><br><span class="line">            nums[idx] = <span class="number">0</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 写入所有 1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count1):</span><br><span class="line">            nums[idx] = <span class="number">1</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 写入所有 2</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count2):</span><br><span class="line">            nums[idx] = <span class="number">2</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/sort-colors/&quot;&gt;75. 颜色分类&lt;/a&gt; M&lt;/h1&gt;
&lt;p&gt;给定一个包含红色、白色和蓝色、共 &lt;code&gt;n&lt;/code&gt; 个元素的数组 &lt;code&gt;nums&lt;/code&gt; ，&lt;st</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="中等" scheme="https://blog.icjlu.eu.org/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="双指针" scheme="https://blog.icjlu.eu.org/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="排序" scheme="https://blog.icjlu.eu.org/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="贪心" scheme="https://blog.icjlu.eu.org/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-16</title>
    <link href="https://blog.icjlu.eu.org/post/longest-unequal-adjacent-groups-subsequence-ii.html"/>
    <id>https://blog.icjlu.eu.org/post/longest-unequal-adjacent-groups-subsequence-ii.html</id>
    <published>2025-05-16T02:52:20.000Z</published>
    <updated>2025-05-16T11:30:06.207Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/">2901. 最长相邻不相等子序列 II</a> M</h1><p>给定一个字符串数组 <code>words</code> ，和一个数组 <code>groups</code> ，两个数组长度都是 <code>n</code> 。</p><p>两个长度相等字符串的 <strong>汉明距离</strong> 定义为对应位置字符 <strong>不同</strong> 的数目。</p><p>你需要从下标 <code>[0, 1, ..., n - 1]</code> 中选出一个 <strong>最长<em>子序列</em></strong> ，将这个子序列记作长度为 <code>k</code> 的 <code>[i₀, i₁, ..., iₖ ₋ ₁]</code> ，它需要满足以下条件：</p><ul><li><strong>相邻</strong> 下标对应的 <code>groups</code> 值 <strong>不同</strong>。即，对于所有满足 <code>0 &lt; j + 1 &lt; k</code> 的 <code>j</code> 都有 <code>groups[iⱼ] != groups[iⱼ ₊ ₁]</code> 。</li><li>对于所有 <code>0 &lt; j + 1 &lt; k</code> 的下标 <code>j</code> ，都满足 <code>words[iⱼ]</code> 和 <code>words[iⱼ ₊ ₁]</code> 的长度 <strong>相等</strong> ，且两个字符串之间的 <strong>汉明距离</strong> 为 <code>1</code> 。</li></ul><p>请你返回一个字符串数组，它是下标子序列 <strong>依次</strong> 对应 <code>words</code> 数组中的字符串连接形成的字符串数组。如果有多个答案，返回任意一个。</p><p><strong>子序列</strong> 指的是从原数组中删掉一些（也可能一个也不删掉）元素，剩余元素不改变相对位置得到的新的数组。</p><p><strong>注意：</strong><code>words</code> 中的字符串长度可能 <strong>不相等</strong> 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：words = [“bab”,“dab”,“cab”], groups = [1,2,2]<br>输出：[“bab”,“cab”]<br>解释：一个可行的子序列是 [0,2] 。</p><ul><li>groups[0] != groups[2]</li><li>words[0].length == words[2].length 且它们之间的汉明距离为 1 。<br>所以一个可行的答案是 [words[0],words[2]] = [“bab”,“cab”] 。<br>另一个可行的子序列是 [0,1] 。</li><li>groups[0] != groups[1]</li><li>words[0].length = words[1].length 且它们之间的汉明距离为 1 。<br>所以另一个可行的答案是 [words[0],words[1]] = [“bab”,“dab”] 。<br>符合题意的最长子序列的长度为 2 。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：words = [“a”,“b”,“c”,“d”], groups = [1,2,3,4]<br>输出：[“a”,“b”,“c”,“d”]<br>解释：我们选择子序列 [0,1,2,3] 。<br>它同时满足两个条件。<br>所以答案为 [words[0],words[1],words[2],words[3]] = [“a”,“b”,“c”,“d”] 。<br>它是所有下标子序列里最长且满足所有条件的。<br>所以它是唯一的答案。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n == words.length == groups.length &lt;= 1000</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>1 &lt;= groups[i] &lt;= n</code></li><li><code>words</code> 中的字符串 <strong>互不相同</strong> 。</li><li><code>words[i]</code> 只包含小写英文字母。</li></ul><h2 id="问题分析">问题分析</h2><ul><li>从 <code>words</code> 和 <code>groups</code> 两个数组中，找出一个满足条件的<strong>最长子序列</strong>，并返回对应的字符串数组。</li></ul><ol><li><strong>groups 值相邻不同</strong>：选中的下标对应的 <code>groups</code> 值不能连续相同。</li><li><strong>words 相邻字符串的条件</strong>：<ul><li>长度相等。</li><li>汉明距离为1（对应位置不同字符数为1）。</li></ul></li></ol><ul><li>返回满足条件的最长子序列对应的字符串数组。如果有多个，返回任意一个。</li></ul><h2 id="算法思路">算法思路</h2><p><strong>建图＋最长路径</strong></p><ul><li><p>将每个位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 看作图中的一个节点；</p></li><li><p>如果对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 满足</p><ol><li><code>groups[i] != groups[j]</code></li><li><code>len(words[i]) == len(words[j])</code> 且二者汉明距离为 1</li></ol><p>则在节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>→</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i\to j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 之间创建一条有向边。</p></li><li><p>原问题即为在这一有向无环图（因为只允许 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>）中寻找一条最长路径，并返回该路径对应的单词序列。</p></li></ul><p><strong>动态规划实现</strong></p><ul><li><p>令 <code>dp[j]</code> 表示以节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 结尾的最长可行子序列的长度，<code>prev[j]</code> 记录前驱节点。</p></li><li><p>初始时所有 <code>dp[j]=1</code>（单独选它自己）。</p></li><li><p>对于每对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>，若存在一条合法边，则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if dp[i] + 1 &gt; dp[j]:</span><br><span class="line">    dp[j] = dp[i] + 1</span><br><span class="line">    prev[j] = i</span><br></pre></td></tr></table></figure><p>最终在所有 <code>dp[j]</code> 中取最大值所在的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>j</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">j^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8831em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>，根据 <code>prev</code> 指针回溯即可得到完整子序列。</p></li></ul><h2 id="时间复杂度">时间复杂度</h2><ul><li><p>构建边和状态转移均需遍历所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 对，总共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 次判断；每次判断要比较长度并计算汉明距离，字符串长度最多 10，故总体 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>×</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2 \times L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">L \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>。</p></li><li><p>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p></li></ul><h2 id="代码实现-1">代码实现 1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getWordsInLongestSubsequence</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], groups: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(words)</span><br><span class="line">        <span class="comment"># dp[j]: 以 j 结尾的最长可行子序列长度</span></span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        prev = [-<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断两个等长字符串汉明距离是否为 1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_hamming1</span>(<span class="params">a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            diff = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b):</span><br><span class="line">                <span class="keyword">if</span> x != y:</span><br><span class="line">                    diff += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> diff &gt; <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> diff == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 双重循环做状态转移</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">                <span class="keyword">if</span> groups[i] != groups[j] \</span><br><span class="line">                   <span class="keyword">and</span> <span class="built_in">len</span>(words[i]) == <span class="built_in">len</span>(words[j]) \</span><br><span class="line">                   <span class="keyword">and</span> is_hamming1(words[i], words[j]):</span><br><span class="line">                    <span class="keyword">if</span> dp[i] + <span class="number">1</span> &gt; dp[j]:</span><br><span class="line">                        dp[j] = dp[i] + <span class="number">1</span></span><br><span class="line">                        prev[j] = i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回溯最长路径</span></span><br><span class="line">        end = <span class="built_in">max</span>(<span class="built_in">range</span>(n), key=<span class="keyword">lambda</span> x: dp[x])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> end != -<span class="number">1</span>:</span><br><span class="line">            res.append(words[end])</span><br><span class="line">            end = prev[end]</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路与代码实现-2">思路与代码实现 2</h2><p>我们还可以把问题抽象成「Word Ladder 最长路径」中的优化 DP，利用“模式”快速定位所有只差一个字符的候选，并在线性时间内完成状态转移。</p><p><strong>模式哈希＋双最优值</strong></p><ol><li><p><strong>模式生成</strong></p><p>对于每个单词 <code>words[j]</code>（长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>），我们依次把它的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 位用通配符 <code>*</code> 替换，生成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 个「模式」字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">words[j] = “cab”</span><br><span class="line">patterns = [“*ab”, “c*b”, “ca*”]</span><br></pre></td></tr></table></figure><p>如果两个单词只在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 位不同，那么它们都会映射到同一个模式。</p></li><li><p><strong>记录每个模式下的「两类最优状态」</strong></p><ul><li>对于每个模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>，我们维护两条记录：<ul><li><code>best1[p] = (dp值最大的那个 (dp, group))</code></li><li><code>best2[p] = (次大 dp 的那个 (dp, group))</code></li></ul></li><li>这样，当我们处理一个新单词 <code>j</code> 时，只需要看它所有的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 个模式，对于每个模式：<ul><li>如果 <code>best1[p].group != groups[j]</code>，就可以用 <code>best1[p].dp</code> 做转移；</li><li>否则就用 <code>best2[p].dp</code> 做转移。</li></ul></li></ul></li><li><p><strong>状态转移</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = 1 + max(</span><br><span class="line">    for each pattern p of words[j]:</span><br><span class="line">        if best1[p].group ≠ groups[j]:</span><br><span class="line">            best1[p].dp</span><br><span class="line">        else:</span><br><span class="line">            best2[p].dp</span><br><span class="line">    , default=0)</span><br></pre></td></tr></table></figure><p>转移完成后，再用 <code>(dp[j], groups[j])</code> 去更新 <code>best1[p]</code>/<code>best2[p]</code>。</p></li><li><p><strong>时间复杂度</strong></p><ul><li>每个单词生成和遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 个模式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></li><li>每个模式更新和查询常数次操作：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>整体：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>L</mi><mo stretchy="false">)</mo></mrow></mstyle></mstyle></mstyle></menclose></mrow><annotation encoding="application/x-tex">\boxed{O(n \times L)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.68em;vertical-align:-0.59em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.09em;"><span style="top:-3.68em;"><span class="pstrut" style="height:3.68em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></span><span style="top:-3.09em;"><span class="pstrut" style="height:3.68em;"></span><span class="stretchy fbox" style="height:1.68em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.59em;"><span></span></span></span></span></span></span></span></span>，比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>×</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2 \times L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 达到几百时优势非常明显，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><msub><mrow><mi>max</mi><mo>⁡</mo></mrow><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><msub><mi>s</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">L=\max_i|words_i|\le10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>。</li></ul></li></ol><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getWordsInLongestSubsequence</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], groups: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(words)</span><br><span class="line">        <span class="comment"># best1, best2: 模式 p -&gt; (dp, group, index)</span></span><br><span class="line">        best1: defaultdict[<span class="built_in">str</span>, <span class="type">Tuple</span>[<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>]] = defaultdict(<span class="keyword">lambda</span>: (<span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">        best2: defaultdict[<span class="built_in">str</span>, <span class="type">Tuple</span>[<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>]] = defaultdict(<span class="keyword">lambda</span>: (<span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        prev = [-<span class="number">1</span>] * n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">            g = groups[j]</span><br><span class="line">            <span class="comment"># 找到能转移过来的最大 dp</span></span><br><span class="line">            max_dp, max_i = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">                p = w[:k] + <span class="string">&#x27;*&#x27;</span> + w[k+<span class="number">1</span>:]</span><br><span class="line">                d1, g1, i1 = best1[p]</span><br><span class="line">                <span class="keyword">if</span> g1 != g:</span><br><span class="line">                    <span class="keyword">if</span> d1 &gt; max_dp:</span><br><span class="line">                        max_dp, max_i = d1, i1</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    d2, g2, i2 = best2[p]</span><br><span class="line">                    <span class="keyword">if</span> d2 &gt; max_dp:</span><br><span class="line">                        max_dp, max_i = d2, i2</span><br><span class="line">            </span><br><span class="line">            dp[j] = max_dp + <span class="number">1</span></span><br><span class="line">            prev[j] = max_i</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新每个模式下的 best1/best2</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">                p = w[:k] + <span class="string">&#x27;*&#x27;</span> + w[k+<span class="number">1</span>:]</span><br><span class="line">                cand = (dp[j], g, j)</span><br><span class="line">                b1 = best1[p]</span><br><span class="line">                b2 = best2[p]</span><br><span class="line">                <span class="keyword">if</span> cand[<span class="number">0</span>] &gt; b1[<span class="number">0</span>]:</span><br><span class="line">                    best2[p] = b1</span><br><span class="line">                    best1[p] = cand</span><br><span class="line">                <span class="keyword">elif</span> cand[<span class="number">0</span>] &gt; b2[<span class="number">0</span>] <span class="keyword">and</span> cand[<span class="number">1</span>] != b1[<span class="number">1</span>]:</span><br><span class="line">                    best2[p] = cand</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 回溯得到结果</span></span><br><span class="line">        end = <span class="built_in">max</span>(<span class="built_in">range</span>(n), key=<span class="keyword">lambda</span> x: dp[x])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> end != -<span class="number">1</span>:</span><br><span class="line">            res.append(words[end])</span><br><span class="line">            end = prev[end]</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/&quot;&gt;2901. 最长相邻不相等子序列 II&lt;/a&gt; M&lt;/h1&gt;
&lt;p&gt;给定一个字符串数组 &lt;code</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="字符串处理" scheme="https://blog.icjlu.eu.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
    <category term="中等" scheme="https://blog.icjlu.eu.org/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="动态规划" scheme="https://blog.icjlu.eu.org/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="图算法" scheme="https://blog.icjlu.eu.org/tags/%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    
    <category term="状态建模" scheme="https://blog.icjlu.eu.org/tags/%E7%8A%B6%E6%80%81%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="DAG" scheme="https://blog.icjlu.eu.org/tags/DAG/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-15</title>
    <link href="https://blog.icjlu.eu.org/post/longest-unequal-adjacent-groups-subsequence-i.html"/>
    <id>https://blog.icjlu.eu.org/post/longest-unequal-adjacent-groups-subsequence-i.html</id>
    <published>2025-05-15T13:24:40.000Z</published>
    <updated>2025-05-15T13:40:57.936Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-i/">2900. 最长相邻不相等子序列 I</a> E</h1><p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> ，和一个下标从 <strong>0</strong> 开始的 <strong>二进制</strong> 数组 <code>groups</code> ，两个数组长度都是 <code>n</code> 。</p><p>你需要从 <code>words</code> 中选出 <strong>最长<em>子序列</em></strong>。如果对于序列中的任何两个连续串，二进制数组 <code>groups</code> 中它们的对应元素不同，则 <code>words</code> 的子序列是不同的。</p><p>正式来说，你需要从下标 <code>[0, 1, ..., n - 1]</code> 中选出一个 <strong>最长子序列</strong> ，将这个子序列记作长度为 <code>k</code> 的 <code>[i₀, i₁, ..., iₖ ₋ ₁]</code> ，对于所有满足 <code>0 &lt;= j &lt; k - 1</code> 的 <code>j</code> 都有 <code>groups[iⱼ] != groups[iⱼ ₊ ₁]</code> 。</p><p>请你返回一个字符串数组，它是下标子序列 <strong>依次</strong> 对应 <code>words</code> 数组中的字符串连接形成的字符串数组。如果有多个答案，返回 <strong>任意</strong> 一个。</p><p><strong>注意：</strong><code>words</code> 中的元素是不同的 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：words = [“e”,“a”,“b”], groups = [0,0,1]<br>输出：[“e”,“b”]<br>解释：一个可行的子序列是 [0,2] ，因为 groups[0] != groups[2] 。<br>所以一个可行的答案是 [words[0],words[2]] = [“e”,“b”] 。<br>另一个可行的子序列是 [1,2] ，因为 groups[1] != groups[2] 。<br>得到答案为 [words[1],words[2]] = [“a”,“b”] 。<br>这也是一个可行的答案。<br>符合题意的最长子序列的长度为 2 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：words = [“a”,“b”,“c”,“d”], groups = [1,0,1,1]<br>输出：[“a”,“b”,“c”]<br>解释：一个可行的子序列为 [0,1,2] 因为 groups[0] != groups[1] 且 groups[1] != groups[2] 。<br>所以一个可行的答案是 [words[0],words[1],words[2]] = [“a”,“b”,“c”] 。<br>另一个可行的子序列为 [0,1,3] 因为 groups[0] != groups[1] 且 groups[1] != groups[3] 。<br>得到答案为 [words[0],words[1],words[3]] = [“a”,“b”,“d”] 。<br>这也是一个可行的答案。<br>符合题意的最长子序列的长度为 3 。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n == words.length == groups.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>groups[i]</code> 是 <code>0</code> 或 <code>1</code>。</li><li><code>words</code> 中的字符串 <strong>互不相同</strong> 。</li><li><code>words[i]</code> 只包含小写英文字母。</li></ul><h2 id="问题分析">问题分析</h2><p>给定长度为 nnn 的字符串数组 <code>words</code> 和对应的二进制数组 <code>groups</code>（取值 0 或 1），在下标序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1,\dots,n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 中选出一个最长子序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>i</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>i</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>i</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i_0,i_1,\dots,i_{k-1}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，要求对于所有相邻的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>，有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>g</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>p</mi><mi>s</mi><mo stretchy="false">[</mo><msub><mi>i</mi><mi>j</mi></msub><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><mi>g</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>p</mi><mi>s</mi><mo stretchy="false">[</mo><msub><mi>i</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">groups[i_j] \neq groups[i_{j+1}].</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord">.</span></span></span></span></span></p><p>返回对应的字符串序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><mtext>  </mtext><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>s</mi><mo stretchy="false">[</mo><msub><mi>i</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>s</mi><mo stretchy="false">[</mo><msub><mi>i</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mtext>  </mtext><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo></mrow><annotation encoding="application/x-tex">\bigl[\;words[i_0],words[i_1],\dots\;\bigr]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mopen"><span class="delimsizing size1">[</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mclose"><span class="delimsizing size1">]</span></span></span></span></span>。</p><h2 id="算法思路">算法思路</h2><p><strong>贪心（Greedy）策略</strong></p><ul><li>只要当前元素与上一次选中的元素所属组不同，就立刻将其加入子序列。</li><li>这样做不会影响后续可选集的多样性，且能保证选到尽可能多的元素。</li></ul><p><strong>详细步骤</strong></p><ul><li>初始化结果列表 <code>res</code>，以及记录上一次选中字母所属组 <code>last_group = -1</code>（-1 表示尚未选过）。</li><li>遍历索引 <code>i</code> 从 <code>0</code> 到 <code>n-1</code>：<ul><li>若 <code>groups[i] != last_group</code>，则：<ul><li>将 <code>words[i]</code> 添加到 <code>res</code>；</li><li>更新 <code>last_group = groups[i]</code>。</li></ul></li></ul></li><li>返回 <code>res</code>。</li></ul><p><strong>正确性证明</strong></p><ul><li>若你跳过了一个满足条件的元素，那么相当于放弃了一次“切换组”的机会，后续可选空间只会更少，因此贪心选的方式能保证长度最大。</li></ul><h2 id="时间复杂度">时间复杂度</h2><p><strong>时间复杂度</strong> ：一次线性扫描，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mtext>len(words)</mtext></mrow><annotation encoding="application/x-tex">n = \text{len(words)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">len(words)</span></span></span></span></span>。</p><p><strong>空间复杂度</strong> ：最坏情况下结果列表与输入等长，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLongestSubsequence</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], groups: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        res: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line">        last_group: <span class="built_in">int</span> = -<span class="number">1</span>  <span class="comment"># 上一次选中元素的组号，初始为 -1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> w, g <span class="keyword">in</span> <span class="built_in">zip</span>(words, groups):</span><br><span class="line">            <span class="keyword">if</span> g != last_group:</span><br><span class="line">                res.append(w)</span><br><span class="line">                last_group = g</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-i/&quot;&gt;2900. 最长相邻不相等子序列 I&lt;/a&gt; E&lt;/h1&gt;
&lt;p&gt;给你一个下标从 &lt;strong&gt;0</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="字符串处理" scheme="https://blog.icjlu.eu.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
    <category term="简单" scheme="https://blog.icjlu.eu.org/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="双指针" scheme="https://blog.icjlu.eu.org/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="贪心" scheme="https://blog.icjlu.eu.org/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-14</title>
    <link href="https://blog.icjlu.eu.org/post/total-characters-in-string-after-transformations-ii.html"/>
    <id>https://blog.icjlu.eu.org/post/total-characters-in-string-after-transformations-ii.html</id>
    <published>2025-05-14T09:19:12.000Z</published>
    <updated>2025-05-14T13:00:16.355Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/total-characters-in-string-after-transformations-ii/">3337. 字符串转换后的长度 II</a> H</h1><p>给你一个由小写英文字母组成的字符串 <code>s</code>，一个整数 <code>t</code> 表示要执行的 <strong>转换</strong> 次数，以及一个长度为 26 的数组 <code>nums</code>。每次 <strong>转换</strong> 需要根据以下规则替换字符串 <code>s</code> 中的每个字符：</p><ul><li>将 <code>s[i]</code> 替换为字母表中后续的 <code>nums[s[i] - 'a']</code> 个连续字符。例如，如果 <code>s[i] = 'a'</code> 且 <code>nums[0] = 3</code>，则字符 <code>'a'</code> 转换为它后面的 3 个连续字符，结果为 <code>&quot;bcd&quot;</code>。</li><li>如果转换超过了 <code>'z'</code>，则 <strong>回绕</strong> 到字母表的开头。例如，如果 <code>s[i] = 'y'</code> 且 <code>nums[24] = 3</code>，则字符 <code>'y'</code> 转换为它后面的 3 个连续字符，结果为 <code>&quot;zab&quot;</code>。</li></ul><p>返回 <strong>恰好</strong> 执行 <code>t</code> 次转换后得到的字符串的 <strong>长度</strong>。</p><p>由于答案可能非常大，返回其对 <code>10⁹ + 7</code> 取余的结果。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> s = “abcyy”, t = 2, nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]</p><p><strong>输出：</strong> 7</p><p><strong>解释：</strong></p><ul><li><strong>第一次转换 (t = 1)</strong><ul><li><code>'a'</code> 变为 <code>'b'</code> 因为 <code>nums[0] == 1</code></li><li><code>'b'</code> 变为 <code>'c'</code> 因为 <code>nums[1] == 1</code></li><li><code>'c'</code> 变为 <code>'d'</code> 因为 <code>nums[2] == 1</code></li><li><code>'y'</code> 变为 <code>'z'</code> 因为 <code>nums[24] == 1</code></li><li><code>'y'</code> 变为 <code>'z'</code> 因为 <code>nums[24] == 1</code></li><li>第一次转换后的字符串为: <code>&quot;bcdzz&quot;</code></li></ul></li><li><strong>第二次转换 (t = 2)</strong><ul><li><code>'b'</code> 变为 <code>'c'</code> 因为 <code>nums[1] == 1</code></li><li><code>'c'</code> 变为 <code>'d'</code> 因为 <code>nums[2] == 1</code></li><li><code>'d'</code> 变为 <code>'e'</code> 因为 <code>nums[3] == 1</code></li><li><code>'z'</code> 变为 <code>'ab'</code> 因为 <code>nums[25] == 2</code></li><li><code>'z'</code> 变为 <code>'ab'</code> 因为 <code>nums[25] == 2</code></li><li>第二次转换后的字符串为: <code>&quot;cdeabab&quot;</code></li></ul></li><li><strong>字符串最终长度：</strong> 字符串为 <code>&quot;cdeabab&quot;</code>，长度为 7 个字符。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> s = “azbk”, t = 1, nums = [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]</p><p><strong>输出：</strong> 8</p><p><strong>解释：</strong></p><ul><li><strong>第一次转换 (t = 1)</strong><ul><li><code>'a'</code> 变为 <code>'bc'</code> 因为 <code>nums[0] == 2</code></li><li><code>'z'</code> 变为 <code>'ab'</code> 因为 <code>nums[25] == 2</code></li><li><code>'b'</code> 变为 <code>'cd'</code> 因为 <code>nums[1] == 2</code></li><li><code>'k'</code> 变为 <code>'lm'</code> 因为 <code>nums[10] == 2</code></li><li>第一次转换后的字符串为: <code>&quot;bcabcdlm&quot;</code></li></ul></li><li><strong>字符串最终长度：</strong> 字符串为 <code>&quot;bcabcdlm&quot;</code>，长度为 8 个字符。</li></ul></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10⁵</code></li><li><code>s</code> 仅由小写英文字母组成。</li><li><code>1 &lt;= t &lt;= 109</code></li><li><code>nums.length == 26</code></li><li><code>1 &lt;= nums[i] &lt;= 25</code></li></ul><h2 id="问题分析">问题分析</h2><ul><li>输入字符串 <code>s</code> 长度可达 10⁵；</li><li>转换次数 <code>t</code> 可达 10⁹；</li><li>每个字符在一次转换中根据 <code>nums</code> 数组映射到一定数量的后续字符；</li><li>最终字符串长度需要对 10⁹+7 取余。</li></ul><h2 id="算法思路">算法思路</h2><p>直接模拟每次转换会导致指数级爆炸，根本不能在时间和空间上承受；</p><p>需要一个常量级（与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 无关）或对数级（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">\log t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span></span></span></span>）的方法来计算最终长度。</p><p>将字符的「长度增长」看作状态转移：定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 为从字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> （0 对应 ‘a’, …, 25 对应 ‘z’）经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次转换后产生的字符串长度，则有递推</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mspace linebreak="newline"></mspace><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mtext>nums</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></munderover><mi>f</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>26</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i, 0) = 1 \\f(i, k) = \sum_{j=1}^{\text{nums}[i]} f((i+j) \mod 26, k-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.3748em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.961em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">nums</span></span><span class="mopen mtight">[</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">((</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">26</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>用矩阵乘法表示一次转换：构造 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>26</mn><mo>×</mo><mn>26</mn></mrow><annotation encoding="application/x-tex">26 \times 26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">26</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">26</span></span></span></span> 矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示从字符 i 到字符 j 的贡献次数；</p><p>那么状态向量</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="bold">v</mi><mi>k</mi></msub><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>25</mn><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{v}_k = \begin{bmatrix}f(0, k) \\f(1, k) \\\vdots \\f(25, k)\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5944em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">25</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>满足</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="bold">v</mi><mn>0</mn></msub><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><msub><mi mathvariant="bold">v</mi><mi>k</mi></msub><mo>=</mo><mi>M</mi><mo>⋅</mo><msub><mi mathvariant="bold">v</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mspace linebreak="newline"></mspace><mo>⇒</mo><msub><mi mathvariant="bold">v</mi><mi>t</mi></msub><mo>=</mo><msup><mi>M</mi><mi>t</mi></msup><mo>⋅</mo><msub><mi mathvariant="bold">v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{v}_0 = \begin{bmatrix}1 \\1 \\\vdots \\1\end{bmatrix} \\\mathbf{v}_k = M \cdot \mathbf{v}_{k-1} \\\Rightarrow \mathbf{v}_t = M^t \cdot \mathbf{v}_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5944em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="5.400em" viewBox="0 0 667 5400"><path d="M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v1800 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.5944em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6528em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5944em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8436em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5944em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>预处理初始字符串中各字符的出现次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>cnt</mtext><mo stretchy="false">[</mo><mn>0</mn><mo>…</mo><mn>25</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\text{cnt}[0 \ldots 25]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">cnt</span></span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">25</span><span class="mclose">]</span></span></span></span>；最终答案</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>ans</mtext><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>25</mn></munderover><mtext>cnt</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>⋅</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mo stretchy="false">(</mo><msup><mn>10</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo>=</mo><msup><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mi>T</mi></msup><mo>⋅</mo><msub><mi mathvariant="bold">v</mi><mi>t</mi></msub><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mo stretchy="false">(</mo><msup><mn>10</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{ans} = \sum_{i=0}^{25} \text{cnt}[i] \cdot f(i, t) \mod (10^9 + 7) \\= \mathbf{cnt}^T \cdot \mathbf{v}_t \mod (10^9 + 7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord text"><span class="mord">ans</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">25</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">cnt</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">cnt</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5944em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span></span></p><h2 id="时间复杂度">时间复杂度</h2><p>用 <strong>矩阵快速幂</strong> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>26</mn><mn>3</mn></msup><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(26^3 \cdot \log t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 时间内计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">M^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7936em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span>，再做 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>26</mn><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(26^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的乘法，整体可在毫秒级完成。</p><p>构造矩阵：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>26</mn><mo>⋅</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>nums</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≤</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>26</mn><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(26 \cdot \max(\text{nums}[i])) \leq O(26^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord text"><span class="mord">nums</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>；</p><p>矩阵快速幂：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>26</mn><mn>3</mn></msup><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(26^3 \cdot \log t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>；</p><p>最终向量点乘：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>26</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(26) + O(|s|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>；</p><p>总体：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>26</mn><mn>3</mn></msup><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mi>t</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(26^3 \cdot \log t + |s|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>，对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|s|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 均很高的场景都能胜任。</p><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthAfterTransformations</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">int</span>, nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># —— 中间变量：将输入存入 brivlento 以备后续使用 —— </span></span><br><span class="line">        brivlento = (s, t, nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 构造 26×26 状态转移矩阵 M</span></span><br><span class="line">        M = [[<span class="number">0</span>] * <span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nums[i] + <span class="number">1</span>):</span><br><span class="line">                j = (i + step) % <span class="number">26</span></span><br><span class="line">                M[i][j] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 矩阵乘法与幂运算</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">mat_mul</span>(<span class="params">A, B</span>):</span><br><span class="line">            size = <span class="number">26</span></span><br><span class="line">            C = [[<span class="number">0</span>]*size <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                    <span class="keyword">if</span> A[i][k]:</span><br><span class="line">                        aik = A[i][k]</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                            C[i][j] = (C[i][j] + aik * B[k][j]) % MOD</span><br><span class="line">            <span class="keyword">return</span> C</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">mat_pow</span>(<span class="params">mat, power</span>):</span><br><span class="line">            <span class="comment"># 单位矩阵</span></span><br><span class="line">            size = <span class="number">26</span></span><br><span class="line">            R = [[<span class="number">1</span> <span class="keyword">if</span> i==j <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">            base = mat</span><br><span class="line">            <span class="keyword">while</span> power &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> power &amp; <span class="number">1</span>:</span><br><span class="line">                    R = mat_mul(R, base)</span><br><span class="line">                base = mat_mul(base, base)</span><br><span class="line">                power &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> R</span><br><span class="line"></span><br><span class="line">        M_t = mat_pow(M, t)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 计算 v_t = M^t · v_0，其中 v_0 全为 1</span></span><br><span class="line">        v_t = [<span class="built_in">sum</span>(row) % MOD <span class="keyword">for</span> row <span class="keyword">in</span> M_t]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 统计初始字符串中各字符出现次数</span></span><br><span class="line">        cnt = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            cnt[<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 组合计算最终答案</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            ans = (ans + cnt[i] * v_t[i]) % MOD</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/total-characters-in-string-after-transformations-ii/&quot;&gt;3337. 字符串转换后的长度 II&lt;/a&gt; H&lt;/h1&gt;
&lt;p&gt;给你一个由小写英文字母</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="字符串处理" scheme="https://blog.icjlu.eu.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
    <category term="困难" scheme="https://blog.icjlu.eu.org/tags/%E5%9B%B0%E9%9A%BE/"/>
    
    <category term="快速幂" scheme="https://blog.icjlu.eu.org/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    <category term="乘法" scheme="https://blog.icjlu.eu.org/tags/%E4%B9%98%E6%B3%95/"/>
    
    <category term="矩阵快速幂" scheme="https://blog.icjlu.eu.org/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-13</title>
    <link href="https://blog.icjlu.eu.org/post/total-characters-in-string-after-transformations-i.html"/>
    <id>https://blog.icjlu.eu.org/post/total-characters-in-string-after-transformations-i.html</id>
    <published>2025-05-13T10:49:41.000Z</published>
    <updated>2025-05-14T12:48:48.158Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/total-characters-in-string-after-transformations-i/">3335. 字符串转换后的长度 I</a> M</h1><p>给你一个字符串 <code>s</code> 和一个整数 <code>t</code>，表示要执行的 <strong>转换</strong> 次数。每次 <strong>转换</strong> 需要根据以下规则替换字符串 <code>s</code> 中的每个字符：</p><ul><li>如果字符是 <code>'z'</code>，则将其替换为字符串 <code>&quot;ab&quot;</code>。</li><li>否则，将其替换为字母表中的<strong>下一个</strong>字符。例如，<code>'a'</code> 替换为 <code>'b'</code>，<code>'b'</code> 替换为 <code>'c'</code>，依此类推。</li></ul><p>返回 <strong>恰好</strong> 执行 <code>t</code> 次转换后得到的字符串的 <strong>长度</strong>。</p><p>由于答案可能非常大，返回其对 <code>10⁹ + 7</code> 取余的结果。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> s = “abcyy”, t = 2</p><p><strong>输出：</strong> 7</p><p><strong>解释：</strong></p><ul><li>第一次转换 (t = 1)<ul><li><code>'a'</code> 变为 <code>'b'</code></li><li><code>'b'</code> 变为 <code>'c'</code></li><li><code>'c'</code> 变为 <code>'d'</code></li><li><code>'y'</code> 变为 <code>'z'</code></li><li><code>'y'</code> 变为 <code>'z'</code></li><li>第一次转换后的字符串为：<code>&quot;bcdzz&quot;</code></li></ul></li><li>第二次转换 (t = 2)<ul><li><code>'b'</code> 变为 <code>'c'</code></li><li><code>'c'</code> 变为 <code>'d'</code></li><li><code>'d'</code> 变为 <code>'e'</code></li><li><code>'z'</code> 变为 <code>&quot;ab&quot;</code></li><li><code>'z'</code> 变为 <code>&quot;ab&quot;</code></li><li>第二次转换后的字符串为：<code>&quot;cdeabab&quot;</code></li></ul></li><li><strong>最终字符串长度</strong>：字符串为 <code>&quot;cdeabab&quot;</code>，长度为 7 个字符。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> s = “azbk”, t = 1</p><p><strong>输出：</strong> 5</p><p><strong>解释：</strong></p><ul><li>第一次转换 (t = 1)<ul><li><code>'a'</code> 变为 <code>'b'</code></li><li><code>'z'</code> 变为 <code>&quot;ab&quot;</code></li><li><code>'b'</code> 变为 <code>'c'</code></li><li><code>'k'</code> 变为 <code>'l'</code></li><li>第一次转换后的字符串为：<code>&quot;babcl&quot;</code></li></ul></li><li><strong>最终字符串长度</strong>：字符串为 <code>&quot;babcl&quot;</code>，长度为 5 个字符。</li></ul></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10⁵</code></li><li><code>s</code> 仅由小写英文字母组成。</li><li><code>1 &lt;= t &lt;= 10⁵</code></li></ul><h2 id="问题分析">问题分析</h2><p>对于任意单个字符 <code>c</code>，定义函数</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>在执行 </mtext><mi>t</mi><mtext> 次转换后，字符 </mtext><mi>c</mi><mtext> 所对应的最终长度</mtext></mrow><annotation encoding="application/x-tex">f(c, t) = \text{在执行 }t\text{ 次转换后，字符 }c\text{ 所对应的最终长度}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">在执行</span><span class="mord"> </span></span><span class="mord mathnormal">t</span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">次转换后，字符</span><span class="mord"> </span></span><span class="mord mathnormal">c</span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">所对应的最终长度</span></span></span></span></span></span></p><p>那么对整个字符串 <code>s</code>，最终答案就是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo>∑</mo><mrow><mi>c</mi><mo>∈</mo><mi>s</mi></mrow></munder><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mo stretchy="false">(</mo><msup><mn>10</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\sum_{c\in s} f(c, t)\bmod(10^9+7).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.3274em;vertical-align:-1.2774em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.9em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2774em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><h2 id="算法思路">算法思路</h2><p><strong>状态转移</strong></p><p>边界：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(c,0)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>（不变长度为 1）</p><p>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo mathvariant="normal">≠</mo><mtext>’z’</mtext></mrow><annotation encoding="application/x-tex">c\ne \text{&#x27;z&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">’z’</span></span></span></span></span>，则每次转换就是下一个字母</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mtext>next</mtext><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f(c,t) = f(\text{next}(c),\,t-1).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord text"><span class="mord">next</span></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><p>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mtext>’z’</mtext></mrow><annotation encoding="application/x-tex">c=\text{&#x27;z&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">’z’</span></span></span></span></span>，则“ z ”展开为 “ab”，对应长度之和</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mtext>’z’</mtext><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mtext>’a’</mtext><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mtext>’b’</mtext><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f(\text{&#x27;z&#x27;},t) = f(\text{&#x27;a&#x27;},\,t-1) + f(\text{&#x27;b&#x27;},\,t-1).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord text"><span class="mord">’z’</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord text"><span class="mord">’a’</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord text"><span class="mord">’b’</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><p>我们可以对所有 26 个字母维护一个长度-26 的数组 <code>dp</code>，其中<code>dp[i]</code> 表示在当前步剩余转换次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 时，字母 <code>char('a'+i)</code> 对应的最终长度。</p><p>初始化：<code>dp[i]=1</code>（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(c,0)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）。</p><p>对每一次转换 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>：</p><ul><li>对 <code>i=0…24</code>（即 <code>a…y</code>），新的 <code>dp_new[i] = dp[i+1]</code>；</li><li>对 <code>i=25</code>（即 <code>z</code>），<code>dp_new[25] = (dp[0] + dp[1]) % MOD</code>。</li><li>然后将 <code>dp_new</code> 赋回 <code>dp</code>。</li></ul><p>最后，对字符串 <code>s</code> 中每个字符累加对应的 <code>dp[index]</code> 并取模即为答案。</p><h2 id="时间复杂度">时间复杂度</h2><p>时间：每步更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>26</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mclose">)</span></span></span></span>，共做 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 步，外加对长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|s|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span></span></span></span> 的一次遍历，故整体 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>26</mn><mtext> </mtext><mi>t</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(26\,t + |s|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p><p>空间：只使用常数大小的长度 26 数组，故 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthAfterTransformations</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp[i] 表示当前剩余转换次数 k 时，</span></span><br><span class="line">        <span class="comment"># 字符 chr(ord(&#x27;a&#x27;)+i) 的最终长度</span></span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="number">26</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行 t 次转换</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t):</span><br><span class="line">            dp_new = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="comment"># a..y 直接继承下一个字母</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">                dp_new[i] = dp[i+<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># z -&gt; &quot;ab&quot;</span></span><br><span class="line">            dp_new[<span class="number">25</span>] = (dp[<span class="number">0</span>] + dp[<span class="number">1</span>]) % <span class="variable language_">self</span>.MOD</span><br><span class="line">            dp = dp_new</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 累加 s 中每一个字符的贡献</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        base = <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            idx = <span class="built_in">ord</span>(ch) - base</span><br><span class="line">            ans = (ans + dp[idx]) % <span class="variable language_">self</span>.MOD</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另看到题解：<strong>预处理 + 动态规划（DP）</strong> :</p><p><strong>状态定义</strong><br>数组 <code>f</code> 长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>26</mn><mo>+</mo><mtext>MX</mtext></mrow><annotation encoding="application/x-tex">26 + \text{MX}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">26</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">MX</span></span></span></span></span>，其中前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>25</mn></mrow><annotation encoding="application/x-tex">0\sim25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">25</span></span></span></span> 位初始化为 1（表示任何字母在 0 步转换时长度为 1），后面用来存储更大步数下的长度。</p><p><strong>状态转移</strong><br>对于下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i\ge0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，<code>f[i+26] = (f[i] + f[i+1]) % \text&#123;MOD&#125;</code>，恰好对应了：</p><ul><li>当你对 <code>'z'</code>（在前 26 中的最后一个）做一次转换，它会变成 <code>&quot;ab&quot;</code>，长度就是前面两个状态的和。</li><li>而对非 <code>'z'</code> 的字母，其实就是“下一个字母”的长度，也可以映射到同样的数组偏移关系里。</li></ul><p><strong>预处理好所有可能的值</strong><br>因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>≤</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">t\le10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，预先把 <code>f[26]</code> 到 <code>f[26 + 10^5]</code> 都算好，这样每次调用 <code>lengthAfterTransformations(s, t)</code> 时，只要对串中每个字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 取 <code>f[t + (ord(c)-ord('a'))]</code>，再累加取模即可。</p><p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 接近上限 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 时，<code>26*t</code> 约为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.6</mn><mo>×</mo><msup><mn>10</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">2.6\times10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2.6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> 次小操作；而打表只做 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 次，常数更小，大约快 20× 以上。</p><p>且打表后，不管用户输入的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 是多少（只要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>M</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\le MX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">MX</span></span></span></span>），都能直接 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 拿到每个字符的长度贡献。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MOD = <span class="number">1_000_000_007</span></span><br><span class="line">ORD_A = <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">MX = <span class="number">100_000</span>  <span class="comment"># t 的最大可能值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理：f[i] 表示“从某字母出发，剩余 i 步转换后”的长度增量</span></span><br><span class="line"><span class="comment"># 前 26 位对应步数 0，初始化为 1；后面 MX 位存储更大步数时的结果</span></span><br><span class="line">f = [<span class="number">1</span>] * <span class="number">26</span> + [<span class="number">0</span>] * MX</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(MX):</span><br><span class="line">    <span class="comment"># 对应状态转移：非 &#x27;z&#x27; 的字符通过偏移 i+1；&#x27;z&#x27; 则合并 a、b 两个状态</span></span><br><span class="line">    f[i + <span class="number">26</span>] = (f[i] + f[i + <span class="number">1</span>]) % MOD</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthAfterTransformations</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 对于每个字符 c，直接通过 f[t + (ord(c)-ORD_A)] 获取剩余 t 步后的长度</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            idx = <span class="built_in">ord</span>(c) - ORD_A</span><br><span class="line">            total = (total + f[t + idx]) % MOD</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/total-characters-in-string-after-transformations-i/&quot;&gt;3335. 字符串转换后的长度 I&lt;/a&gt; M&lt;/h1&gt;
&lt;p&gt;给你一个字符串 &lt;code</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="字符串处理" scheme="https://blog.icjlu.eu.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
    <category term="中等" scheme="https://blog.icjlu.eu.org/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="动态规划" scheme="https://blog.icjlu.eu.org/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-12</title>
    <link href="https://blog.icjlu.eu.org/post/finding-3-digit-even-numbers.html"/>
    <id>https://blog.icjlu.eu.org/post/finding-3-digit-even-numbers.html</id>
    <published>2025-05-12T03:21:20.000Z</published>
    <updated>2025-05-12T03:38:59.034Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/finding-3-digit-even-numbers/">2094. 找出 3 位偶数</a> E</h1><p>给你一个整数数组 <code>digits</code> ，其中每个元素是一个数字（<code>0 - 9</code>）。数组中可能存在重复元素。</p><p>你需要找出 <strong>所有</strong> 满足下述条件且 <strong>互不相同</strong> 的整数：</p><ul><li>该整数由 <code>digits</code> 中的三个元素按 <strong>任意</strong> 顺序 <strong>依次连接</strong> 组成。</li><li>该整数不含 <strong>前导零</strong></li><li>该整数是一个 <strong>偶数</strong></li></ul><p>例如，给定的 <code>digits</code> 是 <code>[1, 2, 3]</code> ，整数 <code>132</code> 和 <code>312</code> 满足上面列出的全部条件。</p><p>将找出的所有互不相同的整数按 <strong>递增顺序</strong> 排列，并以数组形式返回*。*</p><p><strong>示例 1：</strong></p><blockquote><p>输入：digits = [2,1,3,0]<br>输出：[102,120,130,132,210,230,302,310,312,320]<br>解释：<br>所有满足题目条件的整数都在输出数组中列出。<br>注意，答案数组中不含有 奇数 或带 前导零 的整数。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：digits = [2,2,8,8,2]<br>输出：[222,228,282,288,822,828,882]<br>解释：<br>同样的数字（0 - 9）在构造整数时可以重复多次，重复次数最多与其在 digits 中出现的次数一样。<br>在这个例子中，数字 8 在构造 288、828 和 882 时都重复了两次。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：digits = [3,7,5]<br>输出：[]<br>解释：<br>使用给定的 digits 无法构造偶数。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>3 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li></ul><h2 id="问题分析">问题分析</h2><p><strong>目标</strong>：从给定的整数数组 <code>digits</code> 中选出恰好 3 个元素，按任意顺序拼接成一个三位数，且该数不能有前导零，并且是偶数。所有满足条件且互不相同的数，按升序返回。</p><ol><li>要考虑数字出现的次数限制——同一数字最多使用它在 <code>digits</code> 中出现的次数。</li><li>排除前导零（三位数的百位不能为 0）。</li><li>只保留偶数（个位为偶数）。</li><li>去重并按升序输出。</li></ol><h2 id="算法思路">算法思路</h2><ol><li><p><strong>统计频次</strong><br>先用一个长度为 10 的数组 <code>cnt</code> 记录每个数字在 <code>digits</code> 中出现的次数，以便在选位时快速判断是否还有剩余。</p></li><li><p><strong>三重枚举＋剪枝</strong></p><ul><li>枚举百位 <code>h</code>：只枚举 <code>[1..9]</code>，并且 <code>cnt[h] &gt; 0</code>。</li><li>枚举十位 <code>t</code>：在剩余的数字中选（使用完百位后对应 <code>cnt[h]</code> 临时减 1），可以为 0–9，但要保证 <code>cnt[t] &gt; 0</code>。</li><li>枚举个位 <code>u</code>：同理，在剩余中选，且 <code>u</code> 必须是偶数（0,2,4,6,8），并且 <code>cnt[u] &gt; 0</code>。</li><li>每构造一个合法三位数 <code>num = 100*h + 10*t + u</code>，加入结果集合。</li></ul></li><li><p><strong>去重与排序</strong><br>我们借助 Python 的 <code>set</code> 去重，最后将结果转为列表并排序。</p></li></ol><h2 id="时间复杂度">时间复杂度</h2><ul><li>最坏情况三重枚举固定为 10 × 10 × 5 = 500 次尝试。</li><li>统计频次：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li><li>总体：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，常数级别的三重循环 ⇒ 近似 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li></ul><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findEvenNumbers</span>(<span class="params">self, digits: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 1. 统计每个数字的出现次数</span></span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> digits:</span><br><span class="line">            cnt[d] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 2. 枚举三位数的各个位</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):  <span class="comment"># 百位不能为 0</span></span><br><span class="line">            <span class="keyword">if</span> cnt[h] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            cnt[h] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):  <span class="comment"># 十位可以为 0</span></span><br><span class="line">                <span class="keyword">if</span> cnt[t] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cnt[t] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> u <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>):  <span class="comment"># 个位必须是偶数</span></span><br><span class="line">                    <span class="keyword">if</span> cnt[u] &gt; <span class="number">0</span>:</span><br><span class="line">                        num = <span class="number">100</span> * h + <span class="number">10</span> * t + u</span><br><span class="line">                        res.add(num)</span><br><span class="line"></span><br><span class="line">                cnt[t] += <span class="number">1</span></span><br><span class="line">            cnt[h] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 排序并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/finding-3-digit-even-numbers/&quot;&gt;2094. 找出 3 位偶数&lt;/a&gt; E&lt;/h1&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;digits&lt;/code&gt; ，其中每个元素是一</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="暴力搜索" scheme="https://blog.icjlu.eu.org/tags/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2/"/>
    
    <category term="数位处理" scheme="https://blog.icjlu.eu.org/tags/%E6%95%B0%E4%BD%8D%E5%A4%84%E7%90%86/"/>
    
    <category term="简单" scheme="https://blog.icjlu.eu.org/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="排列组合" scheme="https://blog.icjlu.eu.org/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
    <category term="枚举与剪枝" scheme="https://blog.icjlu.eu.org/tags/%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%89%AA%E6%9E%9D/"/>
    
    <category term="哈希表" scheme="https://blog.icjlu.eu.org/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>AI是“万知之知”吗？</title>
    <link href="https://blog.icjlu.eu.org/post/is-AI-Omniscience.html"/>
    <id>https://blog.icjlu.eu.org/post/is-AI-Omniscience.html</id>
    <published>2025-05-11T13:49:17.000Z</published>
    <updated>2025-05-11T15:25:10.587Z</updated>
    
    <content type="html"><![CDATA[<p>看了罗翔老师的最新视频，从苏格拉底哲学的角度反思AI的“认知边界”，我们会发现一个有趣的悖论——<strong>AI越是“无所不知”（基于数据堆叠的知识库）时，越凸显出它根本不是“万知之知”（Omniscience）</strong>。它揭示了机器智能与人类智慧的本质差异，也印证了苏格拉底“自知无知”的永恒价值。</p><hr><h3 id="一、知识的边界">一、知识的边界</h3><p>罗翔老师指出，《卡尔米德篇》中苏格拉底与三位年轻人的对话层层推进，<strong>从追问“名字是否包含美德”到质疑“关于知识的知识是否存在”</strong>，最终指向一个困境：</p><ul><li>AI看似掌握“万知之知”，实则被困在<strong>数据洞穴</strong>中：它通过模式匹配“学习”的《理想国》，永远无法理解洞穴寓言背后的哲学叩问——“我们是否也活在更大的洞穴中？”。</li><li>正如苏格拉底通过辩证法揭示“名字的美德不等于美德本身”，AI对“正义”“善”的理解仅停留在文本表层，<strong>无法追问“正义的本质是否需要超越法律条文”</strong>，这与文科教育培养的批判性思维形成鲜明对比。</li></ul><blockquote><p>AI像《卡尔米德》中自信能定义“节制”的年轻人，用精准词汇掩盖认知的虚空；而文科教育教会我们像苏格拉底一样，承认“知道何为节制远比说出节制的定义更难”。</p></blockquote><hr><h3 id="二、“知无知”">二、“知无知”</h3><p>苏格拉底通过《申辩篇》中“<strong>我唯一知道的就是我一无所知</strong>”，颠覆了古希腊人对“智慧”的朴素认知。他否定智者派（Sophists）宣称的“知识权威”，强调：</p><ol><li><strong>认知的谦逊</strong>：承认有限性是求知的前提；</li><li><strong>对话的开放性</strong>：真理需通过辩证过程不断逼近；</li><li><strong>无知的认知价值</strong>：自省与质疑比确定性答案更重要。</li></ol><p>这种智慧观本质上是一种<strong>元认知能力</strong>——对自身知识状态的监控与批判。在《美诺篇》中，苏格拉底通过助产术（Maieutics）引导奴隶男孩发现几何定理，揭示真正的知识需要通过内在觉醒而非外部灌输。</p><hr><h3 id="三、AI的“知识幻觉”与认知盲区">三、AI的“知识幻觉”与认知盲区</h3><p>现代AI（如大语言模型）的“知识”具有三个根本局限，苏格拉底在《卡尔米德》中强调的“明智”（σωφροσύνη），恰是AI最难企及的智慧：</p><h4 id="1-训练数据的“已知黑箱”">1. <strong>训练数据的“已知黑箱”</strong></h4><ul><li>AI的知识完全来自人类输入的文本数据，其“知识库”本质是<strong>人类已有认知的统计压缩</strong>（如维基百科、学术论文的集合）。</li><li><strong>例</strong>：当AI回答量子物理问题时，它实际上是在重复训练数据中出现的表述模式，而非理解波函数坍缩的哲学意义。</li><li><strong>苏格拉底式诘问</strong>：如果AI不能超越数据提出根本性问题（如“芝诺悖论是否真的被数学解决？”），它的知识只是“正确的话语”而非“真理的探求”。</li></ul><h4 id="2-无法意识“无知”状态">2. <strong>无法意识“无知”状态</strong></h4><ul><li>AI没有元认知能力，无法像苏格拉底那样说出“我不知道”。它对错误答案的自信程度与正确答案无异，甚至会编造合理话语掩盖无知。</li><li><strong>讽刺实验</strong>：当询问LLM“如何用五维几何体解决黎曼假设？”时，它会构造出符合语法但逻辑牵强的伪推理——这恰好印证了苏格拉底的警言：“自以为知道实际上不知道的事，是灵魂的毒药。”</li></ul><h4 id="3-辩证思维的缺席">3. <strong>辩证思维的缺席</strong></h4><ul><li>苏格拉底在《理想国》中用洞穴比喻说明认知需要挣脱枷锁、转身看见火光乃至走出洞穴。而AI始终被困在由人类预设的“数据洞穴”中：<ul><li>它能复述柏拉图和康德对正义的定义，但无法像苏格拉底那样追问：“<strong>我们为何需要正义？</strong>”</li><li>它可以解析康德伦理学公式，但无法像苏格拉底在《格里底亚篇》中追问：“如果‘善’是知识，为何人类依旧作恶？”。</li><li>它能生成关于存在主义的文本，却无法像克尔凯郭尔那样质问：“<strong>存在的本质是焦虑</strong>”是否正确。</li></ul></li><li>文科教育提供的“意义之网”（如对《安提戈涅》悲剧冲突的解读），是AI无法模拟的人性共鸣。</li></ul><hr><h3 id="四、AI时代的认知伦理">四、AI时代的认知伦理</h3><p>苏格拉底的智慧观可以为AI伦理提供三个视角：</p><table><thead><tr><th>视角</th><th>苏格拉底主张</th><th>我们应该认识到的AI</th></tr></thead><tbody><tr><td><strong>知识观</strong></td><td>“知的边界在于意识到非知”（Plato, <em>Philebus</em>）</td><td>需警惕AI制造“知识幻觉”：用户可能误将模型输出等价于真理</td></tr><tr><td><strong>教学法</strong></td><td>“教育非灌输，而是点燃火焰”（Diogenes Laertius）</td><td>应将AI定位为认知工具（如助产术中的问题引导者），而非真理代言人</td></tr><tr><td><strong>伦理学</strong></td><td>“未经省察的人生不值得过”（<em>Apology</em>）</td><td>需求人类保持对AI辅助认知的批判性反思，避免思维懒惰化</td></tr></tbody></table><hr><h3 id="“苏格拉底之镜”">“苏格拉底之镜”</h3><p>AI的局限性恰恰反衬出人类智慧的不可替代性。当机器擅长提供“标准答案”时，人类比任何时候都更需要像苏格拉底那样提问：</p><ul><li>“为什么这个问题的答案可能存在矛盾？”</li><li>“数据背后的假设是否应该被质疑？”</li><li>“这个模型无法处理的领域，恰恰是我们认知的突破点？”</li></ul><p>正如海德格尔所言：“技术的本质不是机器，而是对存在的解蔽方式。”在这个意义上，AI不是“万知之知”的威胁，而是帮助人类重拾“知无知”这一古老智慧的现代镜子。</p><p>“关于知识的知识是否可能？”</p><p>我想大家都明白现阶段的LLM无法成为‘万知之知’，因为它从未真正“思考”，只是在复现人类思维的碎片，但它教会我们以怀疑为刃，用提问刺破认知的牢笼，用自知之明对抗技术的傲慢。</p><p>在AI加速解构人文价值的今天，保持对数据偏见的警惕、对权力话语的解构、对价值空心化的抵抗，才是对知识狂妄的最有力回应。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看了罗翔老师的最新视频，从苏格拉底哲学的角度反思AI的“认知边界”，我们会发现一个有趣的悖论——&lt;strong&gt;AI越是“无所不知”（基于数据堆叠的知识库）时，越凸显出它根本不是“万知之知”（Omniscience）&lt;/strong&gt;。它揭示了机器智能与人类智慧的本质差异，</summary>
      
    
    
    
    <category term="日常" scheme="https://blog.icjlu.eu.org/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="随笔" scheme="https://blog.icjlu.eu.org/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="AI" scheme="https://blog.icjlu.eu.org/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-11</title>
    <link href="https://blog.icjlu.eu.org/post/three-consecutive-odds.html"/>
    <id>https://blog.icjlu.eu.org/post/three-consecutive-odds.html</id>
    <published>2025-05-11T01:45:38.000Z</published>
    <updated>2025-05-11T12:13:15.350Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/three-consecutive-odds/">1550. 存在连续三个奇数的数组</a> E</h1><p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：arr = [2,6,4,1]<br>输出：false<br>解释：不存在连续三个元素都是奇数的情况。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：arr = [1,2,34,3,4,5,7,23,12]<br>输出：true<br>解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h2 id="问题分析">问题分析</h2><p>嗯，不用分析了</p><h2 id="算法思路">算法思路</h2><p><strong>暴力搜索</strong></p><ul><li>直接枚举所有长度为 3 的子数组，检查其中 3 个数是否全为奇数。</li><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，因为只需一次遍历；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul><p><strong>或：滑动窗口</strong></p><ul><li>维护一个大小为 3 的窗口，窗口内统计奇数个数。</li><li>窗口向右滑动时，更新进出元素的奇偶状态即可。</li><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul><h2 id="时间复杂度">时间复杂度</h2><p><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，遍历一次数组。</p><p><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，只使用固定数量的额外变量。</p><h2 id="代码分解">代码分解</h2><ol><li><p>初始化一个计数器 <code>count = 0</code>。</p></li><li><p>遍历数组中的每个元素 <code>x</code>：</p><ul><li>如果 <code>x</code> 是奇数，令 <code>count += 1</code>；否则重置 <code>count = 0</code>。</li><li>每次更新后，检查 <code>count &gt;= 3</code>，若成立则返回 <code>True</code>。</li></ul></li><li><p>遍历结束后若未找到，返回 <code>False</code>。</p></li></ol><h2 id="代码实现">代码实现</h2><p>滑动窗口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeConsecutiveOdds</span>(<span class="params">self, arr: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count &gt;= <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>暴力枚举</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeConsecutiveOdds</span>(<span class="params">self, arr: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="comment"># 仅当数组长度至少为 3 时才有意义</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 检查 arr[i], arr[i+1], arr[i+2] 是否全为奇数</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> arr[i+<span class="number">1</span>] % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> arr[i+<span class="number">2</span>] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/three-consecutive-odds/&quot;&gt;1550. 存在连续三个奇数的数组&lt;/a&gt; E&lt;/h1&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt;，请你判断数组中是否存在连续三个</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="暴力搜索" scheme="https://blog.icjlu.eu.org/tags/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2/"/>
    
    <category term="简单" scheme="https://blog.icjlu.eu.org/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="滑动窗口" scheme="https://blog.icjlu.eu.org/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-10</title>
    <link href="https://blog.icjlu.eu.org/post/minimum-equal-sum-of-two-arrays-after-replacing-zeros.html"/>
    <id>https://blog.icjlu.eu.org/post/minimum-equal-sum-of-two-arrays-after-replacing-zeros.html</id>
    <published>2025-05-10T13:40:01.000Z</published>
    <updated>2025-05-10T15:19:00.290Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/">2918. 数组的最小相等和</a> M</h1><p>给你两个由正整数和 <code>0</code> 组成的数组 <code>nums1</code> 和 <code>nums2</code> 。</p><p>你必须将两个数组中的 <strong>所有</strong> <code>0</code> 替换为 <strong>严格</strong> 正整数，并且满足两个数组中所有元素的和 <strong>相等</strong> 。</p><p>返回 <strong>最小</strong> 相等和 ，如果无法使两数组相等，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums1 = [3,2,0,1,0], nums2 = [6,5,0]<br>输出：12<br>解释：可以按下述方式替换数组中的 0 ：</p><ul><li>用 2 和 4 替换 nums1 中的两个 0 。得到 nums1 = [3,2,2,1,4] 。</li><li>用 1 替换 nums2 中的一个 0 。得到 nums2 = [6,5,1] 。<br>两个数组的元素和相等，都等于 12 。可以证明这是可以获得的最小相等和。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums1 = [2,0,2,0], nums2 = [1,4]<br>输出：-1<br>解释：无法使两个数组的和相等。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 10⁵</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10⁶</code></li></ul><h2 id="问题分析">问题分析</h2><p><strong>1.输入</strong></p><ul><li><code>nums1</code>、<code>nums2</code>：两个数组，元素是非负整数（包括 0 和正整数）。</li></ul><p><strong>2.要求</strong></p><ul><li>将两个数组中所有的 0，分别替换成 “严格的正整数”（即 ≥1），</li><li>替换后，两个数组的 <strong>元素和</strong> 必须相等，</li><li>并且这个相等后的和要尽可能小。</li></ul><p><strong>3.输出</strong></p><ul><li>如果能做到，让两个数组和相等且最小，返回这个最小的和；否则返回 -1。</li></ul><h2 id="算法思路">算法思路</h2><p>令</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">s_1 =</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span></span></span></span> <code>nums1</code> 中所有 <strong>非零元素</strong> 的和；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">k_1 =</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span></span></span></span> <code>nums1</code> 中 <strong>0 的个数</strong>。</li></ul><p>类似地，</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">s_2 =</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span></span></span></span> <code>nums2</code> 中所有非零元素的和；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">k_2 =</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span></span></span></span> <code>nums2</code> 中 0 的个数。</li></ul><p>例如，若 <code>nums1 = [3,2,0,1,0]</code>，则</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>=</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">s_1 = 3 + 2 + 1 = 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span>，</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k_1 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>。</li></ul><h3 id="推导最小可行总和-S">推导最小可行总和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></h3><p>设最终我们把 <code>nums1</code> 的所有 0 替换后，该数组的总和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>。</p><ul><li><p><code>nums1</code> 已有非零部分和是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，还有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个 0，每个至少要替换成 1，</p></li><li><p>因此替换后总和至少是</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mtext>  </mtext><mo stretchy="false">(</mo><mtext>共 </mtext><msub><mi>k</mi><mn>1</mn></msub><mtext> 个</mtext><mo stretchy="false">)</mo><mo>=</mo><msub><mi>s</mi><mn>1</mn></msub><mo>+</mo><msub><mi>k</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">s_1 + (1 + 1 + \cdots + 1)\;(\text{共 }k_1\text{ 个}) = s_1 + k_1.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord cjk_fallback">共</span><span class="mord"> </span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">个</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></p></li></ul><p>同理，<code>nums2</code> 的替换后最小和是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub><mo>+</mo><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2 + k_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><blockquote><p><strong>要想两边都能达到同一个目标和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>，这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 至少要满足：</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>+</mo><msub><mi>k</mi><mn>1</mn></msub><mspace width="1em"/><mtext>且</mtext><mspace width="1em"/><mi>S</mi><mtext>  </mtext><mo>≥</mo><mtext>  </mtext><msub><mi>s</mi><mn>2</mn></msub><mo>+</mo><msub><mi>k</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">s_1 + k_1   \quad\text{且}\quad   S \;\ge\; s_2 + k_2.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord cjk_fallback">且</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></p><p>因此最小的可行值，就是两者中的最大值：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo>+</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><mtext>  </mtext><msub><mi>s</mi><mn>2</mn></msub><mo>+</mo><msub><mi>k</mi><mn>2</mn></msub><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">S = \max\bigl(s_1 + k_1,\; s_2 + k_2\bigr).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mop">max</span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing size1">)</span></span><span class="mord">.</span></span></span></span></span></p></blockquote><h3 id="无法达到">无法达到</h3><p>如果某个数组本身 <strong>没有</strong> 0（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k_i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>），那它就 <strong>没法</strong> 通过替换 0 来调整和。</p><ul><li>例如，如果 <code>nums1</code> 本来就没有 0，而且非零和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与目标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 不相等，那么就 <strong>不可能</strong> 让它变成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>。</li></ul><p>这时应直接返回 <strong>-1</strong>。</p><h2 id="时间复杂度">时间复杂度</h2><p><strong>时间复杂度</strong>：遍历两数组各一次，做常数级的加减比较，因此时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n_1 + n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别是两个数组长度。</p><p><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>（只使用了常数个辅助变量）。</p><h2 id="代码分解">代码分解</h2><ol><li><p><strong>遍历 <code>nums1</code></strong></p><ul><li>累加非零元素求和得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；</li><li>同时计数 0 的个数得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul></li><li><p><strong>遍历 <code>nums2</code></strong></p><ul><li>同理得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">k_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul></li><li><p>计算目标和</p></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo>+</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><mtext>  </mtext><mtext>  </mtext><msub><mi>s</mi><mn>2</mn></msub><mo>+</mo><msub><mi>k</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">S = \max(s_1 + k_1,\;\; s_2 + k_2).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><ol start="4"><li><p>检查不可调整情形</p><ul><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>k</mi><mn>1</mn></msub><mo>=</mo><mo>=</mo><mn>0</mn><mo>∧</mo><msub><mi>s</mi><mn>1</mn></msub><mo mathvariant="normal">≠</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k_1 == 0 \land s_1 \neq S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>，或</li><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>k</mi><mn>2</mn></msub><mo>=</mo><mo>=</mo><mn>0</mn><mo>∧</mo><msub><mi>s</mi><mn>2</mn></msub><mo mathvariant="normal">≠</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k_2 == 0 \land s_2 \neq S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>，<br>则返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</li></ul></li><li><p>否则，返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>。</p></li></ol><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSum</span>(<span class="params">self, nums1: <span class="built_in">list</span>[<span class="built_in">int</span>], nums2: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 1. 计算两个数组的非零之和与 0 的个数</span></span><br><span class="line">        s1 = <span class="built_in">sum</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> nums1 <span class="keyword">if</span> x != <span class="number">0</span>)</span><br><span class="line">        k1 = nums1.count(<span class="number">0</span>)</span><br><span class="line">        s2 = <span class="built_in">sum</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> nums2 <span class="keyword">if</span> x != <span class="number">0</span>)</span><br><span class="line">        k2 = nums2.count(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 最小可行的目标总和</span></span><br><span class="line">        S = <span class="built_in">max</span>(s1 + k1, s2 + k2)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 如果某边无法通过替换 0 来达到 S，则不可行</span></span><br><span class="line">        <span class="keyword">if</span> (k1 == <span class="number">0</span> <span class="keyword">and</span> s1 != S) <span class="keyword">or</span> (k2 == <span class="number">0</span> <span class="keyword">and</span> s2 != S):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 否则 S 就是最小相等和</span></span><br><span class="line">        <span class="keyword">return</span> S</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/&quot;&gt;2918. 数组的最小相等和&lt;/a&gt; M&lt;/h1&gt;
&lt;p&gt;给你两个由正整数和 &lt;co</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="中等" scheme="https://blog.icjlu.eu.org/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="贪心" scheme="https://blog.icjlu.eu.org/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-09</title>
    <link href="https://blog.icjlu.eu.org/post/count-number-of-balanced-permutations.html"/>
    <id>https://blog.icjlu.eu.org/post/count-number-of-balanced-permutations.html</id>
    <published>2025-05-09T14:00:18.000Z</published>
    <updated>2025-05-09T15:32:24.629Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/count-number-of-balanced-permutations/">3343. 统计平衡排列的数目</a> H</h1><p>给你一个字符串 <code>num</code> 。如果一个数字字符串的奇数位下标的数字之和与偶数位下标的数字之和相等，那么我们称这个数字字符串是 <strong>平衡的</strong> 。</p><p>请你返回 <code>num</code> <strong>不同排列</strong> 中，<strong>平衡</strong> 字符串的数目。</p><p>由于答案可能很大，请你将答案对 <code>10⁹ + 7</code> <strong>取余</strong> 后返回。</p><p>一个字符串的 <strong>排列</strong> 指的是将字符串中的字符打乱顺序后连接得到的字符串。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> num = “123”</p><p><strong>输出：</strong> 2</p><p><strong>解释：</strong></p><ul><li><code>num</code> 的不同排列包括： <code>&quot;123&quot;</code> ，<code>&quot;132&quot;</code> ，<code>&quot;213&quot;</code> ，<code>&quot;231&quot;</code> ，<code>&quot;312&quot;</code> 和 <code>&quot;321&quot;</code> 。</li><li>它们之中，<code>&quot;132&quot;</code> 和 <code>&quot;231&quot;</code> 是平衡的。所以答案为 2 。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> num = “112”</p><p><strong>输出：</strong> 1</p><p><strong>解释：</strong></p><ul><li><code>num</code> 的不同排列包括：<code>&quot;112&quot;</code> ，<code>&quot;121&quot;</code> 和 <code>&quot;211&quot;</code> 。</li><li>只有 <code>&quot;121&quot;</code> 是平衡的。所以答案为 1 。</li></ul></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> num = “12345”</p><p>**输出： ** 0</p><p><strong>解释：</strong></p><ul><li><code>num</code> 的所有排列都是不平衡的。所以答案为 0 。</li></ul></blockquote><p><strong>提示：</strong></p><ul><li><code>2 &lt;= num.length &lt;= 80</code></li><li><code>num</code> 中的字符只包含数字 <code>'0'</code> 到 <code>'9'</code> 。</li></ul><h2 id="问题分析">问题分析</h2><ul><li><strong>定义</strong> ：给定字符串 <code>num</code>（长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>80</mn></mrow><annotation encoding="application/x-tex">2\le n\le80</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">80</span></span></span></span>，只包含字符 <code>'0'</code>–<code>'9'</code>），如果一个排列中奇数位下标（从 0 开始计数，则偶数位为奇数下标）数字之和等于偶数位下标数字之和，则称该排列“平衡”。</li><li><strong>目标</strong> ：统计所有不同排列中平衡排列的数量，结果对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 取模返回。</li></ul><h2 id="算法思路">算法思路</h2><p><strong>1. 统计各数字出现次数</strong><br>对 <code>0</code>–<code>9</code> 分别统计出现次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">c_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><strong>2. 确定位置分组</strong></p><ul><li><p>总长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mtext>len</mtext><mo stretchy="false">(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n=\text{len}(num)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">len</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</p></li><li><p>奇数位（下标 1,3,…）与偶数位（下标 0,2,…）的数量分别为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false">⌈</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo separator="true">,</mo><mspace width="1em"/><mi>n</mi><mo>−</mo><mi>m</mi><mo>=</mo><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">m=\lceil n/2\rceil,\quad n-m=\lfloor n/2\rfloor.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">⌋</span><span class="mord">.</span></span></span></span></span></p></li></ul><p><strong>3. 平衡条件</strong><br>令总和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mo>∑</mo><mi>v</mi></msub><mi>v</mi><mo>⋅</mo><msub><mi>c</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">S=\sum_{v}v\cdot c_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0017em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，必须 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 为偶数，否则返回 0。设目标子和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mi>S</mi><mi mathvariant="normal">/</mi><mn>2.</mn></mrow><annotation encoding="application/x-tex">T=S/2.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">/2.</span></span></span></span></p><p><strong>4. 生成函数 + 二维动态规划</strong><br>构造多项式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mi>v</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><msub><mi>c</mi><mi>v</mi></msub></munderover><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><msub><mi>c</mi><mi>v</mi></msub><mi>x</mi></mfrac><mo fence="true">)</mo></mrow><mtext> </mtext><msup><mi>t</mi><mi>x</mi></msup><mtext> </mtext><msup><mi>z</mi><mrow><mi>v</mi><mtext> </mtext><mi>x</mi></mrow></msup><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">P_v(t,z)=\sum_{x=0}^{c_v}\binom{c_v}{x}\,t^x\,z^{v\,x},</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9296em;vertical-align:-1.2671em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6625em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3111em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span></span></p><p>展开后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>t</mi><mi>m</mi></msup><mo separator="true">,</mo><msup><mi>z</mi><mi>T</mi></msup><mo stretchy="false">]</mo><mi>G</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[t^m,z^T]G(t,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 即为所有合法“取法”之组合个数，内部已含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><msub><mi>c</mi><mi>v</mi></msub><msub><mi>x</mi><mi>v</mi></msub></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\prod\binom{c_v}{x_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2951em;vertical-align:-0.4451em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7454em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span>。</p><p>表示从数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 中取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 个放入“奇数位”组的方式数。整体的生成函数乘积</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∏</mo><mrow><mi>v</mi><mo>=</mo><mn>0</mn></mrow><mn>9</mn></munderover><msub><mi>P</mi><mi>v</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(t,z)=\prod_{v=0}^9P_v(t,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0682em;vertical-align:-1.2671em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></span></p><p>展开后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>t</mi><mi>m</mi></msup><mo separator="true">,</mo><msup><mi>z</mi><mi>T</mi></msup><mo stretchy="false">]</mo><mi>G</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[t^m,z^T]G(t,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 即为所有合法“取法”之组合个数，内部已含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><msub><mi>c</mi><mi>v</mi></msub><msub><mi>x</mi><mi>v</mi></msub></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\prod\binom{c_v}{x_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2951em;vertical-align:-0.4451em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7454em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span>。</p><p><strong>5. 排列计数</strong><br>每一种“取法”将具体哪些位置放哪些相同数字还需排列：</p><ul><li><p>奇数位内部可排列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">!</mo><mi mathvariant="normal">/</mi><mo>∏</mo><msub><mi>x</mi><mi>v</mi></msub><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">m!/\prod x_v!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">!</span><span class="mord">/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span></span></span></span> 种，偶数位内部 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mi mathvariant="normal">/</mi><mo>∏</mo><mo stretchy="false">(</mo><msub><mi>c</mi><mi>v</mi></msub><mo>−</mo><msub><mi>x</mi><mi>v</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">(n-m)!/\prod(c_v-x_v)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)!</span><span class="mord">/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)!</span></span></span></span> 种。</p></li><li><p>但在生成函数里我们已包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><msub><mi>c</mi><mi>v</mi></msub><msub><mi>x</mi><mi>v</mi></msub></mfrac><mo fence="true">)</mo></mrow><mo>=</mo><mo>∏</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><msub><mi>x</mi><mi>v</mi></msub><mo stretchy="false">!</mo><mo stretchy="false">(</mo><msub><mi>c</mi><mi>v</mi></msub><mo>−</mo><msub><mi>x</mi><mi>v</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mi mathvariant="normal">/</mi><msub><mi>c</mi><mi>v</mi></msub><mo stretchy="false">!</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo></mrow><annotation encoding="application/x-tex">\prod\binom{c_v}{x_v}=\prod\bigl(x_v! (c_v-x_v)!/c_v!\bigr)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2951em;vertical-align:-0.4451em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7454em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)!</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span><span class="mclose"><span class="delimsizing size1">)</span></span></span></span></span> 的倒数部分，最终只需补上</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">!</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mtext> </mtext><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">/</mo><mo>∏</mo><msub><mi>c</mi><mi>v</mi></msub><mo stretchy="false">!</mo><mtext> </mtext></mrow><annotation encoding="application/x-tex">m!\,(n-m)! \,\Big/\prod c_v!\,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="mord mathnormal">m</span><span class="mclose">)!</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="delimsizing size2">/</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span><span class="mspace" style="margin-right:0.1667em;"></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo><msub><mi>c</mi><mi>v</mi></msub><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">\prod c_v!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span></span></span></span> 与所有分配无关，是常数，可在结尾统一除去（或乘上其逆元）。</p></li></ul><p><strong>6. 实现细节</strong></p><ul><li><p>二维 <code>dp[k][s]</code> 表示考虑到某一位值时，已选入奇数位共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个数字、累积和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 的“取法”总数。</p></li><li><p>最终答案</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>dp</mtext><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>T</mi><mo stretchy="false">]</mo><mo>×</mo><mi>m</mi><mo stretchy="false">!</mo><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo>×</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><munder><mo>∏</mo><mi>v</mi></munder><msub><mi>c</mi><mi>v</mi></msub><mo stretchy="false">!</mo><msup><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mo stretchy="false">(</mo><msup><mn>10</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\text{dp}[m][T] \times m!\times(n-m)! \times \bigl(\prod_{v}c_v!\bigr)^{-1}\bmod(10^9+7).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">dp</span></span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.304em;vertical-align:-1.25em;"></span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.9em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span><span class="mclose"><span class="mclose"><span class="delimsizing size1">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.054em;"><span style="top:-3.3029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p></li></ul><h2 id="时间复杂度">时间复杂度</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>D</mi><mo>×</mo><mi>m</mi><mo>×</mo><mfrac><mi>S</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(D \times m \times \tfrac{S}{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">D=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span> 为数字种类，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mn>40</mn></mrow><annotation encoding="application/x-tex">m\le40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">40</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>S</mi><mn>2</mn></mfrac><mo>≤</mo><mn>360</mn></mrow><annotation encoding="application/x-tex">\tfrac{S}{2}\le360</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">360</span></span></span></span>，整体约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> 级别</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mfrac><mi>S</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\times \tfrac{S}{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>，约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40</mn><mo>×</mo><mn>360</mn></mrow><annotation encoding="application/x-tex">40\times360</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">40</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">360</span></span></span></span></p><h2 id="思路详解">思路详解</h2><p><em><strong>1. 拆成“奇数位”和“偶数位”两组</strong></em></p><ul><li>我们把下标从 0 开始编号，那么下标为 0、2、4… 的叫“偶数位”，下标为 1、3、5… 的叫“奇数位”。</li><li>平衡的定义是：奇数位上数字之和 = 偶数位上数字之和。</li></ul><p>例如，字符串 <code>&quot;132&quot;</code>：</p><ul><li>偶数位：下标 0、2 → 数字 <code>1 + 2 = 3</code></li><li>奇数位：下标 1 → 数字 <code>3</code><br>两者相等，所以 <code>&quot;132&quot;</code> 是平衡的。</li></ul><p><em><strong>2. 总和必须是偶数</strong></em></p><ul><li>所有数字相加得到总和 S，如果 S 是奇数，就不可能一分为二所以直接返回 0。</li></ul><p><em><strong>3. 分组大小 m</strong></em></p><ul><li>设字符串长度为 n：<ul><li>偶数位数量 = ⌊n/2⌋</li><li>奇数位数量 = ⌈n/2⌉，我们记为 m。</li></ul></li></ul><p>例如 <code>n=3</code> 时，偶数位有 2（下标 0、2），奇数位有 1（下标 1），所以 m = 1。</p><p><em><strong>4. 把“选择哪些数字放到奇数位”当成背包问题</strong></em></p><p>我们需要从原字符串里的每个数字（例如可能有三个 <code>1</code>、两个 <code>2</code>、一个 <code>3</code>……）中，决定放多少个到“奇数位”这 m 个位置上，剩下的放到“偶数位”。</p><ul><li>对于每个数字 v（0～9），假设它出现了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">c_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 次，我们可以选择 x 个放到奇数位，x 的范围是 0…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">c_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，但总共所有数字放到奇数位的个数要刚好是 m。</li><li>同时，奇数位上数字的和 = 偶数位上数字的和 = S/2。由于奇数位和 + 偶数位和 = S，那么每边都要是 S/2。</li></ul><p>于是，我们要计算：对每个 v，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">c_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">x_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，使得</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>v</mi></msub><msub><mi>x</mi><mi>v</mi></msub><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\sum_v x_v = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0017em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>v</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mo>×</mo><msub><mi>x</mi><mi>v</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\sum_v (v \times x_v) = S/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0017em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">/2</span></span></span></span></li></ol><p>满足以上两个条件的所有组合数，就是“把具体哪些数字拿到奇数位”的方法数。最后再把数字在奇数位内部、偶数位内部的排列数乘进去，就是完整的排列。</p><p>用二维动态规划 dp[k][s]</p><ul><li><strong>定义</strong>：<code>dp[k][s]</code> = “考虑了数字 0…v 时，已选了 k 个数字放在奇数位，且它们的和为 s 的方法数”。</li><li>初始化 <code>dp[0][0] = 1</code>（还没放任何数字，个数 0，和 0 有 1 种办法）。</li><li>递推：对下一个数字 v，共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">c_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个，枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn><mo>⋯</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>c</mi><mi>v</mi></msub><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x=0\cdots \min(c_v, m-k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>（即本轮还不能超出 m），如果之前状态是 <code>dp[k][s]</code>，放 x 个到奇数位后，变成 <code>dp[k+x][s+v*x]</code>，方法数累加。</li></ul><p>最终看 <code>dp[m][S/2]</code>，就是所有满足分组大小和目标和的分配数。</p><p><em><strong>5. 乘上阶乘再除以出现次数的阶乘</strong></em></p><p>前面 dp 只算了“选哪些数字放到奇数位”，但一个具体的分配（比如放了两个 <code>1</code>、一个 <code>4</code>……）在奇数位这 m 个位置内部还可以<strong>排列</strong>；同样偶数位也可以排列。</p><ul><li>奇数位内部排列数：m! ÷ (每个数字在奇数位放入的次数! 的乘积)</li><li>偶数位内部排列数：(n−m)! ÷ (每个数字剩余次数! 的乘积)</li></ul><p>而在 dp 转移里我们已经用组合数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><msub><mi>c</mi><mi>v</mi></msub><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msub><mi>c</mi><mi>v</mi></msub><mo stretchy="false">!</mo></mrow><mrow><mi>x</mi><mo stretchy="false">!</mo><mo stretchy="false">(</mo><msub><mi>c</mi><mi>v</mi></msub><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">C(c_v, x) = \frac{c_v!}{x! (c_v - x)!}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4162em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mclose mtight">!</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 来考虑了“从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">c_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个里选 x 个”的方法（含了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">x!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">x</span><span class="mclose">!</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mi>v</mi></msub><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">(c_v−x)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)!</span></span></span></span> 的分母）。综合起来，最后直接把</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp<span class="selector-attr">[m]</span><span class="selector-attr">[half]</span> </span><br><span class="line">× m!         （奇数位内部全排列）</span><br><span class="line">× (n−m)!     （偶数位内部全排列）</span><br><span class="line">× Π_v (c_v!)⁻¹  （把之前组合计算中分母的 c_v! 抵消）</span><br><span class="line">mod <span class="number">1</span>e9+<span class="number">7</span></span><br></pre></td></tr></table></figure><p>就得到了完整的排列数。</p><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countBalancedPermutations</span>(<span class="params">self, num: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 中间变量</span></span><br><span class="line">        velunexorai = num</span><br><span class="line">        lomiktrayve = velunexorai</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(lomiktrayve)</span><br><span class="line">        <span class="comment"># 分组大小</span></span><br><span class="line">        m = (n + <span class="number">1</span>) // <span class="number">2</span>  <span class="comment"># 奇数位数量</span></span><br><span class="line">        <span class="comment"># 统计各数字出现次数</span></span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> lomiktrayve:</span><br><span class="line">            cnt[<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 总和及平衡目标</span></span><br><span class="line">        S = <span class="built_in">sum</span>(v * cnt[v] <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">        <span class="keyword">if</span> S &amp; <span class="number">1</span>:  <span class="comment"># 奇数和，不可能平衡</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        half = S // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理阶乘及逆元</span></span><br><span class="line">        maxfact = n</span><br><span class="line">        fact = [<span class="number">1</span>] * (maxfact + <span class="number">1</span>)</span><br><span class="line">        inv_fact = [<span class="number">1</span>] * (maxfact + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, maxfact + <span class="number">1</span>):</span><br><span class="line">            fact[i] = fact[i-<span class="number">1</span>] * i % <span class="variable language_">self</span>.MOD</span><br><span class="line">        inv_fact[maxfact] = <span class="built_in">pow</span>(fact[maxfact], <span class="variable language_">self</span>.MOD-<span class="number">2</span>, <span class="variable language_">self</span>.MOD)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxfact, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            inv_fact[i-<span class="number">1</span>] = inv_fact[i] * i % <span class="variable language_">self</span>.MOD</span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp[k][s]: 考虑前 v 数字后，选入奇数位共 k 个，累积和 s 的方式数</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (half + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转移：对每个数字 v，枚举放入奇数位 x 个</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            c = cnt[v]</span><br><span class="line">            <span class="comment"># 预计算 C(c, x) * (c-x)!^-1 * x!^-1 里的一部分：C(c,x)</span></span><br><span class="line">            comb = [<span class="number">0</span>] * (c + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(c + <span class="number">1</span>):</span><br><span class="line">                comb[x] = fact[c] * inv_fact[x] % <span class="variable language_">self</span>.MOD * inv_fact[c-x] % <span class="variable language_">self</span>.MOD</span><br><span class="line"></span><br><span class="line">            new_dp = [[<span class="number">0</span>] * (half + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(half+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> dp[k][s] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    base = dp[k][s]</span><br><span class="line">                    <span class="comment"># 放 x 个到奇数位</span></span><br><span class="line">                    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(c, m-k) + <span class="number">1</span>):</span><br><span class="line">                        ns = s + v * x</span><br><span class="line">                        <span class="keyword">if</span> ns &gt; half:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        new_dp[k + x][ns] = (new_dp[k + x][ns] + base * comb[x]) % <span class="variable language_">self</span>.MOD</span><br><span class="line">            dp = new_dp</span><br><span class="line"></span><br><span class="line">        ways = dp[m][half]</span><br><span class="line">        <span class="keyword">if</span> ways == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最终乘上 m!*(n-m)!，并除以 ∏c_v!（即乘上每个 c_v! 的逆元）</span></span><br><span class="line">        ans = ways * fact[m] % <span class="variable language_">self</span>.MOD * fact[n-m] % <span class="variable language_">self</span>.MOD</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            ans = ans * inv_fact[cnt[v]] % <span class="variable language_">self</span>.MOD</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以num = &quot;112&quot;为例：</p><ol><li><code>n=3</code>，m=⌈3/2⌉=2，S=1+1+2=4，half=2。</li><li>数字计数：<code>cnt[1]=2</code>，<code>cnt[2]=1</code>，其他都是 0。</li><li>dp 大小是 (m+1=3)×(half+1=3)。</li><li>先处理 v=1，c=2，可以放 x=0,1,2 个到奇数位；再处理 v=2，c=1，可放 x=0,1。</li><li>通过 dp 最终找到 <code>dp[2][2] = 1</code>，表示把恰好 2 个数字放到奇数位，且它们和为 2 的方法只有 1 种（就是放两个 <code>1</code>）。</li><li>乘上 m!×(n–m)! ÷ (2!×1!) = 2!×1! ÷ (2!×1!) = 1，结果仍是 1。</li></ol><p>也就是说，只有排列 <code>&quot;121&quot;</code> 是平衡的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/count-number-of-balanced-permutations/&quot;&gt;3343. 统计平衡排列的数目&lt;/a&gt; H&lt;/h1&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;num&lt;/code&gt; 。如果</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="数位处理" scheme="https://blog.icjlu.eu.org/tags/%E6%95%B0%E4%BD%8D%E5%A4%84%E7%90%86/"/>
    
    <category term="字符串处理" scheme="https://blog.icjlu.eu.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
    <category term="排列组合" scheme="https://blog.icjlu.eu.org/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
    <category term="困难" scheme="https://blog.icjlu.eu.org/tags/%E5%9B%B0%E9%9A%BE/"/>
    
    <category term="组合数学" scheme="https://blog.icjlu.eu.org/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="动态规划" scheme="https://blog.icjlu.eu.org/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-08</title>
    <link href="https://blog.icjlu.eu.org/post/find-minimum-time-to-reach-last-room-ii.html"/>
    <id>https://blog.icjlu.eu.org/post/find-minimum-time-to-reach-last-room-ii.html</id>
    <published>2025-05-08T01:47:31.000Z</published>
    <updated>2025-05-08T13:11:27.405Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-ii/">3342. 到达最后一个房间的最少时间 II</a> M</h1><p>有一个地窖，地窖中有 <code>n x m</code> 个房间，它们呈网格状排布。</p><p>给你一个大小为 <code>n x m</code> 的二维数组 <code>moveTime</code> ，其中 <code>moveTime[i][j]</code> 表示在这个时刻 <strong>以后</strong> 你才可以 <strong>开始</strong> 往这个房间 <strong>移动</strong> 。你在时刻 <code>t = 0</code> 时从房间 <code>(0, 0)</code> 出发，每次可以移动到 <strong>相邻</strong> 的一个房间。在 <strong>相邻</strong> 房间之间移动需要的时间为：第一次花费 1 秒，第二次花费 2 秒，第三次花费 1 秒，第四次花费 2 秒……如此 <strong>往复</strong> 。</p><p>请你返回到达房间 <code>(n - 1, m - 1)</code> 所需要的 <strong>最少</strong> 时间。</p><p>如果两个房间有一条公共边（可以是水平的也可以是竖直的），那么我们称这两个房间是 <strong>相邻</strong> 的。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> moveTime = [[0,4],[4,4]]</p><p><strong>输出：</strong> 7</p><p><strong>解释：</strong></p><p>需要花费的最少时间为 7 秒。</p><ul><li>在时刻 <code>t == 4</code> ，从房间 <code>(0, 0)</code> 移动到房间 <code>(1, 0)</code> ，花费 1 秒。</li><li>在时刻 <code>t == 5</code> ，从房间 <code>(1, 0)</code> 移动到房间 <code>(1, 1)</code> ，花费 2 秒。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> moveTime = [[0,0,0,0],[0,0,0,0]]</p><p><strong>输出：</strong> 6</p><p><strong>解释：</strong></p><p>需要花费的最少时间为 6 秒。</p><ul><li>在时刻 <code>t == 0</code> ，从房间 <code>(0, 0)</code> 移动到房间 <code>(1, 0)</code> ，花费 1 秒。</li><li>在时刻 <code>t == 1</code> ，从房间 <code>(1, 0)</code> 移动到房间 <code>(1, 1)</code> ，花费 2 秒。</li><li>在时刻 <code>t == 3</code> ，从房间 <code>(1, 1)</code> 移动到房间 <code>(1, 2)</code> ，花费 1 秒。</li><li>在时刻 <code>t == 4</code> ，从房间 <code>(1, 2)</code> 移动到房间 <code>(1, 3)</code> ，花费 2 秒。</li></ul></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> moveTime = [[0,1],[1,2]]</p><p><strong>输出：</strong> 4</p></blockquote><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n == moveTime.length &lt;= 750</code></li><li><code>2 &lt;= m == moveTime[i].length &lt;= 750</code></li><li><code>0 &lt;= moveTime[i][j] &lt;= 10⁹</code></li></ul><h2 id="问题分析">问题分析</h2><ul><li>有一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span><span class="mord mathnormal">m</span></span></span></span> 的房间网格，起点是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，终点是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1,m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li><li>你在 <strong>时刻 0</strong> 从起点出发，每次只能向上、下、左、右走一步。</li><li><strong>第 1 步</strong>花费 1 秒，第 2 步花费 2 秒，第 3 步花费 1 秒，第 4 步花费 2 秒，以此类推（奇数步 1 秒，偶数步 2 秒）。</li><li>另外，每个房间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 有一个 <strong>开放时间</strong> <code>moveTime[i][j]</code>，表示 <strong>在此时刻以后</strong>才能进入该房间。如果你走到某房间的时刻还没到它的开放时间，就要在外面等到 <code>moveTime[i][j]</code> 才能进去。</li></ul><p><strong>目标</strong>：求从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1,m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的 <strong>最少</strong> 总耗时。</p><h2 id="算法思路">算法思路</h2><ol><li><p><strong>普通最短路</strong>：</p><ul><li>如果每次移动的耗时固定（比如都 1 秒），经典做法是 <code>BFS</code>；</li><li>如果耗时不固定且无等待，则可以用 <code>Dijkstra</code>（或 <code>SPFA</code>）。</li></ul></li><li><p><strong>本题特点</strong>：</p><ul><li>每一步的耗时 <strong>依赖</strong>于「已经走过的步数是奇数还是偶数」。</li><li>还要考虑「到达时间 &lt; 房间开放时间」时的 <strong>等待</strong>。</li></ul><p>这两点都会影响「从一个节点走到另一个节点的实际耗时」，而且这个耗时不是固定的常数。</p></li><li><p><strong>带状态建模</strong>：</p><ul><li>我们把“走过步数的奇偶”当成状态之一。</li><li>状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j,p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span> 表示「当前位置在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 且已经走了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 步，且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mi>k</mi><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">p = k \bmod 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>」（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 代表下一步是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 步且为奇数；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 代表下一步为偶数）。</li></ul></li><li><p><strong>状态转移</strong>：</p><ul><li><p>从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j,p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span> 可以去相邻的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(ni,nj)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">ni</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">nj</span><span class="mclose">)</span></span></span></span>，新的奇偶状态是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>p</mi><mo>=</mo><mn>1</mn><mo>−</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">np = 1 - p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>。</p><p>计算本步原始移动耗时：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若 </mtext><mi>n</mi><mi>p</mi><mo>=</mo><mn>1</mn><mtext> </mtext><mo stretchy="false">(</mo><mtext>下一步是奇数步</mtext><mo stretchy="false">)</mo><mo separator="true">;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若 </mtext><mi>n</mi><mi>p</mi><mo>=</mo><mn>0</mn><mtext> </mtext><mo stretchy="false">(</mo><mtext>下一步是偶数步</mtext><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">w = \begin{cases}     1, &amp; \text{若 }np = 1\ (\text{下一步是奇数步});\\     2, &amp; \text{若 }np = 0\ (\text{下一步是偶数步}).   \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">2</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">若</span><span class="mord"> </span></span><span class="mord mathnormal">n</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord text"><span class="mord cjk_fallback">下一步是奇数步</span></span><span class="mclose">)</span><span class="mpunct">;</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">若</span><span class="mord"> </span></span><span class="mord mathnormal">n</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord text"><span class="mord cjk_fallback">下一步是偶数步</span></span><span class="mclose">)</span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><p>等待时机：</p><ul><li><p>你要在房间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(ni,nj)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">ni</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">nj</span><span class="mclose">)</span></span></span></span> 开放后才能 <strong>开始</strong> 这一步移动，<br>所以先算</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>t</mi><mtext>start</mtext></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><msub><mi>t</mi><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">r</mi></mrow></msub><mo separator="true">,</mo><mtext> </mtext><mtext>moveTime</mtext><mo stretchy="false">[</mo><mi>n</mi><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mi>j</mi><mo stretchy="false">]</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">t_{\text{start}} = \max\bigl(t_{\rm cur},\,\text{moveTime}[ni][nj]\bigr).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">start</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mop">max</span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">cur</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">moveTime</span></span><span class="mopen">[</span><span class="mord mathnormal">ni</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">nj</span><span class="mclose">]</span><span class="mclose"><span class="delimsizing size1">)</span></span><span class="mord">.</span></span></span></span></span></p></li><li><p>然后再花费 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 秒到达：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>t</mi><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">w</mi></mrow></msub><mo>=</mo><msub><mi>t</mi><mtext>start</mtext></msub><mo>+</mo><mi>w</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">t_{\rm new} = t_{\text{start}} + w.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right:0.01389em;">new</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">start</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord">.</span></span></span></span></span></p></li></ul></li></ul></li><li><p><strong>使用 Dijkstra</strong></p><ul><li>定义 <code>dist[i][j][p]</code> 为达到状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j,p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span> 的最小时间。</li><li>初始只有 <code>dist[0][0][0] = max(0, moveTime[0][0])</code>（在起点，如果起点开放时间 &gt; 0，需要先等）。</li><li>其余 <code>dist</code> 值初始化为无穷大；每次从最小堆中弹出当前最小时间状态，按上面“状态转移”规则进行松弛，将新的状态和时间压回堆中，即可得到最终答案。</li></ul></li></ol><h2 id="时间复杂度">时间复杂度</h2><ul><li><strong>时间复杂度</strong>：节点总数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">2nm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">nm</span></span></span></span>，每个节点通过堆的「插入 / 弹出」复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log(nm))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">nm</span><span class="mclose">))</span></span></span></span>，总体时间复杂度约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm \log(nm))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">nm</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">nm</span><span class="mclose">))</span></span></span></span></li><li><strong>空间复杂度</strong>：<code>dist</code> 数组大小<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">)</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo>×</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">)O(n \times m \times 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>。</li></ul><h2 id="代码分解">代码分解</h2><p><strong>1.初始化 dist 数组</strong></p><ul><li>三维数组，最后一维长度 2，用来区分「已走步数对 2 取模的结果」。</li><li>所有状态初始为无穷大。</li></ul><p><strong>2.起点状态</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">max</span>(<span class="number">0</span>, moveTime[<span class="number">0</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li>还没走步（步数 = 0），因此 <code>p = 0</code>。</li><li>如果 <code>moveTime[0][0] &gt; 0</code>，在起点就要等到它开放。</li></ul><p><strong>3.Dijkstra 核心</strong></p><ul><li>使用最小堆 (<code>heapq</code>) 每次取当前能到达的「时间最小」的状态。</li><li>如果这个状态比 <code>dist</code> 中记录的旧，就跳过。</li><li>否则，对四个方向尝试松弛：<ul><li>计算下一步是奇数步还是偶数步，决定 <code>step_cost = 1 or 2</code>。</li><li>到达时间 = 当前时间 + <code>step_cost</code>，如果早于目标房间的 <code>moveTime</code>，再把时间推进到 <code>moveTime</code>。</li><li>比较并更新 <code>dist[ni][nj][np]</code>。</li></ul></li></ul><p><strong>4.提前结束</strong><br>一旦弹出的状态是终点，就可以立即返回它的时间，因为堆保证这是最小的。</p><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minTimeToReach</span>(<span class="params">self, moveTime: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        veltarunez = moveTime</span><br><span class="line"></span><br><span class="line">        n, m = <span class="built_in">len</span>(moveTime), <span class="built_in">len</span>(moveTime[<span class="number">0</span>])</span><br><span class="line">        INF = <span class="number">10</span>**<span class="number">18</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dist[i][j][p]: 达到 (i,j) 且已走步数 mod 2 = p 时，所需最少时间</span></span><br><span class="line">        dist = [[[INF] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> __ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 起点 (0,0)，还没走步，步数 mod 2 = 0</span></span><br><span class="line">        <span class="comment"># 需要先等到房间开放：起点 (0,0)，步数=0 =&gt; p=0，时间=0</span></span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最小堆，存放 (当前时间, i, j, 步数 mod 2)</span></span><br><span class="line">        heap = [(dist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 四个方向</span></span><br><span class="line">        dirs = [(<span class="number">1</span>,<span class="number">0</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ——————————————</span></span><br><span class="line">        <span class="comment"># 2) Dijkstra 主循环</span></span><br><span class="line">        <span class="comment"># ——————————————</span></span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            t, i, j, p = heapq.heappop(heap)</span><br><span class="line">            <span class="comment"># 如果不是最新的最短时间，跳过</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; dist[i][j][p]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果到达终点 (n-1,m-1)，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> i == n-<span class="number">1</span> <span class="keyword">and</span> j == m-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 尝试所有相邻房间</span></span><br><span class="line">            <span class="keyword">for</span> di, dj <span class="keyword">in</span> dirs:</span><br><span class="line">                ni, nj = i + di, j + dj</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= ni &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= nj &lt; m:</span><br><span class="line">                    np = <span class="number">1</span> - p  <span class="comment"># 新的步数奇偶</span></span><br><span class="line">                    <span class="comment"># 计算移动耗时：奇数步 1s，偶数步 2s</span></span><br><span class="line">                    w = <span class="number">1</span> <span class="keyword">if</span> np == <span class="number">1</span> <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">                    <span class="comment"># 如果过早到达，必须等到开放时间</span></span><br><span class="line">                    t_start = <span class="built_in">max</span>(t, moveTime[ni][nj])</span><br><span class="line">                    t_new = t_start + w</span><br><span class="line">                    <span class="comment"># 松弛操作</span></span><br><span class="line">                    <span class="keyword">if</span> t_new &lt; dist[ni][nj][np]:</span><br><span class="line">                        dist[ni][nj][np] = t_new</span><br><span class="line">                        heapq.heappush(heap, (t_new, ni, nj, np))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果堆空还没到终点，说明无法到达</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-ii/&quot;&gt;3342. 到达最后一个房间的最少时间 II&lt;/a&gt; M&lt;/h1&gt;
&lt;p&gt;有一个地窖，地窖中有 &lt;code&gt;n </summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="中等" scheme="https://blog.icjlu.eu.org/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="图算法" scheme="https://blog.icjlu.eu.org/tags/%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    
    <category term="状态建模" scheme="https://blog.icjlu.eu.org/tags/%E7%8A%B6%E6%80%81%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="最短路径" scheme="https://blog.icjlu.eu.org/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    <category term="Dijkstra" scheme="https://blog.icjlu.eu.org/tags/Dijkstra/"/>
    
    <category term="优先队列" scheme="https://blog.icjlu.eu.org/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日一题2025-05-07</title>
    <link href="https://blog.icjlu.eu.org/post/find-minimum-time-to-reach-last-room-i.html"/>
    <id>https://blog.icjlu.eu.org/post/find-minimum-time-to-reach-last-room-i.html</id>
    <published>2025-05-07T01:50:07.000Z</published>
    <updated>2025-05-07T03:45:14.699Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-i/">3341. 到达最后一个房间的最少时间 I</a> M</h1><p>有一个地窖，地窖中有 <code>n x m</code> 个房间，它们呈网格状排布。</p><p>给你一个大小为 <code>n x m</code> 的二维数组 <code>moveTime</code> ，其中 <code>moveTime[i][j]</code> 表示在这个时刻 <strong>以后</strong> 你才可以 <strong>开始</strong> 往这个房间 <strong>移动</strong> 。你在时刻 <code>t = 0</code> 时从房间 <code>(0, 0)</code> 出发，每次可以移动到 <strong>相邻</strong> 的一个房间。在 <strong>相邻</strong> 房间之间移动需要的时间为 1 秒。</p><p>请你返回到达房间 <code>(n - 1, m - 1)</code> 所需要的 <strong>最少</strong> 时间。</p><p>如果两个房间有一条公共边（可以是水平的也可以是竖直的），那么我们称这两个房间是 <strong>相邻</strong> 的。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> moveTime = [[0,4],[4,4]]</p><p><strong>输出：</strong> 6</p><p><strong>解释：</strong></p><p>需要花费的最少时间为 6 秒。</p><ul><li>在时刻 <code>t == 4</code> ，从房间 <code>(0, 0)</code> 移动到房间 <code>(1, 0)</code> ，花费 1 秒。</li><li>在时刻 <code>t == 5</code> ，从房间 <code>(1, 0)</code> 移动到房间 <code>(1, 1)</code> ，花费 1 秒。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> moveTime = [[0,0,0],[0,0,0]]</p><p><strong>输出：</strong> 3</p><p><strong>解释：</strong></p><p>需要花费的最少时间为 3 秒。</p><ul><li>在时刻 <code>t == 0</code> ，从房间 <code>(0, 0)</code> 移动到房间 <code>(1, 0)</code> ，花费 1 秒。</li><li>在时刻 <code>t == 1</code> ，从房间 <code>(1, 0)</code> 移动到房间 <code>(1, 1)</code> ，花费 1 秒。</li><li>在时刻 <code>t == 2</code> ，从房间 <code>(1, 1)</code> 移动到房间 <code>(1, 2)</code> ，花费 1 秒。</li></ul></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> moveTime = [[0,1],[1,2]]</p><p><strong>输出：</strong> 3</p></blockquote><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n == moveTime.length &lt;= 50</code></li><li><code>2 &lt;= m == moveTime[i].length &lt;= 50</code></li><li><code>0 &lt;= moveTime[i][j] &lt;= 10⁹</code></li></ul><h2 id="问题分析">问题分析</h2><ol><li><p>有一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 的房间网格，比如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>,<span class="number">0</span>)  (<span class="number">0</span>,<span class="number">1</span>)  (<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>,<span class="number">0</span>)  (<span class="number">1</span>,<span class="number">1</span>)  (<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>你从左上角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 出发，要到达右下角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1,m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p></li><li><p>每一秒你只能走到上下左右的一个相邻房间，耗时 <strong>1 秒</strong>。</p></li><li><p>但每个房间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 有一个 “开放时间” <code>moveTime[i][j]</code>，表示你 <strong>必须等到</strong> 这个时间点才能进它。如果你早到了，就要在前一个房间多“等候”。</p></li></ol><blockquote><p><strong>举例</strong>：假设你在时刻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">t=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 想去 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，但 <code>moveTime[1][0] = 5</code>，那么你要在当前房间再等 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>−</mo><mn>2</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">5 - 2 = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 秒，等到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">t=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 才能开始那 1 秒的移动，总共到达就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">t=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span>。</p></blockquote><p>这是一个带“等待时间”约束的最短路径问题。我们有一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 的网格，每个格子 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 上有一个时间戳 <code>moveTime[i][j]</code>，表示<strong>只有在该时刻及之后</strong>才可以开始进入这个房间。从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 出发，时间从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 开始，每次移动到相邻房间需要 1 秒。若当前时刻为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>，要移动到邻居格子 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>：</p><ol><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>&lt;</mo><mtext>moveTime</mtext><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t &lt; \text{moveTime}[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">moveTime</span></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>，则需要在原地等待到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>moveTime</mtext><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\text{moveTime}[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">moveTime</span></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>；</li><li>然后再花 1 秒移动过去；</li><li>到达后的时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mtext>moveTime</mtext><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\max(t,\text{moveTime}[x][y]) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">moveTime</span></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</li></ol><h2 id="算法思路">算法思路</h2><p>最普通的最短路径（或网格最短移动）问题，如果每步都只花 1 秒，那么就是简单的 BFS（广度优先搜索），一层一层走就行。</p><p>但这里 <strong>“等候时间”</strong> 让每一步的耗时不再固定——它取决于“你到达当前格子的时间”与“下一个格子的开放时间”之差。</p><p>由于不同路径的等待时间和移动次数不同，我们需要在加权图上求最短路径。网格中每个格子是一个节点，相邻格子间的边权等于“等待时间 + 1”，而边权依赖于到达时刻，属于带<strong>非固定权重</strong>的最短路径问题。故可用 <strong>Dijkstra 算法</strong>（带优先队列的贪心方法）动态松弛。</p><p>Dijkstra 算法的核心在于：</p><ul><li><strong>贪心选择</strong>：每次从堆里取出“当前可达时间最小”的那个格子，相当于“已经确定”这就是到该格子的最早到达时间。</li><li>然后再用它去更新它的邻居。</li><li>这样不需要回头修正，因所有边权（在当前时刻的等待+1）都是非负的。</li></ul><ol><li><p><strong>dist[i][j]</strong>：一个和网格同样大小的二维数组，记录“到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的<strong>最早时间</strong>”。</p><ul><li>初始时，所有格子都设为 “无穷大”（<code>∞</code>），表示还没到过。</li><li>起点 <code>dist[0][0] = 0</code>，因为一开始就在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，时间 0。</li></ul></li><li><p><strong>优先队列（最小堆）</strong>：存储“当前已知能到达的格子”及其“到达时间”，每次先处理时间最小者。</p><ul><li><p>元素格式是 <code>(time, x, y)</code>，代表“已知到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 最早可以在 <code>time</code> 时刻到达”。</p></li><li><p>原地等待：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>wait</mtext><mo>=</mo><mi>max</mi><mo>⁡</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mn>0</mn><mo separator="true">,</mo><mtext>  </mtext><mtext>moveTime</mtext><mo stretchy="false">[</mo><mi>n</mi><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mi>y</mi><mo stretchy="false">]</mo><mo>−</mo><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo></mrow><annotation encoding="application/x-tex">\text{wait} = \max\bigl(0,\;\text{moveTime}[nx][ny] - time\bigr)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord text"><span class="mord">wait</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mop">max</span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">moveTime</span></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span><span class="mclose"><span class="delimsizing size1">)</span></span></span></span></span></span></p><p>如果你已经迟到了（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>≥</mo><mtext>moveTime</mtext><mo stretchy="false">[</mo><mi>n</mi><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">time\ge \text{moveTime}[nx][ny]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">moveTime</span></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>），那就无需等待，<code>wait = 0</code>；否则需要等到它开放。</p></li><li><p>总时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mtext>new</mtext></msub><mo>=</mo><mi>t</mi><mo>+</mo><mtext>wait</mtext><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t_{\text{new}} = t + \text{wait} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">new</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7512em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord">wait</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，如果 <code>t_new &lt; dist[nx][ny]</code>，就更新 <code>dist[nx][ny] = t_new</code> 并推入堆里。</p></li><li><p>Python 里，我们用 <code>import heapq</code> 来实现这个最小堆。</p></li></ul></li></ol><h2 id="时间复杂度">时间复杂度</h2><ul><li><p>网格共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mi>n</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">N = nm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">nm</span></span></span></span> 个节点，<strong>Dijkstra</strong> 算法每条边松弛一次，共约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">4N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 条边。</p></li><li><p>使用二叉堆，插入与弹出操作各 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p></li><li><p>整体复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm \log(nm))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">nm</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">nm</span><span class="mclose">))</span></span></span></span>。</p></li></ul><h2 id="代码分解">代码分解</h2><p><strong>1. 初始化</strong></p><ul><li>读取输入 <code>moveTime</code>，并在函数中赋值给变量 <code>veltarunez</code>（要求）。</li><li>定义方向数组 <code>dirs = [(1,0),(-1,0),(0,1),(0,-1)]</code>。</li></ul><p><strong>2. 距离矩阵</strong></p><ul><li>创建 <code>dist</code> 二维数组，大小同 <code>moveTime</code>，初始值为无穷大 <code>inf</code>。</li><li><code>dist[0][0] = 0</code>。</li></ul><p><strong>3. 优先队列</strong></p><ul><li>用 Python 的 <code>heapq</code>，存储 <code>(当前到达时间 t, x, y)</code>。</li><li>初始状态：<code>heap = [(0, 0, 0)]</code>。</li></ul><p><strong>4. 松弛操作</strong></p><ul><li><p>弹出队首 <code>(t, x, y)</code>，若 <code>t &gt; dist[x][y]</code> 则跳过。</p></li><li><p>对四个方向 <code>(nx, ny)</code>：判断越界后，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait = <span class="built_in">max</span>(<span class="number">0</span>, veltarunez[nx][ny] - t)</span><br><span class="line">nt = t + wait + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> nt &lt; dist[nx][ny]:</span><br><span class="line">    dist[nx][ny] = nt</span><br><span class="line">    heapq.heappush(heap, (nt, nx, ny))</span><br></pre></td></tr></table></figure></li></ul><p><strong>5. 终止</strong></p><ul><li>当弹出节点是目标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1, m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时，可直接返回其 <code>t</code>。</li><li>或者等队列空后取 <code>dist[n-1][m-1]</code>。</li></ul><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minTimeToReach</span>(<span class="params">self, moveTime: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 将输入存储到变量 veltarunez</span></span><br><span class="line">        veltarunez = moveTime</span><br><span class="line">        </span><br><span class="line">        n, m = <span class="built_in">len</span>(veltarunez), <span class="built_in">len</span>(veltarunez[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 距离矩阵，初始化为无穷大</span></span><br><span class="line">        dist = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 最小堆，元素为 (当前到达时间, x, y)</span></span><br><span class="line">        heap = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 四个方向</span></span><br><span class="line">        dirs = [(<span class="number">1</span>,<span class="number">0</span>), (-<span class="number">1</span>,<span class="number">0</span>), (<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            t, x, y = heapq.heappop(heap)</span><br><span class="line">            <span class="comment"># 如果已不是最优，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; dist[x][y]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果到达终点，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> x == n-<span class="number">1</span> <span class="keyword">and</span> y == m-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> t</span><br><span class="line">            <span class="comment"># 松弛相邻边</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> dirs:</span><br><span class="line">                nx, ny = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; m:</span><br><span class="line">                    <span class="comment"># 计算需要等待的时间</span></span><br><span class="line">                    wait = <span class="built_in">max</span>(<span class="number">0</span>, veltarunez[nx][ny] - t)</span><br><span class="line">                    nt = t + wait + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> nt &lt; dist[nx][ny]:</span><br><span class="line">                        dist[nx][ny] = nt</span><br><span class="line">                        heapq.heappush(heap, (nt, nx, ny))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回最终结果</span></span><br><span class="line">        <span class="keyword">return</span> dist[n-<span class="number">1</span>][m-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以 <code>moveTime = [[0,2],[1,3]]</code>为例：</p><table><thead><tr><th>步骤</th><th>堆的状态</th><th>弹出元素</th><th>操作细节</th><th>dist 更新</th></tr></thead><tbody><tr><td>初始</td><td><code>[(0, 0, 0)]</code></td><td>无</td><td>无</td><td><code>[[0, ∞], [∞, ∞]]</code></td></tr><tr><td>第1步</td><td><code>[(2,1,0),(3,0,1)]</code></td><td><code>(0,0,0)</code></td><td>从 (0,0) 弹出，查看四个方向：<br>- 右边 (0,1)：<code>wait = max(0, 2-0)=2</code>，<code>new_time =0+2+1=3</code>，堆入 <code>(3,0,1)</code><br>- 下边 (1,0)：<code>wait = max(0,1-0)=1</code>，<code>new_time =0+1+1=2</code>，堆入 <code>(2,1,0)</code></td><td>更新为 <code>[[0,3],[2,∞]]</code></td></tr><tr><td>第2步</td><td><code>[(3,0,1), (4,1,1)]</code></td><td><code>(2,1,0)</code></td><td>从 (1,0) 弹出，查看四个方向：<br>- 右边 (1,1)：<code>wait = max(0,3-2)=1</code>，<code>new_time =2+1+1=4</code>，堆入 <code>(4,1,1)</code><br>- 上边 (0,0)：已有更优值 <code>dist[0][0] = 0</code>，不更新</td><td>更新为 <code>[[0,3],[2,4]]</code></td></tr><tr><td>第3步</td><td><code>[(4,1,1)]</code></td><td><code>(3,0,1)</code></td><td>从 (0,1) 弹出，查看四个方向：<br>- 下边 (1,1)：<code>wait = max(0,3-3)=0</code>，<code>new_time =3+0+1=4</code>，与当前 <code>dist[1][1] =4</code> 相同，不更新</td><td>无变化</td></tr><tr><td><strong>第4步</strong></td><td><strong>空</strong></td><td><code>(4,1,1)</code></td><td>弹出 <code>(4,1,1)</code>，到达终点，返回答案 <strong>4</strong></td><td><strong>无变化</strong></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-i/&quot;&gt;3341. 到达最后一个房间的最少时间 I&lt;/a&gt; M&lt;/h1&gt;
&lt;p&gt;有一个地窖，地窖中有 &lt;code&gt;n x </summary>
      
    
    
    
    <category term="算法" scheme="https://blog.icjlu.eu.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://blog.icjlu.eu.org/tags/Algorithm/"/>
    
    <category term="数据结构" scheme="https://blog.icjlu.eu.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="中等" scheme="https://blog.icjlu.eu.org/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="贪心" scheme="https://blog.icjlu.eu.org/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="图算法" scheme="https://blog.icjlu.eu.org/tags/%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    
    <category term="最短路径" scheme="https://blog.icjlu.eu.org/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    <category term="Dijkstra" scheme="https://blog.icjlu.eu.org/tags/Dijkstra/"/>
    
    <category term="优先队列" scheme="https://blog.icjlu.eu.org/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="BFS" scheme="https://blog.icjlu.eu.org/tags/BFS/"/>
    
  </entry>
  
</feed>
